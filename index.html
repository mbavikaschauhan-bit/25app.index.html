<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tradlyst - Trading Journal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Apply theme immediately to prevent flicker
        (function() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
            
            // Set theme toggle button state immediately when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                const themeToggle = document.getElementById('theme-toggle');
                if (themeToggle) {
                    themeToggle.checked = savedTheme === 'dark';
                }
            });
        })();
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/styles.css">
    <script src="js/utils.js" defer></script>
    <script src="js/datastore.js" defer></script>
    <script src="js/compat.js" defer></script>
    <script src="js/ui_helpers.js" defer></script>
    <script src="js/ui.js" defer></script>
    <script src="js/auth.js" defer></script>
    <script src="js/auth_state.js" defer></script>
    <script src="js/main.js" defer></script>
    <script src="js/init.js" defer></script>
</head>
<body class="antialiased">

    <div id="toast-container"></div>

    <!-- NEW: Auth Container -->
        <div id="auth-container" class="min-h-screen flex items-center justify-center">
        <div class="w-full max-w-sm p-8 space-y-6 rounded-lg shadow-lg" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
            <form id="auth-form">
                <div class="text-center mb-6">
                    <h1 class="text-3xl font-bold">
                        <span style="color: #22c55e;">Tradlyst</span>
                    </h1>
                    <h2 id="auth-title" class="text-2xl font-semibold mt-4" style="color: var(--text-primary);">Sign In</h2>
                    <p class="text-sm" style="color: var(--text-secondary);">Welcome back to your trading journal</p>
                </div>
                
                <div>
                    <label for="auth-email" class="block text-sm font-medium" style="color: var(--text-secondary);">Email Address</label>
                    <input type="email" id="auth-email" required class="mt-1 w-full px-4 py-2 rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="email">
                </div>
                <div>
                    <label for="auth-password" class="block text-sm font-medium" style="color: var(--text-secondary);">Password</label>
                    <input type="password" id="auth-password" required class="mt-1 w-full px-4 py-2 rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="current-password">
                </div>
                
                <p id="auth-message" class="text-sm text-center h-4"></p>
                
                <button type="submit" id="auth-submit-btn" class="w-full btn-primary font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center">
                    <span class="btn-text">Sign In</span>
                    <span class="spinner hidden"></span>
                </button>
                
                <div class="text-center text-sm mt-4">
                    <a href="#" id="auth-toggle-link" class="font-medium text-blue-600 hover:underline">Don't have an account? Sign up</a>
                </div>
            </form>
        </div>
    </div>


    <!-- Main App Wrapper -->
        <div id="app-container" class="relative h-screen md:flex">
        <!-- Sidebar -->
        <aside id="sidebar" class="w-64 flex-shrink-0 flex-col fixed left-0 z-20 transform -translate-x-full md:translate-x-0 transition-transform duration-200 ease-in-out flex" style="background-color: var(--bg-primary); border-right: 1px solid var(--border-color); top: 65px; height: calc(100vh - 65px);">
            <nav class="flex-1 px-4 py-4 space-y-2">
                <a href="#" data-page="dashboard" class="nav-item flex items-center px-4 py-2 rounded-md active" style="color: var(--text-secondary);">
                    <i data-feather="home" class="mr-3 h-5 w-5"></i> <span>Dashboard</span>
                </a>
                <a href="#" data-page="add-trade" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="plus-circle" class="mr-3 h-5 w-5"></i> <span>Add Trade</span>
                </a>
                <a href="#" data-page="trade-calendar" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="calendar" class="mr-3 h-5 w-5"></i> <span>Trading Calendar</span>
                </a>
                <a href="#" data-page="trade-history" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="list" class="mr-3 h-5 w-5"></i> <span>Trade History</span>
                </a>
                <a href="#" data-page="fund-management" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i class="mr-3 h-5 w-5 flex items-center justify-center font-bold text-lg not-italic">₹</i>
                    <span>Fund Management</span>
                </a>
                <a href="#" data-page="reports" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="bar-chart-2" class="mr-3 h-5 w-5"></i> <span>Reports</span>
                </a>
                <a href="#" data-page="trade-statement" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="file-text" class="mr-3 h-5 w-5"></i> <span>Trade Statement</span>
                </a>
                <a href="#" data-page="challenge" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="award" class="mr-3 h-5 w-5"></i> <span>Challenge</span>
                </a>
                <a href="#" data-page="ai-analyst" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="cpu" class="mr-3 h-5 w-5"></i> <span>AI Analyst</span>
                </a>
                <a href="#" data-page="profile" class="nav-item flex items-center px-4 py-2 rounded-md" style="color: var(--text-secondary);">
                    <i data-feather="user" class="mr-3 h-5 w-5"></i> <span>User Profile</span>
                </a>
            </nav>
        </aside>

        <!-- Main Content -->
        <div class="flex flex-col flex-1 w-full overflow-hidden">
             <header class="fixed top-0 backdrop-blur-lg z-50 h-16 flex items-center justify-between px-4 md:px-8" style="background-color: var(--bg-primary); border-bottom: 1px solid var(--border-color); left: 0; right: 0;">
                <div class="flex items-center space-x-4">
                    <img src="logo.png" alt="Tradlyst Trading Journal" class="h-10 w-auto object-contain" />
                    <button id="menu-toggle-btn" class="md:hidden p-2 rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                        <i data-feather="menu" class="h-6 w-6"></i>
                    </button>
                    <h2 id="page-title" class="text-xl font-semibold" style="color: var(--text-primary);"></h2>
                </div>

                <div class="flex items-center space-x-2 md:space-x-4">
                    <p id="user-display-name" class="hidden md:block text-sm font-medium" style="color: var(--text-secondary);"></p>
                    <div id="connection-status" class="connection-status unknown hidden md:flex items-center">
                        <div class="w-2 h-2 rounded-full"></div>
                        <span>Syncing...</span>
                    </div>
                    <div class="flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-500"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                        <label for="theme-toggle-input" class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" value="" id="theme-toggle-input" class="sr-only peer">
                            <div class="w-11 h-6 bg-slate-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-400"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                    </div>
                     <button class="logout-btn p-2 rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);" title="Logout">
                         <i data-feather="log-out" class="h-5 w-5"></i>
                    </button>
                </div>
            </header>
            
            <main id="main-content" class="flex-1 overflow-y-auto" style="padding-top: 4rem;">
                <div class="p-4 md:p-8">
                    <!-- Dashboard Page -->
                    <div id="dashboard" class="page active">
                        
                        <!-- Analytics Section with Date Filter -->
                        <div class="flex flex-col sm:flex-row gap-4 mb-6 items-start sm:items-center justify-between">
                            <h2 class="text-2xl font-bold" style="color: var(--text-primary);">Analytics</h2>
                            
                        </div>
                        
                        <!-- Performance Stats -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <div class="p-5 rounded-lg shadow-sm text-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Net P&L</h3>
                                <p id="db-net-pnl" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">₹0.00</p>
                                <div class="flex justify-center items-center mt-1 space-x-3">
                                    <p id="db-net-pnl-percentage" class="text-xs font-bold">0.00%</p>
                                    <p id="db-total-trades" class="text-xs" style="color: var(--text-muted);">0 trades</p>
                                </div>
                            </div>
                            <div class="p-5 rounded-lg shadow-sm text-center relative" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-sm font-medium" style="color: var(--text-secondary);">
                                    Win Rate 
                                    <span class="info-tooltip-trigger cursor-pointer ml-1 text-xs inline-block w-4 h-4 rounded-full text-center leading-4" style="color: var(--text-muted); background-color: var(--bg-secondary);">?</span>
                                    <div class="info-tooltip absolute z-50 rounded-lg shadow-lg" 
                                         style="background-color: #D3D3D3; color: #ffffff; border: 1px solid #B0B0B0; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3); top: -105px; left: 50%; transform: translateX(-50%); width: 220px; font-size: 0.75rem; padding: 0.5rem;" data-tooltip-position="auto">
                                        <div class="font-semibold mb-1" style="color: #ffffff; font-size: 0.8em;">Win Rate</div>
                                        <div class="bg-gray-600 px-2 py-1 rounded text-white text-center mb-1" style="font-size: 0.9em;">wins ÷ total trades × 100</div>
                                        <div style="color: #ffffff; font-size: 0.85em; line-height: 1.3;">
                                            <div>• Percent of trades that ended in profit.</div>
                                            <div>• Bar below fills to your win percentage.</div>
                                            <div>• Badges show number of wins and losses.</div>
                                        </div>
                                    </div>
                                </h3>
                                <p id="db-win-rate" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0%</p>
                                <div class="flex items-center justify-center text-xs" style="color: var(--text-muted);">
                                    <span id="db-won-trades" class="text-green-500 mr-2">0 won</span>
                                    <span id="db-lost-trades" class="text-red-500">0 lost</span>
                                </div>
                            </div>
                            <div class="p-5 rounded-lg shadow-sm text-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Profit Factor</h3>
                                <p id="db-profit-factor" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0.00</p>
                                <p class="text-xs" style="color: var(--text-muted);">You make ₹<span id="profit-factor-ratio">0.00</span> for every ₹1 lost</p>
                            </div>
                            <div class="p-5 rounded-lg shadow-sm text-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Avg win/loss trade</h3>
                                <p id="db-avg-win-loss" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0.00</p>
                                <div class="flex items-center justify-center text-xs" style="color: var(--text-muted);">
                                    <span id="db-avg-win" class="text-green-500 mr-2">+₹0.00</span>
                                    <span id="db-avg-loss" class="text-red-500">-₹0.00</span>
                                </div>
                            </div>
                        </div>

                        <!-- Account Summary -->
                        <div class="rounded-lg shadow-sm p-6 mb-8" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Account Summary</h3>
                            <div id="db-account-summary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                                <div><p class="text-sm" style="color: var(--text-secondary);">NET ACCOUNT VALUE</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">NET REALIZED P&L</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">AVAILABLE CASH</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">DEPLOYED CAPITAL</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL DEPOSITS</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL WITHDRAWN</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm" style="color: var(--text-secondary);">STARTING BALANCE</p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                                <div><p class="text-sm font-medium" style="color: var(--text-secondary);">TOTAL OPEN RISK <span class="text-xs">(0.0%)</span></p><p class="text-2xl font-bold" style="color: var(--text-primary);">Loading...</p></div>
                            </div>
                        </div>
                        
                        <!-- Open Positions Overview - Full Width -->
                        <div class="rounded-lg shadow-sm p-4 mb-8" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex items-center justify-between mb-4">
                                <div>
                                    <h3 class="text-xl font-bold" style="color: var(--text-primary);">Open Positions Overview</h3>
                                    <p class="text-sm mt-1" style="color: var(--text-secondary);">Comprehensive analysis of your current <span id="open-positions-count">0</span> open position<span id="open-positions-plural">s</span></p>
                                </div>
                                <span class="px-3 py-2 text-sm rounded-full" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">
                                    <i data-feather="clock" class="inline-block h-4 w-4 mr-2"></i>
                                    Top 5 by Days Open
                                </span>
                            </div>
                            
                            <!-- Open Positions Cards - Expanded Grid -->
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-4">
                                <!-- Capital Deployed -->
                                <div class="rounded-lg p-3" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">Capital Deployed</p>
                                    <p id="capital-deployed-amount" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">₹0.00</p>
                                    <p id="capital-deployed-description" class="text-sm mt-1" style="color: var(--text-muted);">0 open trade<span id="capital-deployed-plural">s</span></p>
                                </div>
                                
                                <!-- Total Open Risk -->
                                <div class="rounded-lg p-3" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">Total Open Risk</p>
                                    <p id="total-open-risk-amount-overview" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">₹0.00</p>
                                    <p class="text-sm mt-1" style="color: var(--text-muted);">At trailing SL / SL</p>
                                </div>
                                
                                <!-- Avg. Time Open -->
                                <div class="rounded-lg p-3" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">Avg. Time Open</p>
                                    <p id="avg-time-open" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0</p>
                                    <p class="text-sm mt-1" style="color: var(--text-muted);">Days per position</p>
                                </div>
                                
                                <!-- Strategy Mix -->
                                <div class="rounded-lg p-3" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <p class="text-sm font-medium mb-3" style="color: var(--text-secondary);">Strategy Mix</p>
                                    <div class="space-y-2">
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center space-x-2">
                                                <div id="long-dot" class="w-3 h-3 rounded-full" style="background-color: #10b981;"></div>
                                                <span class="text-sm" style="color: var(--text-primary);">Long</span>
                                            </div>
                                            <span id="long-percentage" class="text-sm font-medium" style="color: var(--text-primary);">0%</span>
                                        </div>
                                        <div class="flex items-center justify-between">
                                            <div class="flex items-center space-x-2">
                                                <div id="short-dot" class="w-3 h-3 rounded-full" style="background-color: #ef4444;"></div>
                                                <span class="text-sm" style="color: var(--text-primary);">Short</span>
                                            </div>
                                            <span id="short-percentage" class="text-sm font-medium" style="color: var(--text-primary);">0%</span>
                                        </div>
                                        <div class="mt-2">
                                            <div class="flex h-2 rounded-full overflow-hidden" style="background-color: rgba(128, 128, 128, 0.2);">
                                                <div id="long-bar" class="transition-all duration-300" style="background-color: #10b981; width: 0%;"></div>
                                                <div id="short-bar" class="transition-all duration-300" style="background-color: #ef4444; width: 0%;"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Open Positions List - Expanded -->
                            <div>
                                <h4 class="text-lg font-semibold mb-3" style="color: var(--text-primary);">Open Positions</h4>
                                <div id="open-positions-list" class="space-y-2">
                                    <!-- Open positions will be populated here -->
                                </div>
                            </div>
                        </div>

                        <!-- Top Trades - Now standalone -->
                        <div class="rounded-lg shadow-sm p-6 mb-8" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex justify-between items-center mb-4">
                               <h3 class="text-xl font-bold" style="color: var(--text-primary);">Top Trades</h3>
                               <a href="#" data-page="trade-history" class="nav-item text-sm font-medium text-blue-600 hover:underline">View All Trades</a>
                            </div>
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <div class="space-y-2">
                                    <h4 class="text-lg font-semibold mb-3" style="color: var(--text-primary);">Top 5 Winners</h4>
                                    <div id="dashboard-top-winners" class="space-y-2">
                                        <!-- Top winners will be rendered here -->
                                    </div>
                                </div>
                                <div class="space-y-2">
                                    <h4 class="text-lg font-semibold mb-3" style="color: var(--text-primary);">Top 5 Losers</h4>
                                    <div id="dashboard-top-losers" class="space-y-2">
                                        <!-- Top losers will be rendered here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Charts -->
                        <div class="space-y-8">
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Account Balance</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Account Value over time</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="balance-filter-week" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">Week</button>
                                        <button id="balance-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-primary); color: var(--text-primary); border: 1px solid var(--border-color);">Month</button>
                                        <button id="balance-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-80 mt-4">
                                <canvas id="accountBalanceChart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Equity Curve - Full Width -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Equity Curve</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Trading Performance over time</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="equity-filter-week" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">Week</button>
                                        <button id="equity-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors active" style="background-color: var(--accent-color, #3b82f6); color: white; border: 1px solid var(--accent-color, #3b82f6);">Month</button>
                                        <button id="equity-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-80 mt-4">
                                <canvas id="equityCurveChart"></canvas>
                                </div>
                            </div>
                            
                            <!-- Daily P&L - Full Width -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Daily P&L</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Daily profit and loss over time</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="dailyPnl-filter-week" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">Week</button>
                                        <button id="dailyPnl-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors active" style="background-color: var(--accent-color, #3b82f6); color: white; border: 1px solid var(--accent-color, #3b82f6);">Month</button>
                                        <button id="dailyPnl-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-80 mt-4">
                                <canvas id="dailyPnlChart"></canvas>
                                <p id="dailyPnlMessage" class="hidden absolute inset-0 flex items-center justify-center" style="color: var(--text-muted);">No P&L data yet</p>
                                </div>
                            </div>
                            
                            <!-- Monthly Performance - Now standalone -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Monthly Performance</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Monthly trading performance overview</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="monthly-performance-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors active" style="background-color: var(--accent-color, #3b82f6); color: white; border: 1px solid var(--accent-color, #3b82f6);">Month</button>
                                        <button id="monthly-performance-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-64 mt-4">
                                <canvas id="monthlyPerformanceChart"></canvas>
                                </div>
                            </div>

                            <!-- Monthly Commission/Charges - Full Width -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Monthly Commission/Charges</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Monthly trading costs and commission breakdown</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="monthly-commission-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors active" style="background-color: var(--accent-color, #3b82f6); color: white; border: 1px solid var(--accent-color, #3b82f6);">Month</button>
                                        <button id="monthly-commission-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-80 mt-4">
                                <canvas id="monthlyChargesChart"></canvas>
                                </div>
                            </div>

                            <!-- Daily Win Rate - Full Width -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-between items-center mb-4">
                                    <div>
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Daily Win Rate</h3>
                                        <p class="text-sm" style="color: var(--text-secondary);">Daily win rate analysis and performance trends</p>
                                    </div>
                                    <!-- Filter Buttons -->
                                    <div class="flex gap-2">
                                        <button id="dailyWinRate-filter-week" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">Week</button>
                                        <button id="dailyWinRate-filter-month" class="px-3 py-1 rounded text-sm font-medium transition-colors active" style="background-color: var(--accent-color, #3b82f6); color: white; border: 1px solid var(--accent-color, #3b82f6);">Month</button>
                                        <button id="dailyWinRate-filter-all" class="px-3 py-1 rounded text-sm font-medium transition-colors" style="background-color: var(--bg-secondary); color: var(--text-secondary); border: 1px solid var(--border-color);">All Time</button>
                                    </div>
                                </div>
                                <div class="relative h-80 mt-4" style="min-height: 320px;">
                                <canvas id="dailyWinRateChart" style="display: block; width: 100%; height: 100%;"></canvas>
                                <div id="dailyWinRateMessage" class="hidden absolute inset-0 flex items-center justify-center" style="color: var(--text-muted);">Loading chart...</div>
                                </div>
                            </div>

                            <!-- P&L by Trading Style and P&L by Segment Side by Side -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">P&L by Trading Style</h3>
                                    <div class="relative h-64">
                                    <canvas id="pnlByTradingStyleChart"></canvas>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">P&L by Segment</h3>
                                    <div class="relative h-64">
                                    <canvas id="pnlBySegmentChart"></canvas>
                                    </div>
                                </div>
                            </div>
                            <!-- Win/Loss Distribution and Strategy vs P&L Side by Side -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">Win/Loss Distribution</h3>
                                    <div class="h-64 flex items-center justify-center relative">
                                        <canvas id="winLossDistributionChart"></canvas>
                                        <p id="winLossMessage" class="hidden absolute text-center" style="color: var(--text-muted);">No trades yet</p>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">Strategy vs P&L</h3>
                                    <div class="relative h-64">
                                    <canvas id="strategyPnlChart"></canvas>
                                    </div>
                                </div>
                            </div>

                            <!-- Performance by Day of Week and Trade Distribution - Side by Side -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">Performance by Day of Week</h3>
                                    <div class="relative h-64">
                                    <canvas id="performanceByDayChart"></canvas>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="font-semibold mb-4" style="color: var(--text-primary);">Trade Distribution by Day of the Week</h3>
                                    <div class="relative h-64">
                                    <canvas id="tradeDistributionChart"></canvas>
                                    </div>
                                </div>
                            </div>

                            <!-- Net P&L by Mood and Most Common Mistakes Charts - Side by Side -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                <!-- Net P&L by Mood Chart -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <div>
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Net P&L by Mood</h3>
                                            <p class="text-sm mt-1" style="color: var(--text-muted);">Analyze how your emotional state impacts trading profitability (net P&L after costs)</p>
                                        </div>
                                    </div>
                                    <div class="relative h-64">
                                        <canvas id="netPnlByMoodChart"></canvas>
                                        <div id="netPnlByMoodMessage" class="hidden absolute inset-0 flex items-center justify-center" style="color: var(--text-muted);">Loading chart...</div>
                                    </div>
                                </div>

                                <!-- Most Common Mistakes Chart -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <div>
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Most Common Mistakes</h3>
                                            <p class="text-sm mt-1" style="color: var(--text-muted);">Identify patterns in trading errors and behavioral issues</p>
                                        </div>
                                    </div>
                                    <div class="relative h-64">
                                        <canvas id="mostCommonMistakesChart"></canvas>
                                        <div id="mostCommonMistakesMessage" class="hidden absolute inset-0 flex items-center justify-center" style="color: var(--text-muted);">Loading chart...</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Add Trade Page -->
                    <div id="add-trade" class="page">
                        <form id="manual-trade-form" class="space-y-1 max-w-[800px] mx-auto">
                            <input type="hidden" id="trade-id" name="tradeId">
                            
                            <h2 id="trade-form-title" class="text-3xl font-bold" style="color: var(--text-primary);"></h2>

                            <!-- Tabs -->
                            <div class="flex justify-center mb-6">
                                <div class="flex rounded-lg w-full" style="background-color: var(--bg-tertiary);">
                                    <button type="button" id="trade-tab" class="py-2 rounded-lg text-sm font-medium transition-colors duration-200 border w-full sm:w-[400px] flex-1" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        Trade
                                    </button>
                                    <button type="button" id="journal-tab" class="py-2 rounded-lg text-sm font-medium transition-colors duration-200 border w-full sm:w-[400px] flex-1" style="background-color: var(--bg-tertiary); color: var(--text-secondary); border-color: var(--border-color);">
                                        Journal
                                    </button>
                                </div>
                            </div>

                            <!-- Trade Tab Content -->
                            <div id="trade-tab-content" class="space-y-6">
                                <!-- Main Trade Form Container -->
                                <div class="py-4 px-3 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <!-- Trade Details and Execution Details - Centered Layout -->
                                    <div class="flex flex-col items-center space-y-3">
                                        <!-- Trade Details Section -->
                                        <div class="w-full">
                                            <div class="p-3 rounded-md shadow-sm" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                                <h3 class="text-base font-semibold mb-2 border-b pb-1" style="color: var(--text-primary); border-color: var(--border-color);">Trade Details</h3>
                                                <div class="space-y-2">
                                                    <!-- Trading Style and Symbol Row -->
                                                    <div class="grid grid-cols-2 gap-3">
                                                        <div>
                                                            <label for="trading-style-select" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Trading Style</label>
                                                            <select name="tradingStyle" id="trading-style-select" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;">
                                                                <option value="Scalping" selected>Scalping</option>
                                                                <option value="Intraday">Intraday</option>
                                                                <option value="Swing">Swing</option>
                                                                <option value="Position">Position</option>
                                                                <option value="Long-Term">Long-Term</option>
                                                            </select>
                                                        </div>
                                                        <div class="relative">
                                                            <label for="asset-input" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Symbol</label>
                                                            <input name="asset" type="text" id="asset-input" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="e.g.RELIANCE,NIFTY50" required autocomplete="off">
                                                            <div id="asset-suggestions" class="absolute z-10 w-full rounded-md mt-1 hidden max-h-48 overflow-y-auto" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);"></div>
                                                        </div>
                                                    </div>
                                                    
                                                    <!-- Segment and Direction Row -->
                                                    <div class="grid grid-cols-2 gap-3">
                                                    <div>
                                                        <label for="segment-select" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Segment</label>
                                                        <select name="segment" id="segment-select" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;">
                                                            <option value="Equity" selected>Equity</option>
                                                            <option value="F&O">F&O</option>
                                                            <option value="Currency">Currency</option>
                                                            <option value="Commodity">Commodity</option>
                                                            <option value="Debt">Debt</option>
                                                            <option value="Mutual Fund">Mutual Fund</option>
                                                        </select>
                                                    </div>
                                                        <div>
                                                            <label for="direction-group" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Direction</label>
                                                            <div id="direction-group" class="form-btn-group flex gap-1" role="radiogroup" aria-labelledby="direction-group">
                                                                <button type="button" data-value="Long" class="active active-long flex items-center justify-center gap-1 px-2 py-1 rounded-md border text-sm">
                                                                    <i data-feather="arrow-up" class="inline-block h-3 w-3"></i>Long
                                                                </button>
                                                                <button type="button" data-value="Short" class="flex items-center justify-center gap-1 px-2 py-1 rounded-md border text-sm">
                                                                    <i data-feather="arrow-down" class="inline-block h-3 w-3"></i>Short
                                                                </button>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                        </div>

                                        <!-- Execution Details Section -->
                                        <div class="w-full">
                                            <div class="p-3 rounded-md shadow-sm" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                                <h3 class="text-base font-semibold mb-2 border-b pb-1" style="color: var(--text-primary); border-color: var(--border-color);">Execution Details</h3>
                                                <div class="space-y-2">
                                                    <div class="grid grid-cols-4 gap-2">
                                                        <div>
                                                            <label for="entry-date" class="block text-xs font-medium" style="color: var(--text-secondary);">Entry Date</label>
                                                            <input name="entryDate" type="date" id="entry-date" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" required autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="entry-time" class="block text-xs font-medium" style="color: var(--text-secondary);">Entry Time (Optional)</label>
                                                            <input name="entryTime" type="time" id="entry-time" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="exit-date" class="block text-xs font-medium" style="color: var(--text-secondary);">Exit Date</label>
                                                            <input name="exitDate" type="date" id="exit-date" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="exit-time" class="block text-xs font-medium" style="color: var(--text-secondary);">Exit Time (Optional)</label>
                                                            <input name="exitTime" type="time" id="exit-time" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" autocomplete="off">
                                                        </div>
                                                    </div>
                                                    <div class="grid grid-cols-4 gap-2">
                                                        <div>
                                                            <label for="entry-price" class="block text-xs font-medium" style="color: var(--text-secondary);">Entry Price</label>
                                                            <input name="entryPrice" type="number" step="any" id="entry-price" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" required autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="quantity" class="block text-xs font-medium" style="color: var(--text-secondary);">Entry Qty</label>
                                                            <input name="quantity" type="number" id="quantity" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0" required autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="exit-price" class="block text-xs font-medium" style="color: var(--text-secondary);">Exit Price</label>
                                                            <input name="exitPrice" type="number" step="any" id="exit-price" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="exit-quantity" class="block text-xs font-medium" style="color: var(--text-secondary);">Exit Qty</label>
                                                            <input name="exitQuantity" type="number" id="exit-quantity" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0" autocomplete="off">
                                                        </div>
                                                    </div>
                                                    <div class="grid grid-cols-4 gap-2">
                                                        <div>
                                                            <label for="stop-loss" class="block text-xs font-medium" style="color: var(--text-secondary);">Stop loss <span id="stop-loss-percent" class="text-xs font-normal" style="color: var(--text-secondary);"></span></label>
                                                            <input name="stopLoss" type="number" step="any" id="stop-loss" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="target" class="block text-xs font-medium" style="color: var(--text-secondary);">Target price <span id="target-percent" class="text-xs font-normal" style="color: var(--text-secondary);"></span></label>
                                                            <input name="target" type="number" step="any" id="target" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="brokerage" class="block text-xs font-medium" style="color: var(--text-secondary);">Brokerage</label>
                                                            <input name="brokerage" type="number" step="any" id="brokerage" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" autocomplete="off">
                                                        </div>
                                                        <div>
                                                            <label for="other-fees" class="block text-xs font-medium" style="color: var(--text-secondary);">Charges</label>
                                                            <input name="otherFees" type="number" step="any" id="other-fees" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="0.00" autocomplete="off">
                                                        </div>
                                                    </div>
                                                    
                                                    <!-- Total Amount and P&L Summary - Same Line -->
                                                    <div class="grid grid-cols-2 gap-2 mt-2">
                                                        <div class="p-2 rounded-sm shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                                            <div class="flex justify-between items-center">
                                                                <span class="text-xs font-medium" style="color: var(--text-muted);">Total Amount</span>
                                                                <span id="total-amount" class="font-bold text-sm" style="color: var(--text-primary);">₹0.00</span>
                                                            </div>
                                                        </div>
                                                        <div class="p-2 rounded-sm shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                                            <div class="space-y-1">
                                                                <div class="flex justify-between items-center">
                                                                    <span class="text-xs font-medium" style="color: var(--text-muted);">Gross P&L</span>
                                                                    <span id="gross-pnl-amount" class="font-bold text-xs" style="color: var(--text-primary);">₹0.00</span>
                                                                </div>
                                                                <div class="flex justify-between items-center">
                                                                    <span class="text-xs font-medium" style="color: var(--text-muted);">Total Charges</span>
                                                                    <span id="total-charges" class="font-bold text-xs text-red-500">₹0.00</span>
                                                                </div>
                                                                <div class="flex justify-between items-center">
                                                                    <span class="text-xs font-medium" style="color: var(--text-muted);">Net P&L Amount</span>
                                                                    <span id="pnl-amount" class="font-bold text-xs" style="color: var(--text-primary);">₹0.00</span>
                                                                </div>
                                                                <div class="flex justify-between items-center">
                                                                    <span class="text-xs font-medium" style="color: var(--text-muted);">P&L (%)</span>
                                                                    <span id="pnl-percent" class="font-bold text-xs" style="color: var(--text-primary);">0.00%</span>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                        </div>
                                    </div>

                                </div>
                            </div>

                            <!-- Journal Tab Content -->
                            <div id="journal-tab-content" class="hidden space-y-6">
                                <!-- Main Journal Form Container -->
                                <div class="py-4 px-3 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex justify-center">
                                    <div class="w-full">
                                            <!-- Strategy and Outcome Section - Above Psychology and Notes -->
                                            <div class="p-3 rounded-md shadow-sm mb-4" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                            <h3 class="text-base font-semibold mb-2 border-b pb-1" style="color: var(--text-primary); border-color: var(--border-color);">Strategy and Outcome</h3>
                                            <div class="grid grid-cols-2 gap-3">
                                                <div>
                                                    <label for="strategy" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Strategy Tag</label>
                                                    <select name="strategy" id="strategy" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;">
                                                        <option value="Price Action" selected>Price Action</option>
                                                        <option value="Trend Following">Trend Following</option>
                                                        <option value="Breakout">Breakout</option>
                                                        <option value="Reversal">Reversal</option>
                                                        <option value="Scalping">Scalping</option>
                                                        <option value="Swing Trading">Swing Trading</option>
                                                        <option value="Support/Resistance">Support/Resistance</option>
                                                        <option value="Moving Average">Moving Average</option>
                                                        <option value="RSI Strategy">RSI Strategy</option>
                                                        <option value="MACD Strategy">MACD Strategy</option>
                                                        <option value="News Based">News Based</option>
                                                        <option value="Other">Other</option>
                                                    </select>
                                                </div>
                                                <div>
                                                    <label for="outcome-summary" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Outcome Summary</label>
                                                    <select name="outcomeSummary" id="outcome-summary" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;">
                                                        <option>Select outcome summary</option>
                                                        <option>Target Hit</option>
                                                        <option>Stop Loss Hit</option>
                                                        <option>Exited Early (Profit)</option>
                                                        <option>Exited Early (Loss)</option>
                                                        <option>Break Even</option>
                                                    </select>
                                        </div>
                                    </div>
                                </div>

                                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                        <!-- Left Column - Psychology -->
                                        <div class="p-3 rounded-md shadow-sm" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                            <h3 class="text-base font-semibold mb-2 border-b pb-1" style="color: var(--text-primary); border-color: var(--border-color);">Psychology</h3>
                                            <div class="space-y-3">
                                                <div>
                                                    <label for="emotional-state" class="block text-xs font-medium mb-1" style="color: var(--text-secondary);">Emotional State During Trade</label>
                                                    <select name="emotionalState" id="emotional-state" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;">
                                                        <option value="">Select Emotional state</option>
                                                        <option value="Calm">Calm</option>
                                                        <option value="Frustrated">Frustrated</option>
                                                        <option value="Overconfident">Overconfident</option>
                                                        <option value="Anxious">Anxious</option>
                                                        <option value="Impatient">Impatient</option>
                                                        <option value="Confident">Confident</option>
                                                        <option value="Fearful">Fearful</option>
                                                        <option value="Greedy">Greedy</option>
                                                        <option value="Excited">Excited</option>
                                                        <option value="Neutral">Neutral</option>
                                                    </select>
                                                </div>
                                                <fieldset>
                                                    <legend class="block text-xs font-medium mb-2" style="color: var(--text-secondary);">Mistake Made</legend>
                                                    <div class="grid grid-cols-2 gap-2">
                                                        <label for="mistake-overtrading" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-overtrading" name="mistakes" value="Overtrading" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Overtrading</span>
                                                        </label>
                                                        <label for="mistake-risked-too-much" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-risked-too-much" name="mistakes" value="Risked Too Much" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Risked Too Much</span>
                                                        </label>
                                                        <label for="mistake-exited-too-late" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-exited-too-late" name="mistakes" value="Exited Too Late" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Exited Too Late</span>
                                                        </label>
                                                        <label for="mistake-ignored-signals" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-ignored-signals" name="mistakes" value="Ignored signals" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Ignored signals</span>
                                                        </label>
                                                        <label for="mistake-ignored-stop-loss" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-ignored-stop-loss" name="mistakes" value="Ignored Stop loss" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Ignored Stop loss</span>
                                                        </label>
                                                        <label for="mistake-revenge-signals" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-revenge-signals" name="mistakes" value="Revenge signals" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Revenge signals</span>
                                                        </label>
                                                        <label for="mistake-exited-too-early" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-exited-too-early" name="mistakes" value="Exited Too Early" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Exited Too Early</span>
                                                        </label>
                                                        <label for="mistake-revenge-trading" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-revenge-trading" name="mistakes" value="Revenge Trading" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">Revenge Trading</span>
                                                        </label>
                                                        <label for="mistake-no-clean-plan" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-no-clean-plan" name="mistakes" value="No clean Plan" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">No clean Plan</span>
                                                        </label>
                                                        <label for="mistake-no-mistake" class="flex items-center space-x-1 cursor-pointer">
                                                            <input type="checkbox" id="mistake-no-mistake" name="mistakes" value="No Mistake" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                                            <span class="text-xs" style="color: var(--text-primary);">No Mistake</span>
                                                        </label>
                                                    </div>
                                                </fieldset>
                                        </div>
                                    </div>

                                                <!-- Right Column - Trade Journal & Notes -->
                                                <div class="p-3 rounded-md shadow-sm" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                                    <h3 class="text-base font-semibold mb-2 border-b pb-1" style="color: var(--text-primary); border-color: var(--border-color);">Trade Journal & Notes</h3>
                                                    <div class="space-y-2">
                                                        <p class="text-xs" style="color: var(--text-secondary);">Reason for entry/exit, learning, etc.</p>
                                                        <textarea name="reasons" id="reasons" rows="8" class="w-full rounded-md border focus:border-blue-500 focus:ring-blue-500 text-sm" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.375rem;" placeholder="What was your thesis for this trade? What did you learn?"></textarea>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- CSV Upload Section -->
                            <div class="py-4 px-3 rounded-lg shadow-sm mt-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-base font-semibold mb-4 border-b pb-2" style="color: var(--text-primary); border-color: var(--border-color);">
                                    <i data-feather="upload" class="inline-block h-4 w-4 mr-2"></i>Bulk Upload Trades
                                </h3>
                                
                                <!-- Sample CSV Download -->
                                <div class="mb-4 p-3 rounded-md" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <p class="text-sm font-medium" style="color: var(--text-primary);">Need a template?</p>
                                            <p class="text-xs" style="color: var(--text-secondary);">Download our sample CSV file to see the required format</p>
                                        </div>
                                        <button type="button" id="download-sample-csv" class="btn-secondary text-sm py-2 px-4 rounded-md flex items-center gap-2">
                                            <i data-feather="download" class="h-4 w-4"></i>
                                            Download Sample
                                        </button>
                                    </div>
                                </div>
                                
                                <!-- File Upload Area -->
                                <div class="border-2 border-dashed rounded-lg p-6 text-center" style="border-color: var(--border-color);" id="csv-drop-zone">
                                    <input type="file" id="csv-file-input" accept=".csv" class="hidden">
                                    <div class="space-y-2">
                                        <i data-feather="file-plus" class="mx-auto h-8 w-8" style="color: var(--text-secondary);"></i>
                                        <p class="text-sm" style="color: var(--text-secondary);">Drop your CSV file here or click to browse</p>
                                        <button type="button" id="csv-browse-btn" class="btn-primary text-sm py-2 px-4 rounded-md">Choose File</button>
                                    </div>
                                </div>
                                
                                <!-- Progress Bar -->
                                <div id="csv-progress-container" class="hidden mt-4">
                                    <div class="flex justify-between text-xs mb-1" style="color: var(--text-secondary);">
                                        <span>Uploading trades...</span>
                                        <span id="csv-progress-text">0/0</span>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-2" style="background-color: var(--bg-tertiary);">
                                        <div id="csv-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                    </div>
                                </div>
                                
                                <!-- Results Display -->
                                <div id="csv-results" class="hidden mt-4 p-3 rounded-md" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                    <div id="csv-success-message" class="hidden text-green-600 text-sm"></div>
                                    <div id="csv-error-message" class="hidden text-red-600 text-sm"></div>
                                </div>
                            </div>
                            
                            <!-- Action Buttons -->
                            <div class="flex justify-center gap-4 pt-4 border-t" style="border-color: var(--border-color);">
                                <button type="button" id="clear-trade-form-btn" class="font-semibold py-2 px-6 rounded-md shadow-sm" style="background-color: var(--bg-tertiary); color: var(--text-secondary);">Reset</button>
                                <button type="submit" class="btn-primary font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center min-w-[120px]">
                                    <span class="btn-text">Save Trade</span>
                                    <span class="spinner hidden"></span>
                                </button>
                            </div>
                        </form>
                    </div>


                    <!-- Trade History Page (Enhanced) -->
                    <div id="trade-history" class="page">
                        <div class="mb-8">
                            <h2 class="text-3xl font-bold" style="color: var(--text-primary);">Enhanced Trade Logs</h2>
                            <p class="text-lg" style="color: var(--text-secondary);">Cleaner, sharper, and more insightful.</p>
                        </div>
                        
                        <!-- Trade History Filters -->
                        <div class="mb-4 p-4 rounded-lg border" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                            <div class="flex flex-wrap items-end gap-4">
                                <div class="flex-1 min-w-[200px] max-w-[250px]">
                                    <label for="trade-history-filter-status" class="block text-sm font-medium" style="color: var(--text-secondary);">Status</label>
                                    <select id="trade-history-filter-status" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All Status</option>
                                        <option value="Open">Open</option>
                                        <option value="Closed">Closed</option>
                                        <option value="Partial Exit">Partial Exit</option>
                                    </select>
                                </div>
                                <div class="flex-1 min-w-[200px] max-w-[250px]">
                                    <label for="trade-history-filter-start-date" class="block text-sm font-medium" style="color: var(--text-secondary);">Start Date</label>
                                    <input type="date" id="trade-history-filter-start-date" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="off">
                                </div>
                                <div class="flex-1 min-w-[200px] max-w-[250px]">
                                    <label for="trade-history-filter-end-date" class="block text-sm font-medium" style="color: var(--text-secondary);">End Date</label>
                                    <input type="date" id="trade-history-filter-end-date" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="off">
                                </div>
                                <div class="flex-1 min-w-[200px] max-w-[250px]">
                                    <label for="trade-history-filter-symbol" class="block text-sm font-medium" style="color: var(--text-secondary);">Symbol</label>
                                    <input type="text" id="trade-history-filter-symbol" placeholder="Search symbol..." class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="off">
                                </div>
                                <div class="flex items-end space-x-2">
                                    <button id="trade-history-apply-filter-btn" class="btn-primary text-sm py-2 px-4 rounded-md">Apply</button>
                                    <button id="trade-history-reset-filter-btn" class="btn-primary text-sm py-2 px-4 rounded-md" style="background-color: #6b7280; border-color: #6b7280;">Reset</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="rounded-lg shadow-sm overflow-x-auto" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <table class="w-full min-w-[1500px] text-xs text-left border-collapse" style="border: 1px solid var(--border-color);">
                                <thead class="text-xs uppercase" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color); width: 40px;">
                                            <input type="checkbox" id="select-all-trades" class="w-4 h-4 rounded border-gray-300" title="Select All Trades">
                                        </th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Symbol</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Net P&L</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Net P/L %</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Status</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Qty</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Direction</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Segment</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Date</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Stop Loss</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Target Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Qty</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Date</th>
                                        <th scope="col" class="px-3 py-2" style="border-color: var(--border-color);">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="trade-history-tbody">
                                    <!-- Dynamic content here -->
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Bulk Actions Toolbar -->
                        <div id="bulk-actions-toolbar" class="hidden mt-4 p-4 rounded-lg border" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                            <div class="flex items-center justify-between">
                                <div class="flex items-center space-x-4">
                                    <span id="selected-count" class="text-sm font-medium" style="color: var(--text-primary);">0 trades selected</span>
                                    <div class="flex space-x-2">
                                        <button id="delete-selected-btn" class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700 transition-colors">
                                            <i data-feather="trash-2" class="w-4 h-4 mr-2"></i>
                                            Delete Selected
                                        </button>
                                        <button id="delete-all-btn" class="px-4 py-2 text-sm font-medium text-white bg-red-800 rounded-md hover:bg-red-900 transition-colors">
                                            <i data-feather="trash" class="w-4 h-4 mr-2"></i>
                                            Delete All Trades
                                        </button>
                                    </div>
                                </div>
                                <button id="clear-selection-btn" class="text-sm" style="color: var(--text-secondary);">
                                    <i data-feather="x" class="w-4 h-4 mr-1"></i>
                                    Clear Selection
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Reports Page -->
                    <div id="reports" class="page">
                        <div class="space-y-8">
                             <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h2 class="text-2xl font-bold mb-1" style="color: var(--text-primary);">Performance Metrics</h2>
                                <p style="color: var(--text-secondary);" class="mb-6">Key stats for your trading performance.</p>
                                <div id="reports-metrics-grid" class="grid grid-cols-1 md:grid-cols-2 gap-x-8 gap-y-4 text-sm">
                                    <!-- Dynamic content here -->
                                </div>
                            </div>

                            <!-- Advanced Trading Metrics -->
                            <div class="space-y-6">
                                <!-- Row 1: Trade Performance, Daily Performance, Trade Execution -->
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                    <!-- Trade Performance Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Trade Performance</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #3b82f6;">
                                                <i data-feather="award" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="trade-performance-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Daily Performance Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Daily Performance</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #10b981;">
                                                <i data-feather="calendar" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="daily-performance-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Trade Execution Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Trade Execution</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #8b5cf6;">
                                                <i data-feather="trending-up" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="trade-execution-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 2: Time Metrics, Setup Effectiveness, Symbol Frequency -->
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                    <!-- Time Metrics Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Time Metrics</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #f59e0b;">
                                                <i data-feather="clock" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="time-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Setup Effectiveness Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Setup Effectiveness</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #10b981;">
                                                <i data-feather="bar-chart-2" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="setup-effectiveness-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Symbol Frequency Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Symbol Frequency</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #8b5cf6;">
                                                <i data-feather="pie-chart" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="symbol-frequency-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 3: Capital Usage, Quantity Analysis, Weekday Avg R:R -->
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                    <!-- Capital Usage Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Capital Usage</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #10b981;">
                                                <span class="text-white font-bold text-lg">₹</span>
                                            </div>
                                        </div>
                                        <div id="capital-usage-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Quantity Analysis Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Quantity Analysis</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #d97706;">
                                                <i data-feather="layers" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="quantity-analysis-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Weekday Avg R:R Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Weekday Avg R:R</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #3b82f6;">
                                                <i data-feather="trending-up" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="weekday-rr-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 4: Weekday Win Rate, Daily Trade Activity, Emotional State -->
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                                    <!-- Weekday Win Rate Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Weekday Win Rate</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #3b82f6;">
                                                <i data-feather="calendar" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="weekday-win-rate-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Daily Trade Activity Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Daily Trade Activity</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #8b5cf6;">
                                                <i data-feather="clock" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="daily-trade-activity-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Emotional State Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Emotional State</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #ec4899;">
                                                <i data-feather="heart" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="emotional-state-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>
                                </div>

                                <!-- Row 5: Advanced Trading Metrics -->
                                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mt-6">
                                    <!-- Risk-Adjusted Performance Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Risk-Adjusted Performance</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #ef4444;">
                                                <i data-feather="shield" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="risk-adjusted-performance-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Winning Trade Analysis (MAE) Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Winning Trade Analysis (MAE)</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #22c55e;">
                                                <i data-feather="trending-up" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="winning-trade-analysis-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>

                                    <!-- Losing Trade Analysis (MFE) Card -->
                                    <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                        <div class="flex justify-between items-center mb-4">
                                            <h3 class="font-semibold" style="color: var(--text-primary);">Losing Trade Analysis (MFE)</h3>
                                            <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #f97316;">
                                                <i data-feather="trending-down" class="w-4 h-4 text-white"></i>
                                            </div>
                                        </div>
                                        <div id="losing-trade-analysis-metrics" class="space-y-3">
                                            <!-- Dynamic content -->
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Row 6: Cost Analysis, Maximum Drawdown, R-Value Analysis -->
                            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mt-6">
                                <!-- Cost Analysis Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Cost Analysis</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #3b82f6;">
                                            <i data-feather="pie-chart" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="cost-analysis-metrics" class="space-y-3">
                                        <!-- Dynamic content -->
                                    </div>
                                </div>

                                <!-- Maximum Drawdown Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Maximum Drawdown</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #ef4444;">
                                            <i data-feather="alert-triangle" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="max-drawdown-metrics" class="space-y-3">
                                        <!-- Dynamic content -->
                                    </div>
                                </div>

                                <!-- R-Value Analysis Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">R-Value Analysis</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #3b82f6;">
                                            <i data-feather="target" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="r-value-metrics" class="space-y-3">
                                        <!-- Dynamic content -->
                                    </div>
                                </div>
                            </div>

                            <!-- Row 7: Financial Impact of Mistakes & P&L by Quantity Traded Tier -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                                <!-- Financial Impact of Mistakes Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Financial Impact of Mistakes</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #ef4444;">
                                            <i data-feather="alert-triangle" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="mistake-impact-table" class="overflow-x-auto">
                                        <!-- Dynamic table content -->
                                    </div>
                                </div>

                                <!-- P&L by Quantity Traded Tier Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">P&L by Quantity Traded Tier</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #10b981;">
                                            <i data-feather="trending-up" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="quantity-tier-table" class="overflow-x-auto">
                                        <!-- Dynamic table content -->
                                    </div>
                                </div>
                            </div>

                            <!-- Row 8: Detailed Performance by Day of the Week & Trade Duration Analysis -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
                                <!-- Detailed Performance by Day of the Week Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Detailed Performance by Day of the Week</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #10b981;">
                                            <i data-feather="calendar" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="day-performance-table" class="overflow-x-auto">
                                        <!-- Dynamic table content -->
                                    </div>
                                </div>

                                <!-- Trade Duration Analysis Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="font-semibold" style="color: var(--text-primary);">Profitability by Trade Duration</h3>
                                        <div class="w-8 h-8 rounded-lg flex items-center justify-center" style="background-color: #8b5cf6;">
                                            <i data-feather="clock" class="w-4 h-4 text-white"></i>
                                        </div>
                                    </div>
                                    <div id="trade-duration-table" class="overflow-x-auto">
                                        <!-- Dynamic table content -->
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>

                    <!-- Trade Calendar Page -->
                    <div id="trade-calendar" class="page">
                         <div id="calendar-stats-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <!-- Dynamic content here -->
                        </div>
                        <div class="rounded-lg shadow-sm p-4" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="p-2 md:p-0 flex flex-col md:flex-row items-center justify-between gap-4 mb-4">
                                <div class="flex items-center space-x-2 md:space-x-4">
                                    <button id="prev-month-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700" style="color: var(--text-primary);">
                                        <i data-feather="chevron-left" class="h-6 w-6"></i>
                                    </button>
                                    <h2 id="calendar-month-year" class="text-xl font-bold whitespace-nowrap" style="color: var(--text-primary);">Month Year</h2>
                                    <button id="next-month-btn" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700" style="color: var(--text-primary);">
                                        <i data-feather="chevron-right" class="h-6 w-6"></i>
                                    </button>
                                </div>
                                <div class="flex items-center gap-4">
                                    <div id="monthly-pnl-display" class="font-semibold" style="color: var(--text-primary);">Monthly P&L: ₹0.00</div>
                                </div>
                            </div>
                            <div class="overflow-x-auto">
                                <div class="min-w-[950px]">
                                     <div class="flex gap-2">
                                        <!-- Main calendar part (7 columns) -->
                                        <div class="flex-grow">
                                            <div class="grid grid-cols-7 gap-2 p-2 text-center text-sm font-medium" style="color: var(--text-secondary);">
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Sun</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Mon</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Tue</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Wed</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Thu</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Fri</div>
                                                <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 weekday-header">Sat</div>
                                            </div>
                                            <div id="calendar-grid-days" class="p-2">
                                                <!-- JS will create week rows here, each being a grid-cols-7 -->
                                            </div>
                                        </div>
                                        <!-- Weekly summaries part (1 column) -->
                                        <div class="w-[140px] flex-shrink-0">
                                            <div class="p-2 text-center text-sm font-medium" style="color: var(--text-secondary);"> <!-- Header placeholder for alignment -->
                                                 <div class="bg-gray-100 dark:bg-gray-800/80 rounded-md py-2 invisible">Summary</div> <!-- Invisible to just take space -->
                                            </div>
                                            <div id="calendar-grid-summaries" class="p-2">
                                                <!-- JS will create summary boxes here -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Fund Management Page -->
                    <div id="fund-management" class="page">
                         <div class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
                            <h2 class="text-3xl font-bold" style="color: var(--text-primary);">Funds</h2>
                            <div class="flex items-center space-x-2">
                                <button id="fm-deposit-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm text-sm flex items-center">
                                    <i data-feather="plus" class="mr-2 h-4 w-4"></i> Deposit
                                </button>
                                <button id="fm-withdraw-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm text-sm flex items-center">
                                     <i data-feather="arrow-up-right" class="mr-2 h-4 w-4"></i> Withdraw
                                </button>
                            </div>
                        </div>

                        <!-- Stat Cards -->
                        <div id="fm-stats-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                            <!-- Net Account Value -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Net Account Value</p>
                                        <p id="net-account-value" class="text-2xl font-bold text-green-600">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Net Realized P&L -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Net Realized P&L</p>
                                        <p id="net-realized-pnl" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Starting Account Balance -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Starting Account Balance</p>
                                        <p id="starting-account-balance" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Total Deposits -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Total Deposits</p>
                                        <p id="total-deposits" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Deployed Capital -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Deployed Capital</p>
                                        <p id="deployed-capital" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Available Cash -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Available Cash</p>
                                        <p id="available-cash" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Total Withdrawn -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Total Withdrawn</p>
                                        <p id="total-withdrawn" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Total Open Risk (%) -->
                            <div class="rounded-lg shadow-sm p-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Total Open Risk <span id="total-open-risk-percentage" class="text-xs">(0.00%)</span></p>
                                        <p id="total-open-risk-amount" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Ledger Table -->
                        <div class="rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="overflow-x-auto">
                                <table class="w-full text-sm text-left">
                                    <thead class="text-xs uppercase" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                                        <tr>
                                            <th class="px-6 py-3 font-medium">Date</th>
                                            <th class="px-6 py-3 font-medium">Direction</th>
                                            <th class="px-6 py-3 font-medium">Amount</th>
                                            <th class="px-6 py-3 font-medium">Notes</th>
                                            <th class="px-6 py-3 font-medium">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody id="fund-ledger-body">
                                        <!-- Dynamic content here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>

                    <!-- Trade Statement Page -->
                    <div id="trade-statement" class="page">
                         <!-- Filter Section -->
                        <div class="rounded-lg shadow-sm p-4 mb-6" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 items-end">
                                <div>
                                    <label for="filter-type" class="block text-sm font-medium" style="color: var(--text-secondary);">Transaction Type</label>
                                    <select id="filter-type" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option>All Types</option>
                                        <option>Trade</option>
                                        <option>Deposit</option>
                                        <option>Withdrawal</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="filter-strategy" class="block text-sm font-medium" style="color: var(--text-secondary);">Strategy</label>
                                    <select id="filter-strategy" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All Strategies</option>
                                        <option value="Price Action">Price Action</option>
                                        <option value="Trend Following">Trend Following</option>
                                        <option value="Breakout">Breakout</option>
                                        <option value="Reversal">Reversal</option>
                                        <option value="Scalping">Scalping</option>
                                        <option value="Swing Trading">Swing Trading</option>
                                        <option value="Support/Resistance">Support/Resistance</option>
                                        <option value="Moving Average">Moving Average</option>
                                        <option value="RSI Strategy">RSI Strategy</option>
                                        <option value="MACD Strategy">MACD Strategy</option>
                                        <option value="News Based">News Based</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="filter-start-date" class="block text-sm font-medium" style="color: var(--text-secondary);">Start Date</label>
                                    <input type="date" id="filter-start-date" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="off">
                                </div>
                                <div>
                                    <label for="filter-end-date" class="block text-sm font-medium" style="color: var(--text-secondary);">End Date</label>
                                    <input type="date" id="filter-end-date" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" autocomplete="off">
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 items-end mt-1">
                                <div>
                                    <label for="filter-status" class="block text-sm font-medium" style="color: var(--text-secondary);">Status</label>
                                    <select id="filter-status" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All Status</option>
                                        <option value="Open">Open</option>
                                        <option value="Closed">Closed</option>
                                        <option value="Pending">Pending</option>
                                        <option value="Cancelled">Cancelled</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="filter-winloss" class="block text-sm font-medium" style="color: var(--text-secondary);">Win/Loss</label>
                                    <select id="filter-winloss" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All</option>
                                        <option value="Win">Win</option>
                                        <option value="Loss">Loss</option>
                                        <option value="Break Even">Break Even</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="filter-segment" class="block text-sm font-medium" style="color: var(--text-secondary);">Segment</label>
                                    <select id="filter-segment" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All Segments</option>
                                        <option value="Equity">Equity</option>
                                        <option value="F&O">F&O</option>
                                        <option value="Currency">Currency</option>
                                        <option value="Commodity">Commodity</option>
                                        <option value="Debt">Debt</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="filter-direction" class="block text-sm font-medium" style="color: var(--text-secondary);">Direction</label>
                                    <select id="filter-direction" class="w-full rounded-md text-sm border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                        <option value="">All Directions</option>
                                        <option value="Buy">Buy</option>
                                        <option value="Sell">Sell</option>
                                        <option value="Long">Long</option>
                                        <option value="Short">Short</option>
                                    </select>
                                </div>
                                <div class="flex items-end">
                                    <div class="flex gap-2 w-full">
                                        <button id="apply-filter-btn" class="btn-primary font-semibold py-2 px-4 rounded-md shadow-sm flex-1">Apply</button>
                                        <button id="reset-filter-btn" class="font-semibold py-2 px-4 rounded-md shadow-sm flex-1" style="background-color: var(--bg-tertiary); color: var(--text-secondary);">Reset</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Export CSV Button -->
                        <div class="flex justify-end mb-4">
                            <button id="export-csv-btn" class="font-semibold py-1 px-3 rounded-md shadow-sm flex items-center justify-center text-sm" style="background-color: #10b981; color: white;">
                                <i data-feather="download" class="mr-1 h-3 w-3"></i>Export CSV
                            </button>
                        </div>

                        <div class="rounded-lg shadow-sm overflow-x-auto" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <table class="w-full min-w-[2500px] text-xs text-left border-collapse" style="border: 1px solid var(--border-color);">
                                <thead class="text-xs uppercase" style="background-color: var(--bg-secondary); color: var(--text-secondary);">
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <th scope="col" class="px-2 py-2 border-r text-center" style="border-color: var(--border-color); width: 100px; min-width: 100px;">Date</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Symbol/Desc</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Direction</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Segment</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Amount (₹)</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Gross P/L</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Charges</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Net P/L</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Net P/L %</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Win/Loss</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Status</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Qty</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Entry Date</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Stop Loss</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Target Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Price</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Qty</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Exit Date</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Strategy</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Outcome Summary</th>
                                        <th scope="col" class="px-3 py-2 border-r" style="border-color: var(--border-color);">Emotional State</th>
                                        <th scope="col" class="px-3 py-2" style="border-color: var(--border-color);">Notes</th>
                                    </tr>
                                </thead>
                                <tbody id="statement-tbody">
                                    <!-- Dynamic content here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Profile Page -->
                    <div id="profile" class="page">
                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                            <div class="lg:col-span-2 space-y-8">
                                <div class="rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="p-6">
                                        <h3 class="text-xl font-bold mb-6" style="color: var(--text-primary);">Profile Information</h3>
                                        <form id="profile-info-form" class="space-y-6">
                                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                                                <div>
                                                    <label for="profile-name" class="block text-sm font-medium" style="color: var(--text-secondary);">Full Name</label>
                                                    <input type="text" id="profile-name" name="name" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                                </div>
                                                <div>
                                                    <label for="profile-email" class="block text-sm font-medium" style="color: var(--text-secondary);">Email Address</label>
                                                    <input type="email" id="profile-email" class="mt-1 w-full rounded-md" style="background-color: var(--bg-tertiary);" disabled>
                                                </div>
                                                <div>
                                                    <label for="profile-phone" class="block text-sm font-medium" style="color: var(--text-secondary);">Contact Number</label>
                                                    <input type="tel" id="profile-phone" name="phone" placeholder="+91 XXXXX XXXXX" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                                </div>
                                                <div>
                                                    <label for="profile-city" class="block text-sm font-medium" style="color: var(--text-secondary);">City</label>
                                                    <input type="text" id="profile-city" name="city" placeholder="e.g. Mumbai" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                                </div>
                                            </div>
                                            <div>
                                                <button type="submit" class="bg-slate-600 hover:bg-slate-700 text-white font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center min-w-[150px]">
                                                    <span class="btn-text">Save Changes</span>
                                                    <span class="spinner hidden"></span>
                                                </button>
                                            </div>
                                        </form>
                                    </div>
                                </div>
                                 <div class="rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="p-6">
                                        <h3 class="text-xl font-bold mb-6" style="color: var(--text-primary);">Change Password</h3>
                                        <form id="change-password-form" class="space-y-6">
                                            <div>
                                                <label class="block text-sm font-medium" style="color: var(--text-secondary);">Current Password</label>
                                                <input type="password" id="current-password" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                            </div>
                                             <div>
                                                <label class="block text-sm font-medium" style="color: var(--text-secondary);">New Password</label>
                                                <input type="password" id="new-password" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                            </div>
                                             <div>
                                                <label class="block text-sm font-medium" style="color: var(--text-secondary);">Confirm New Password</label>
                                                <input type="password" id="confirm-new-password" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                                            </div>
                                            <div>
                                                <button type="submit" class="btn-primary font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center min-w-[180px]">
                                                     <span class="btn-text">Update Password</span>
                                                     <span class="spinner hidden"></span>
                                                </button>
                                            </div>
                                        </form>
                                    </div>
                                </div>
                            </div>
                            <div class="lg:col-span-1 space-y-8">
                                <div class="rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="p-6">
                                        <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Account</h3>
                                        <div class="space-y-3">
                                            <p class="text-sm" style="color: var(--text-secondary);">Member Since</p>
                                            <p id="profile-member-since" class="font-semibold"></p>
                                        </div>
                                    </div>
                                </div>
                                <div class="rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="p-6">
                                        <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Subscription</h3>
                                        <div class="space-y-3">
                                            <div>
                                                <p class="text-sm" style="color: var(--text-secondary);">Subscription Start</p>
                                                <p id="profile-subscription-start" class="font-semibold">—</p>
                                            </div>
                                            <div>
                                                <p class="text-sm" style="color: var(--text-secondary);">Subscription End</p>
                                                <p id="profile-subscription-end" class="font-semibold">—</p>
                                            </div>
                                            <div>
                                                <p class="text-sm" style="color: var(--text-secondary);">Plan Type</p>
                                                <p id="profile-plan-type" class="font-semibold">—</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- AI Analyst Page -->
                    <div id="ai-analyst" class="page">
                        <div class="space-y-2">
                            <!-- Header Section -->
                            <div class="text-center py-2">
                                <div class="flex items-center justify-center mb-2">
                                    <i data-feather="cpu" class="h-8 w-8 mr-3" style="color: var(--text-primary);"></i>
                                    <h1 class="text-3xl font-bold" style="color: var(--text-primary);">AI-Powered Trading Insights</h1>
                                </div>
                                <p class="text-lg" style="color: var(--text-secondary);">Personalized suggestions based on your trade history.</p>
                                <div id="ai-summary-highlight" class="mt-2 text-xl font-semibold" style="color: var(--text-primary);">
                                    <!-- Dynamic summary will be inserted here -->
                                </div>
                            </div>

                            <!-- Alert Cards Section -->
                            <div id="ai-alert-cards" class="space-y-4">
                                <!-- Alert cards will be dynamically inserted here -->
                            </div>

                            <!-- Summary Cards Section -->
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="trending-up" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Total Trades</p>
                                            <p id="ai-total-trades" class="text-2xl font-bold" style="color: var(--text-primary);">0</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="target" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Win Rate</p>
                                            <p id="ai-win-rate" class="text-2xl font-bold" style="color: var(--text-primary);">0%</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i class="h-6 w-6 flex items-center justify-center font-bold text-lg not-italic" style="color: var(--text-primary);">₹</i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Avg P&L per Trade</p>
                                            <p id="ai-avg-pnl" class="text-2xl font-bold" style="color: var(--text-primary);">₹0</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="bar-chart-2" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Net P&L</p>
                                            <p id="ai-net-pnl" class="text-2xl font-bold" style="color: var(--text-primary);">₹0</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Trade Efficiency, Predictive Win Probability & Trading Discipline Score Cards -->
                            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="clock" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Trade Efficiency</p>
                                            <p id="ai-trade-efficiency" class="text-2xl font-bold" style="color: var(--text-primary);">₹0.00 / min</p>
                                            <p id="ai-efficiency-interpretation" class="text-xs mt-1" style="color: var(--text-secondary);">No Data</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="target" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Recent Win Probability</p>
                                            <p id="ai-predictive-win-prob" class="text-2xl font-bold" style="color: var(--text-primary);">0%</p>
                                            <p id="ai-predictive-win-interpretation" class="text-xs mt-1" style="color: var(--text-secondary);">No Data</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="p-2 rounded-lg" style="background-color: var(--bg-secondary);">
                                            <i data-feather="shield" class="h-6 w-6" style="color: var(--text-primary);"></i>
                                        </div>
                                        <div class="ml-4">
                                            <p class="text-sm font-medium" style="color: var(--text-secondary);">Trading Discipline Score</p>
                                            <p id="ai-discipline-score" class="text-2xl font-bold" style="color: var(--text-primary);">0/100</p>
                                            <p id="ai-discipline-interpretation" class="text-xs mt-1" style="color: var(--text-secondary);">No Data</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Trader Personality Profile Section -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Trader Personality Profile</h3>
                                    <div id="ai-trader-profile" class="space-y-4">
                                        <!-- Trader profile will be dynamically inserted here -->
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Behavior & Psychology</h3>
                                    <div id="ai-behavior-insights" class="space-y-4">
                                        <!-- Behavior insights will be dynamically inserted here -->
                                    </div>
                                </div>
                            </div>

                            <!-- Emotional Volatility and Performance Under Stress Section -->
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Emotional Volatility</h3>
                                    <div id="ai-emotional-volatility" class="space-y-4">
                                        <!-- Emotional volatility insights will be dynamically inserted here -->
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Performance Under Stress</h3>
                                    <div id="ai-performance-stress" class="space-y-4">
                                        <!-- Performance under stress insights will be dynamically inserted here -->
                                    </div>
                                </div>
                            </div>

                            <!-- Risk Discipline Panel -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Risk Discipline</h3>
                                <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                                    <div class="text-center">
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Stop Loss Usage</p>
                                        <p id="ai-stop-loss-usage" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">N/A</p>
                                    </div>
                                    <div class="text-center">
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Avg Stop Loss</p>
                                        <p id="ai-avg-stop-loss" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">N/A</p>
                                    </div>
                                    <div class="text-center">
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Oversize Positions</p>
                                        <p id="ai-oversize-positions" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0</p>
                                    </div>
                                    <div class="text-center">
                                        <p class="text-sm font-medium" style="color: var(--text-secondary);">Capital Utilization</p>
                                        <p id="ai-capital-utilization" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0.0%</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Adaptive Risk Suggestion Section -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Adaptive Risk Management</h3>
                                <div id="ai-adaptive-risk-recommendation">
                                    <!-- Adaptive risk suggestion will be dynamically inserted here -->
                                </div>
                            </div>

                            <!-- AI Recommendations Section -->
                            <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">AI Recommendations</h3>
                                <div id="ai-recommendations" class="space-y-3">
                                    <!-- AI recommendations will be dynamically inserted here -->
                                </div>
                            </div>

                            <!-- Consistency & Growth Stats -->
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Consistency Score</h3>
                                    <div class="text-center">
                                        <p id="ai-consistency-score" class="text-4xl font-bold" style="color: var(--text-primary);">0%</p>
                                        <p class="text-sm mt-2" style="color: var(--text-secondary);">Profitable trading days</p>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Consistency Index</h3>
                                    <div class="text-center">
                                        <p id="ai-consistency-index" class="text-4xl font-bold" style="color: var(--text-primary);">0.00</p>
                                        <p id="ai-consistency-interpretation" class="text-sm mt-2" style="color: var(--text-secondary);">No Data</p>
                                    </div>
                                </div>
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Growth Projection</h3>
                                    <div class="text-center">
                                        <p id="ai-growth-projection" class="text-4xl font-bold" style="color: var(--text-primary);">₹0</p>
                                        <p class="text-sm mt-2" style="color: var(--text-secondary);">Expected monthly growth</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Challenge Page -->
                    <div id="challenge" class="page">
                        <div id="challenge-stats-view">
                            <div id="challenge-active-wrapper">
                                <div class="flex items-center justify-between mb-8">
                                    <h2 class="text-3xl font-bold" style="color: var(--text-primary);">Capital Growth Challenge</h2>
                                    <button id="set-challenge-btn" class="btn-primary font-semibold py-2 px-4 rounded-md shadow-sm text-sm">Set Challenge</button>
                                </div>
                                <div id="challenge-active-container" class="space-y-8 hidden">
                                    <p class="text-lg" style="color: var(--text-secondary);">Track your progress towards your trading goals with real-time analytics and performance metrics.</p>
                                    
                                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                                        <div class="p-5 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Days Remaining</h3>
                                            <p id="challenge-days-remaining" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0</p>
                                            <p id="challenge-end-date" class="text-xs" style="color: var(--text-muted);">01 Jan 1970</p>
                                        </div>
                                        <div class="p-5 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Current Capital</h3>
                                            <p id="challenge-current-capital" class="text-2xl font-bold mt-2">₹0.00</p>
                                            <p id="challenge-target-capital" class="text-xs" style="color: var(--text-muted);">Target: ₹0.00</p>
                                        </div>
                                        <div class="p-5 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Daily Target</h3>
                                            <p id="challenge-daily-target" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">₹0.00</p>
                                            <p class="text-xs" style="color: var(--text-muted);">Profit needed per day</p>
                                        </div>
                                        <div class="p-5 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <h3 class="text-sm font-medium" style="color: var(--text-secondary);">Win Rate</h3>
                                            <p id="challenge-win-rate" class="text-2xl font-bold mt-2" style="color: var(--text-primary);">0.00%</p>
                                            <p class="text-xs" style="color: var(--text-muted);">Of challenge period</p>
                                        </div>
                                    </div>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                                        <div class="p-6 rounded-lg shadow-sm flex items-center justify-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <div class="relative h-48 w-48">
                                                <canvas id="challengeProgressChart"></canvas>
                                                <div class="absolute inset-0 flex items-center justify-center flex-col">
                                                    <p id="challenge-progress-percent" class="text-3xl font-bold" style="color: var(--text-primary);">0%</p>
                                                    <p class="text-sm" style="color: var(--text-secondary);">Progress</p>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                            <h3 class="text-xl font-bold mb-4" style="color: var(--text-primary);">Key Metrics</h3>
                                            <div class="space-y-4">
                                                <div class="flex justify-between items-center border-b pb-2" style="border-color: var(--border-color);">
                                                    <span class="text-sm" style="color: var(--text-secondary);">Average Risk/Reward</span>
                                                    <span id="challenge-avg-rr" class="font-semibold" style="color: var(--text-primary);">0:0</span>
                                                </div>
                                                <div class="flex justify-between items-center border-b pb-2" style="border-color: var(--border-color);">
                                                    <span class="text-sm" style="color: var(--text-secondary);">Highest Profit Day</span>
                                                    <span id="challenge-highest-profit" class="font-semibold text-green-500">₹0.00</span>
                                                </div>
                                                <div class="flex justify-between items-center pb-2" style="border-color: var(--border-color);">
                                                    <span class="text-sm" style="color: var(--text-secondary);">Max Drawdown</span>
                                                    <span id="challenge-max-drawdown" class="font-semibold text-red-500">0.00%</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Loading State Container -->
                            <div id="challenge-loading-container" class="flex flex-col items-center justify-center p-12 text-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 0.5rem;">
                                <div class="animate-spin rounded-full h-8 w-8 border-b-2 mb-4" style="border-color: var(--text-primary);"></div>
                                <p class="text-sm" style="color: var(--text-secondary);">Loading challenge data...</p>
                            </div>
                            
                            <div id="challenge-inactive-container" class="flex flex-col items-center justify-center p-12 text-center hidden" style="background-color: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 0.5rem;">
                                <i data-feather="award" class="h-16 w-16 mb-4" style="color: var(--text-muted);"></i>
                                <h3 class="text-xl font-semibold mb-2" style="color: var(--text-primary);">No Active Challenge</h3>
                                <p class="text-sm mb-6" style="color: var(--text-secondary);">Set a new challenge to track your progress towards a specific goal.</p>
                                <button id="set-challenge-btn-inactive" class="btn-primary font-semibold py-2 px-6 rounded-md shadow-sm">Start a New Challenge</button>
                            </div>
                        </div>

                        <!-- Challenge Statistics Section -->
                        <div class="mt-12">
                            <h3 class="text-2xl font-bold mb-6" style="color: var(--text-primary);">Challenge Statistics</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                                <!-- Challenge Wins Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0">
                                            <div class="w-12 h-12 rounded-full bg-green-100 flex items-center justify-center">
                                                <i data-feather="award" class="h-6 w-6 text-green-600"></i>
                                            </div>
                                        </div>
                                        <div class="ml-4">
                                            <h4 class="text-lg font-semibold" style="color: var(--text-primary);">Challenges Won</h4>
                                            <p id="challenge-wins-count" class="text-3xl font-bold text-green-600">0</p>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Challenge Losses Card -->
                                <div class="p-6 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                                    <div class="flex items-center">
                                        <div class="flex-shrink-0">
                                            <div class="w-12 h-12 rounded-full bg-red-100 flex items-center justify-center">
                                                <i data-feather="x-circle" class="h-6 w-6 text-red-600"></i>
                                            </div>
                                        </div>
                                        <div class="ml-4">
                                            <h4 class="text-lg font-semibold" style="color: var(--text-primary);">Challenges Lost</h4>
                                            <p id="challenge-losses-count" class="text-3xl font-bold text-red-600">0</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="mt-12">
                            <div class="flex justify-between items-center mb-6">
                                <h3 class="text-2xl font-bold" style="color: var(--text-primary);">Challenge History</h3>
                                <button id="clear-challenge-history" class="px-4 py-2 text-sm rounded-md" style="background-color: var(--bg-secondary); color: var(--text-primary); border: 1px solid var(--border-color);">
                                    Clear History
                                </button>
                            </div>
                            <div id="challenge-history-container" class="space-y-4">
                                <!-- History items will be injected here -->
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
        <!-- Sidebar Overlay -->
        <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-30 hidden md:hidden" style="z-index: 30;"></div>
    </div>

    <!-- Trade Saved Success Modal -->
    <div id="trade-saved-modal" class="modal-overlay hidden">
        <div class="w-full max-w-md m-4 rounded-lg shadow-xl text-center" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
            <div class="p-8">
                <div class="w-16 h-16 mx-auto flex items-center justify-center rounded-full bg-green-100 mb-4">
                    <i data-feather="check-circle" class="h-8 w-8 text-green-600"></i>
                </div>
                <h3 class="text-xl font-bold" style="color: var(--text-primary);">Trade Saved Successfully!</h3>
                <p class="text-sm mt-2 mb-6" style="color: var(--text-secondary);">The more you write, the more you grow. Stay focused!</p>

                <div class="p-4 rounded-lg" style="background-color: var(--bg-secondary);">
                    <h4 class="font-semibold text-md mb-4" style="color: var(--text-primary);">Comparison with Previous Day's P&L</h4>
                    <div class="flex justify-around items-center mb-4">
                        <div>
                            <p class="text-xs" style="color: var(--text-muted);">Today's P&L</p>
                            <p id="tsm-today-pnl" class="font-bold text-lg text-green-500">+₹0.00</p>
                        </div>
                        <div class="border-l h-10" style="border-color: var(--border-color);"></div>
                        <div>
                            <p class="text-xs" style="color: var(--text-muted);">Yesterday's P&L</p>
                            <p id="tsm-yesterday-pnl" class="font-bold text-lg text-green-500">+₹0.00</p>
                        </div>
                    </div>
                    <div class="flex items-center justify-center text-xs p-2 rounded" style="background-color: var(--bg-primary);">
                        <i data-feather="arrow-up" class="h-4 w-4 text-green-500 mr-1"></i>
                        <span id="tsm-comparison-text" style="color: var(--text-secondary);">You saw an increase of ₹0.00 in your pnl.</span>
                    </div>
                </div>

                <button id="trade-saved-close-btn" class="mt-6 w-full btn-primary font-semibold py-2 px-6 rounded-md shadow-sm">Keep Journaling</button>
            </div>
        </div>
    </div>


    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal-overlay hidden">
        <div class="w-full max-w-sm m-4 rounded-lg shadow-xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
            <div class="p-6">
                <div class="flex items-start gap-4">
                    <div class="flex-shrink-0 w-12 h-12 flex items-center justify-center rounded-full bg-red-100">
                        <i data-feather="alert-triangle" class="h-6 w-6 text-red-600"></i>
                    </div>
                    <div>
                        <h3 id="confirmation-title" class="text-lg font-semibold" style="color: var(--text-primary);">Confirmation</h3>
                        <p id="confirmation-message" class="text-sm mt-1" style="color: var(--text-secondary);">Are you sure? This action cannot be undone.</p>
                    </div>
                </div>
            </div>
            <div class="p-4 border-t flex justify-end items-center space-x-3" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                <button type="button" id="confirmation-cancel-btn" class="border font-semibold py-2 px-4 rounded-md shadow-sm" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">Cancel</button>
                <button type="button" id="confirmation-confirm-btn" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-6 rounded-md shadow-sm">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="transaction-modal" class="modal-overlay hidden">
        <div class="w-full max-w-md m-4 rounded-lg shadow-xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
             <form id="transaction-form">
                <input type="hidden" id="ledger-id" name="ledgerId">
                <div class="p-6 border-b flex justify-between items-center" style="border-color: var(--border-color);">
                    <h3 id="transaction-modal-title" class="text-xl font-semibold" style="color: var(--text-primary);">Deposit Funds</h3>
                    <button type="button" class="close-modal-btn p-1 rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                        <i data-feather="x" class="h-5 w-5"></i>
                    </button>
                </div>
                <div class="p-6 space-y-4">
                    <div>
                        <label for="transaction-amount" class="block text-sm font-medium" style="color: var(--text-secondary);">Amount (₹)</label>
                        <input type="number" step="0.01" id="transaction-amount" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" placeholder="0.00" required>
                    </div>
                     <div>
                        <label for="transaction-date" class="block text-sm font-medium" style="color: var(--text-secondary);">Date</label>
                        <input type="date" id="transaction-date" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" required>
                    </div>
                     <div>
                        <label for="transaction-notes" class="block text-sm font-medium" style="color: var(--text-secondary);">Notes (Optional)</label>
                        <textarea id="transaction-notes" rows="2" class="mt-1 w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);"></textarea>
                    </div>
                </div>
                <div class="p-4 border-t flex justify-end items-center space-x-3" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                    <button type="button" class="close-modal-btn border font-semibold py-2 px-4 rounded-md shadow-sm" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">Cancel</button>
                    <button type="submit" id="transaction-submit-btn" class="btn-primary font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center min-w-[140px]">
                        <span class="btn-text">Add Deposit</span>
                        <span class="spinner hidden"></span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Challenge Modal -->
    <div id="challenge-modal" class="modal-overlay hidden">
        <div class="w-full max-w-md m-4 rounded-lg shadow-xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
             <form id="challenge-form">
                <input type="hidden" id="challenge-id" name="challengeId">
                <div class="p-6 border-b flex justify-between items-center" style="border-color: var(--border-color);">
                    <h3 id="challenge-modal-title" class="text-xl font-semibold" style="color: var(--text-primary);">Set Trading Challenge</h3>
                    <button type="button" class="close-modal-btn p-1 rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                        <i data-feather="x" class="h-5 w-5"></i>
                    </button>
                </div>
                <div class="p-6 space-y-4">
                    <div>
                        <label for="starting-capital" class="block text-sm font-medium" style="color: var(--text-secondary);">Starting Capital (₹)</label>
                        <input type="number" step="1000" id="starting-capital" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" placeholder="100000" required>
                    </div>
                    <div>
                        <label for="target-capital" class="block text-sm font-medium" style="color: var(--text-secondary);">Target Capital (₹)</label>
                        <input type="number" step="1000" id="target-capital" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" placeholder="200000" required>
                    </div>
                    <div>
                        <label for="timeframe" class="block text-sm font-medium" style="color: var(--text-secondary);">Timeframe</label>
                        <select id="timeframe" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);">
                            <option value="7">1 Week</option>
                            <option value="30">1 Month</option>
                            <option value="90">3 Months</option>
                            <option value="180">6 Months</option>
                            <option value="365">1 Year</option>
                        </select>
                    </div>
                    <div>
                        <label for="max-risk" class="block text-sm font-medium" style="color: var(--text-secondary);">Max Risk Per Trade (%)</label>
                        <input type="number" step="0.1" id="max-risk" class="mt-1 block w-full rounded-md border focus:border-blue-500 focus:ring-blue-500" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color);" placeholder="2" required>
                    </div>
                </div>
                <div class="p-4 border-t flex justify-end items-center space-x-3" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                    <button type="button" class="close-modal-btn border font-semibold py-2 px-4 rounded-md shadow-sm" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">Cancel</button>
                    <button type="submit" id="challenge-submit-btn" class="btn-primary font-semibold py-2 px-6 rounded-md shadow-sm flex items-center justify-center min-w-[140px]">
                        <span class="btn-text">Set Challenge</span>
                        <span class="spinner hidden"></span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- New Trading Details Modal -->
    <div id="trade-details-modal" class="trade-details-modal">
        <div class="relative">
             <div class="modal-header flex justify-between items-center">
                <div>
                    <h3 class="text-lg font-bold">Trading Details</h3>
                    <p id="modal-date" class="text-sm" style="color: var(--text-muted);"></p>
                </div>
                <button type="button" class="close-btn">&times;</button>
             </div>
             <div class="modal-content">
                 <div class="modal-stats-grid">
                     <div class="stat-card">
                         <div>
                             <p class="stat-card-label">Total P&L</p>
                             <p id="modal-total-pnl" class="stat-card-value">₹0.00</p>
                         </div>
                         <div class="stat-card-icon" style="background-color: rgba(34, 197, 94, 0.2); color: #22c55e;"><i data-feather="trending-up"></i></div>
                     </div>
                     <div class="stat-card">
                         <div>
                             <p class="stat-card-label">Average R:R</p>
                             <p id="modal-avg-rr" class="stat-card-value">0:0</p>
                         </div>
                         <div class="stat-card-icon" style="background-color: rgba(59, 130, 246, 0.2); color: #3b82f6;"><i data-feather="target"></i></div>
                     </div>
                     <div class="stat-card">
                         <div>
                             <p class="stat-card-label">Total Trades</p>
                             <p id="modal-total-trades" class="stat-card-value">0</p>
                         </div>
                          <div class="stat-card-icon" style="background-color: rgba(234, 179, 8, 0.2); color: #eab308;"><i data-feather="list"></i></div>
                     </div>
                     <div class="stat-card">
                         <div>
                             <p class="stat-card-label">Win Rate</p>
                             <p id="modal-win-rate" class="stat-card-value">0%</p>
                         </div>
                         <div class="stat-card-icon" style="background-color: rgba(245, 158, 11, 0.2); color: #f59e0b;"><i data-feather="award"></i></div>
                     </div>
                 </div>
                 <div class="overflow-y-auto max-h-64 overflow-x-auto">
                    <table class="trades-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th>Size</th>
                                <th>Entry</th>
                                <th>Exit</th>
                                <th>P&L</th>
                            </tr>
                        </thead>
                        <tbody id="modal-trades-tbody">
                        </tbody>
                    </table>
                 </div>
             </div>
        </div>
    </div>

    <!-- Edit Trade Modal -->
    <div id="edit-trade-modal" class="modal-overlay hidden">
        <div class="w-full max-w-xl m-4 rounded-lg shadow-xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
            <form id="edit-trade-form">
                <input type="hidden" id="edit-trade-id" name="tradeId">
                <div class="p-3 border-b flex justify-between items-center" style="border-color: var(--border-color);">
                    <h3 class="text-lg font-semibold" style="color: var(--text-primary);">Edit Trade</h3>
                    <button type="button" id="edit-trade-close-btn" class="close-modal-btn p-0.5 rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);">
                        <i data-feather="x" class="h-3 w-3"></i>
                    </button>
                </div>
                <div class="p-3 max-h-48 overflow-y-auto">
                    <!-- Trade Type Tabs -->
                    <div class="flex space-x-1 mb-3 p-0.5 rounded-lg" style="background-color: var(--bg-secondary);">
                        <button type="button" id="edit-trade-tab" class="flex-1 py-1 px-2 text-sm font-medium rounded-md transition-colors duration-200" style="background-color: var(--bg-primary); color: var(--text-primary);">
                            Details
                        </button>
                        <button type="button" id="edit-exit-tab" class="flex-1 py-1 px-2 text-sm font-medium rounded-md transition-colors duration-200" style="color: var(--text-secondary);">
                            Exit
                        </button>
                    </div>

                    <!-- Trade Details Tab Content -->
                    <div id="edit-trade-content" class="space-y-2">
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label for="edit-symbol" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Symbol</label>
                                <input type="text" id="edit-symbol" name="symbol" required class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                            <div>
                                <label for="edit-quantity" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Quantity</label>
                                <input type="number" id="edit-quantity" name="quantity" step="0.01" required class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label for="edit-entry-price" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Entry Price</label>
                                <input type="number" id="edit-entry-price" name="entry_price" step="0.01" required class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                            <div>
                                <label for="edit-entry-date" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Entry Date</label>
                                <input type="date" id="edit-entry-date" name="entry_date" required class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label for="edit-stop-loss" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Stop Loss</label>
                                <input type="number" id="edit-stop-loss" name="stop_loss" step="0.01" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                            <div>
                                <label for="edit-target-price" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Target Price</label>
                                <input type="number" id="edit-target-price" name="target_price" step="0.01" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label for="edit-exit-price" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Exit Price</label>
                                <input type="number" id="edit-exit-price" name="exit_price" step="0.01" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                            <div>
                                <label for="edit-exit-date" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Exit Date</label>
                                <input type="date" id="edit-exit-date" name="exit_date" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                        </div>
                        <div>
                            <label for="edit-reasons" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Notes</label>
                            <textarea name="reasons" id="edit-reasons" rows="1" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;" placeholder="Notes..."></textarea>
                        </div>
                    </div>

                    <!-- Exit Trade Tab Content -->
                    <div id="edit-exit-content" class="space-y-2 hidden">
                        <div class="grid grid-cols-2 gap-2">
                            <div>
                                <label for="edit-exit-quantity" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Exit Qty</label>
                                <input type="number" id="edit-exit-quantity" name="exit_quantity" step="0.01" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                            <div>
                                <label for="edit-exit-price-exit" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Exit Price</label>
                                <input type="number" id="edit-exit-price-exit" name="exit_price_exit" step="0.01" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                            </div>
                        </div>
                        <div>
                            <label for="edit-exit-date-exit" class="block text-xs font-medium mb-0.5" style="color: var(--text-primary);">Exit Date</label>
                            <input type="date" id="edit-exit-date-exit" name="exit_date_exit" class="w-full rounded border focus:border-blue-500 focus:ring-blue-500 text-xs" style="background-color: var(--bg-primary); color: var(--text-primary); border-color: var(--border-color); padding: 0.2rem;">
                        </div>
                    </div>
                </div>
                <div class="p-2 border-t flex justify-end items-center" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                    <div class="flex space-x-1">
                        <button type="button" id="edit-trade-cancel-btn" class="close-modal-btn border font-medium py-1 px-2 rounded text-sm" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">Cancel</button>
                        <button type="submit" id="edit-trade-submit-btn" class="btn-primary font-medium py-1 px-3 rounded shadow-sm flex items-center justify-center min-w-[100px] text-sm">
                            <span class="btn-text">Save</span>
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
        
    <!-- Scroll to Top Button -->
    <button id="scroll-to-top-btn" class="hidden fixed bottom-8 right-8 bg-blue-600 text-white p-2 rounded-full shadow-lg hover:bg-blue-700 transition-all duration-300" style="z-index: 9999;">
        <i data-feather="arrow-up" class="h-4 w-4"></i>
    </button>

    <!-- Supabase Logic -->
    <script type="module">
        // Import Supabase client from CDN
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // --- Supabase Client Initialization ---
        const supabaseUrl = "https://pedhqcyudanorjewtdiy.supabase.co"; 
        const supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBlZGhxY3l1ZGFub3JqZXd0ZGl5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0OTE1ODAsImV4cCI6MjA3NTA2NzU4MH0.5-5t2Z3gosmTmaFlLKKTm7jHYB7HDESt7h9wH5VAHWk"; 
        
        const supabase = createClient(supabaseUrl, supabaseAnonKey);

        // --- Backend Adapter (Inlined) ---
        const auth = {
            onAuthStateChanged: (callback) => {
                return supabase.auth.onAuthStateChange((event, session) => {
                    const user = session?.user || null;
                    if (user) {
                        user.uid = user.id;
                        user.displayName = user.user_metadata?.name || user.email;
                    }
                    callback(user);
                });
            },
            signIn: async (email, password) => {
                try {
                    const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                    if (error) throw error;
                    return { user: data.user, session: data.session };
                } catch (error) {
                    console.error('Sign in error:', error);
                    throw error;
                }
            },
            signUp: async (email, password) => {
                try {
                    const { data, error } = await supabase.auth.signUp({ email, password });
                    if (error) throw error;
                    // Optional: Create a profile entry upon sign-up
                    if (data.user) {
                        try {
                            await supabase.from('profiles').insert({ id: data.user.id, name: 'New User', email: data.user.email });
                        } catch (profileError) {
                            console.warn('Profile creation failed:', profileError);
                            // Continue without throwing - profile creation is optional
                        }
                    }
                    return { user: data.user, session: data.session };
                } catch (error) {
                    console.error('Sign up error:', error);
                    throw error;
                }
            },
            updateProfile: async (user, profileData) => {
                try {
                    const { data, error } = await supabase.auth.updateUser({
                        data: { name: profileData.displayName }
                    });
                    if (error) throw error;
                    return data;
                } catch (error) {
                    console.error('Update profile error:', error);
                    throw error;
                }
            },
            signOut: async () => {
                try {
                    await supabase.auth.signOut();
                } catch (error) {
                    console.error('Sign out error:', error);
                    // Don't throw - logout should always succeed from UI perspective
                }
            },
            getUser: async () => {
                const { data, error } = await supabase.auth.getSession();
                if (error) {
                    console.error("Error getting supabase session:", error);
                    return null;
                }
                return data?.session?.user || null;
            }
        };

        // Removed unused Firestore-style db object - now using direct Supabase operations
        // Removed unused Firestore helper functions - now using direct Supabase operations
        // --- End of Inlined Adapter ---

        // === Small helper services for trades and files ===
        async function addTrade(trade) {
          // trade: { user_id, asset, entryPrice, exitPrice, quantity, entryDate, exitDate, pnl, ... }
          const { data, error } = await supabase.from('trades').insert([trade]).select();
          if (error) throw error;
          return data[0];
        }

        async function uploadAttachment(userId, file) {
          // `file` is an input File object. Place in 'attachments' bucket.
          const filename = `${userId}/${Date.now()}_${file.name}`;
          const { error: uploadErr } = await supabase.storage.from('attachments').upload(filename, file);
          if (uploadErr) throw uploadErr;
          const { data: { publicUrl } } = supabase.storage.from('attachments').getPublicUrl(filename);
          return { publicUrl, path: filename };
        }

        async function getTradesForCalendar(userId, startDateISO, endDateISO) {
          const { data, error } = await supabase
            .from('trades')
            .select('*')
            .eq('user_id', userId)
            .gte('exit_date', startDateISO)
            .lte('exit_date', endDateISO)
            .order('exit_date', { ascending: true });
          if (error) throw error;
          return data;
        }


        // --- GLOBAL APP STATE ---
        const appState = {
            theme: localStorage.getItem('theme') || 'light',
            calendarDate: new Date(),
            user: null,
            profileData: null,
            trades: [],
            ledger: [],
            challenge: null,
            challengeHistory: [],
            accountValue: 0,
            clockIntervalId: null,
            unsubscribeTrades: () => {},
            unsubscribeLedger: () => {},
            unsubscribeProfile: () => {},
            unsubscribeChallenge: () => {},
            unsubscribeChallengeHistory: () => {},
        };

        // Make appState globally accessible
        window.appState = appState;


        // --- UI ELEMENTS ---
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const mainContent = document.getElementById('main-content');
        const pageTitle = document.getElementById('page-title');
        const themeToggleInput = document.getElementById('theme-toggle-input');
        const sidebar = document.getElementById('sidebar');
        const menuToggleBtn = document.getElementById('menu-toggle-btn');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const confirmationModal = document.getElementById('confirmation-modal');
        const liveTimeEl = document.getElementById('live-time');
        const liveDateEl = document.getElementById('live-date');
        
        // --- UTILITY FUNCTIONS ---
        

        

        // Get theme-aware colors for charts
        const getThemeColors = () => {
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const chartTextColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim();
            return {
                textPrimary: isDark ? '#ffffff' : '#212529',
                textSecondary: isDark ? '#d1d5db' : '#2c333a',
                textMuted: isDark ? '#d1d5db' : '#3e444a',
                gridColor: 'rgba(128, 128, 128, 0.1)',
                chartText: chartTextColor || (isDark ? '#ffffff' : '#212529'),
                // Ensure we always have a valid text color
                textColor: isDark ? '#ffffff' : '#212529'
            };
        };

        // Get continuous tooltip configuration for all charts
        const getContinuousTooltipConfig = (themeColors, customCallbacks = {}) => {
            return {
                enabled: true,
                mode: 'index',
                intersect: false,
                position: 'nearest',
                backgroundColor: '#111827', // Use dark background for all tooltips
                titleColor: '#ffffff', // White text for all tooltips
                bodyColor: '#ffffff', // White text for all tooltips
                borderColor: 'rgba(255, 255, 255, 0.06)',
                borderWidth: 1,
                cornerRadius: 6,
                displayColors: true,
                padding: 12,
                titleFont: {
                    size: 13,
                    weight: 'bold'
                },
                bodyFont: {
                    size: 12
                },
                animation: {
                    duration: 0
                },
                ...customCallbacks
            };
        };

        // Update all charts when theme changes
        const updateChartsOnThemeChange = () => {
            const colors = getThemeColors();
            console.log('Updating charts with theme colors:', colors);
            
            // Use requestAnimationFrame for smoother theme updates
            requestAnimationFrame(() => {
                Object.values(chartInstances).forEach((chart, index) => {
                    if (chart && typeof chart.update === 'function') {
                        try {
                            // Update chart options with new theme colors
                            if (chart.options && chart.options.scales) {
                                // Update axis text colors
                                if (chart.options.scales.x && chart.options.scales.x.ticks) {
                                    chart.options.scales.x.ticks.color = colors.chartText || colors.textColor;
                                }
                                if (chart.options.scales.y && chart.options.scales.y.ticks) {
                                    chart.options.scales.y.ticks.color = colors.chartText || colors.textColor;
                                }
                            }
                            
                            // Update legend colors
                            if (chart.options && chart.options.plugins && chart.options.plugins.legend) {
                                if (chart.options.plugins.legend.labels) {
                                    chart.options.plugins.legend.labels.color = colors.chartText || colors.textColor;
                                }
                            }
                            
                            // Update tooltip colors and continuous mode - Force dark theme for all tooltips
                            if (chart.options && chart.options.plugins && chart.options.plugins.tooltip) {
                                // Force all tooltips to use dark theme regardless of page theme
                                chart.options.plugins.tooltip.backgroundColor = '#111827';
                                chart.options.plugins.tooltip.titleColor = '#ffffff';
                                chart.options.plugins.tooltip.bodyColor = '#ffffff';
                                chart.options.plugins.tooltip.borderColor = 'rgba(255, 255, 255, 0.06)';
                                
                                // Ensure continuous tooltip mode is enabled
                                chart.options.plugins.tooltip.mode = 'index';
                                chart.options.plugins.tooltip.intersect = false;
                            }
                            
                            // Update grid colors
                            if (chart.options && chart.options.scales) {
                                if (chart.options.scales.x && chart.options.scales.x.grid) {
                                    chart.options.scales.x.grid.color = colors.gridColor;
                                }
                                if (chart.options.scales.y && chart.options.scales.y.grid) {
                                    chart.options.scales.y.grid.color = colors.gridColor;
                                }
                            }
                            
                            // Update with no animation for instant theme change
                            chart.update('none');
                            console.log(`Updated chart ${index + 1} successfully`);
                        } catch (error) {
                            console.error(`Error updating chart ${index + 1}:`, error);
                        }
                    }
                });
            });
        };





        
        const countTradingDays = (startDate, endDate) => {
            let count = 0;
            const curDate = new Date(startDate.getTime());
            while (curDate <= endDate) {
                const dayOfWeek = curDate.getDay();
                if (dayOfWeek !== 0 && dayOfWeek !== 6) { // 0=Sun, 6=Sat
                    count++;
                }
                curDate.setDate(curDate.getDate() + 1);
            }
            return count;
        };
        
        const calculateNetPnl = (trade) => {
            try {
                if (!trade || !trade.exit_price || !trade.exit_date) {
                    return 0;
                }
                
                // Validate numeric inputs
                const exitPrice = parseFloat(trade.exit_price);
                const entryPrice = parseFloat(trade.entry_price);
                const quantity = parseFloat(trade.quantity);
                
                if (!isFinite(exitPrice) || !isFinite(entryPrice) || !isFinite(quantity) || quantity <= 0) {
                    return 0;
                }
                
                // Use performance cache for expensive PnL calculations
                const tradeKey = trade.id || `${trade.asset}_${trade.entry_date}_${trade.exit_date}_${trade.exit_price}`;
                return performanceCache.getCachedTradeCalc(tradeKey, 'netPnl', () => {
                    // Check if this is a partial exit trade
                    const isPartialExit = trade.exit_quantity && trade.exit_quantity > 0 && trade.exit_quantity < trade.quantity;
                    
                    if (isPartialExit) {
                        // For partial exits, calculate P&L from stored partial exit data (async)
                        return calculatePartialExitPnlSync(trade);
                    }
                    
                    // For full exits, use the original calculation
                    const exitQty = trade.exit_quantity > 0 ? trade.exit_quantity : trade.quantity;
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    const grossPnl = (exitPrice - entryPrice) * exitQty * (isShort ? -1 : 1);
                    const brokerage = parseFloat(trade.brokerage) || 0;
                    const otherFees = parseFloat(trade.other_fees) || 0;
                    const netPnl = grossPnl - brokerage - otherFees;
                    
                    return isFinite(netPnl) ? netPnl : 0;
                });
            } catch (error) {
                console.warn('Error calculating net P&L for trade:', trade?.id, error);
                return 0;
            }
        };

        // Calculate Consistency Index (Average Daily P&L / Standard Deviation of Daily P&L)
        const calculateConsistencyIndex = (closedTrades, startingBalance) => {
            try {
                if (!closedTrades || closedTrades.length === 0) {
                    return { value: 0, interpretation: 'No Data' };
                }

                // Generate daily equity time-series
                const dailyPnL = {};
                
                closedTrades.forEach(trade => {
                    try {
                        const pnl = calculateNetPnl(trade);
                        if (isFinite(pnl)) {
                            const exitDate = new Date(trade.exit_date);
                            const dateKey = exitDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                            
                            if (!dailyPnL[dateKey]) {
                                dailyPnL[dateKey] = 0;
                            }
                            dailyPnL[dateKey] += pnl;
                        }
                    } catch (error) {
                        console.warn('Error calculating P&L for consistency index:', trade.id, error);
                    }
                });

                // Convert to array of daily P&L values
                const dailyPnLValues = Object.values(dailyPnL);
                
                if (dailyPnLValues.length === 0) {
                    return { value: 0, interpretation: 'No Data' };
                }

                // Calculate average daily P&L
                const avgDailyPnL = dailyPnLValues.reduce((sum, pnl) => sum + pnl, 0) / dailyPnLValues.length;

                // Calculate standard deviation of daily P&L
                const variance = dailyPnLValues.reduce((sum, pnl) => sum + Math.pow(pnl - avgDailyPnL, 2), 0) / dailyPnLValues.length;
                const standardDeviation = Math.sqrt(variance);

                // Calculate Consistency Index
                let consistencyIndex = 0;
                if (standardDeviation !== 0) {
                    consistencyIndex = avgDailyPnL / standardDeviation;
                }

                // Determine interpretation
                let interpretation = 'Erratic Performance';
                if (consistencyIndex >= 2.0) {
                    interpretation = 'Very Consistent';
                } else if (consistencyIndex >= 1.0) {
                    interpretation = 'Consistent';
                } else if (consistencyIndex >= 0.5) {
                    interpretation = 'Moderately Consistent';
                } else if (consistencyIndex > 0) {
                    interpretation = 'Inconsistent';
                }

                return {
                    value: consistencyIndex,
                    interpretation: interpretation,
                    avgDailyPnL: avgDailyPnL,
                    standardDeviation: standardDeviation,
                    tradingDays: dailyPnLValues.length
                };

            } catch (error) {
                console.error('Error calculating consistency index:', error);
                return { value: 0, interpretation: 'Error' };
            }
        };

        // Calculate Emotional Volatility Index (P&L volatility by emotional state)
        const calculateEmotionalVolatility = (closedTrades) => {
            try {
                console.log('calculateEmotionalVolatility called with trades:', closedTrades?.length || 0);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Data', 
                        recommendation: 'Track emotional states for better insights',
                        volatilityData: {}
                    };
                }

                // Define emotional state categories
                const negativeEmotions = ['Frustrated', 'Anxious', 'Fearful', 'Greedy'];
                const positiveEmotions = ['Calm', 'Confident', 'Neutral'];
                const neutralEmotions = ['Impatient', 'Overconfident', 'Excited'];

                // Group trades by emotional state
                const emotionalGroups = {};
                let tradesWithEmotionalState = 0;
                
                closedTrades.forEach(trade => {
                    try {
                        if (trade.emotionalState && trade.exit_date && trade.exit_price) {
                            const pnl = calculateNetPnl(trade);
                            if (isFinite(pnl)) {
                                const emotion = trade.emotionalState.trim();
                                if (!emotionalGroups[emotion]) {
                                    emotionalGroups[emotion] = [];
                                }
                                emotionalGroups[emotion].push(pnl);
                                tradesWithEmotionalState++;
                            }
                        }
                    } catch (error) {
                        console.warn('Error processing trade for emotional volatility:', trade.id, error);
                    }
                });

                console.log('Trades with emotional state:', tradesWithEmotionalState);
                console.log('Emotional groups:', Object.keys(emotionalGroups).map(emotion => 
                    `${emotion}: ${emotionalGroups[emotion].length} trades`
                ));

                // Use lower threshold for better data availability (3 trades minimum)
                const significantGroups = {};
                Object.entries(emotionalGroups).forEach(([emotion, pnlArray]) => {
                    if (pnlArray.length >= 3) {
                        significantGroups[emotion] = pnlArray;
                    }
                });

                console.log('Significant groups (>=3 trades):', Object.keys(significantGroups));

                if (Object.keys(significantGroups).length === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'Insufficient Data', 
                        recommendation: 'Need at least 3 trades per emotional state',
                        volatilityData: {}
                    };
                }

                // Calculate volatility (standard deviation) for each emotional state
                const emotionalVolatility = {};
                Object.entries(significantGroups).forEach(([emotion, pnlArray]) => {
                    const mean = pnlArray.reduce((sum, pnl) => sum + pnl, 0) / pnlArray.length;
                    const variance = pnlArray.reduce((sum, pnl) => sum + Math.pow(pnl - mean, 2), 0) / pnlArray.length;
                    const standardDeviation = Math.sqrt(variance);
                    
                    // Calculate win rate for this emotion
                    const wins = pnlArray.filter(pnl => pnl > 0).length;
                    const winRate = (wins / pnlArray.length) * 100;
                    
                    // Calculate average P&L for this emotion
                    const avgPnL = mean;
                    
                    emotionalVolatility[emotion] = {
                        volatility: standardDeviation,
                        mean: mean,
                        count: pnlArray.length,
                        winRate: winRate,
                        avgPnL: avgPnL
                    };
                });

                // Calculate average volatility for negative vs positive emotions
                let negativeVolatility = 0;
                let positiveVolatility = 0;
                let negativeCount = 0;
                let positiveCount = 0;

                Object.entries(emotionalVolatility).forEach(([emotion, data]) => {
                    if (negativeEmotions.includes(emotion)) {
                        negativeVolatility += data.volatility;
                        negativeCount++;
                    } else if (positiveEmotions.includes(emotion)) {
                        positiveVolatility += data.volatility;
                        positiveCount++;
                    }
                });

                const avgNegativeVolatility = negativeCount > 0 ? negativeVolatility / negativeCount : 0;
                const avgPositiveVolatility = positiveCount > 0 ? positiveVolatility / positiveCount : 0;

                // Find best and worst performing emotions
                const sortedByPerformance = Object.entries(emotionalVolatility)
                    .sort((a, b) => b[1].avgPnL - a[1].avgPnL);
                
                const bestEmotion = sortedByPerformance[0];
                const worstEmotion = sortedByPerformance[sortedByPerformance.length - 1];
                
                // Calculate volatility difference
                let volatilityDifference = 0;
                let interpretation = 'Neutral Performance';
                let recommendation = 'Maintain emotional balance';

                if (avgNegativeVolatility > 0 && avgPositiveVolatility > 0) {
                    volatilityDifference = ((avgNegativeVolatility - avgPositiveVolatility) / avgPositiveVolatility) * 100;
                    
                    if (volatilityDifference > 25) {
                        interpretation = `Negative emotions cause ${volatilityDifference.toFixed(0)}% more P&L volatility`;
                        recommendation = `Avoid trading when feeling ${worstEmotion ? worstEmotion[0] : 'negative emotions'}`;
                    } else if (volatilityDifference < -15) {
                        interpretation = `Positive emotions show ${Math.abs(volatilityDifference).toFixed(0)}% less volatility`;
                        recommendation = `Maintain ${bestEmotion ? bestEmotion[0] : 'positive'} emotional states`;
                    } else {
                        interpretation = 'Emotional state has minimal impact on trading performance';
                        recommendation = 'Continue current emotional management';
                    }
                } else if (avgNegativeVolatility > 0) {
                    interpretation = 'High volatility detected with negative emotions';
                    recommendation = 'Focus on emotional regulation before trading';
                } else if (avgPositiveVolatility > 0) {
                    interpretation = 'Stable performance with positive emotions';
                    recommendation = 'Maintain positive emotional states';
                }
                
                // Add performance insights
                if (bestEmotion && worstEmotion && bestEmotion[1].avgPnL > worstEmotion[1].avgPnL) {
                    const performanceDiff = bestEmotion[1].avgPnL - worstEmotion[1].avgPnL;
                    interpretation += `. Best: ${bestEmotion[0]} (₹${bestEmotion[1].avgPnL.toFixed(0)} avg), Worst: ${worstEmotion[0]} (₹${worstEmotion[1].avgPnL.toFixed(0)} avg)`;
                }

                return {
                    value: volatilityDifference,
                    interpretation: interpretation,
                    recommendation: recommendation,
                    volatilityData: emotionalVolatility,
                    avgNegativeVolatility: avgNegativeVolatility,
                    avgPositiveVolatility: avgPositiveVolatility
                };

            } catch (error) {
                console.error('Error calculating emotional volatility:', error);
                return { 
                    value: 0, 
                    interpretation: 'Error', 
                    recommendation: 'Analysis unavailable',
                    volatilityData: {}
                };
            }
        };

        // Calculate Trade Efficiency (P&L per unit of time)
        const calculateTradeEfficiency = (closedTrades) => {
            try {
                console.log('calculateTradeEfficiency called with trades:', closedTrades?.length || 0);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Data', 
                        recommendation: 'Add closed trades to see efficiency metrics',
                        efficiencyData: {}
                    };
                }

                let totalEfficiency = 0;
                let validTrades = 0;
                let totalHoldingTime = 0;
                let totalPnL = 0;
                const tradeEfficiencies = [];

                closedTrades.forEach(trade => {
                    try {
                        if (trade.entry_date && trade.exit_date) {
                            const entryDate = new Date(trade.entry_date);
                            const exitDate = new Date(trade.exit_date);
                            
                            // Validate dates
                            if (!isNaN(entryDate.getTime()) && !isNaN(exitDate.getTime())) {
                                const holdingTimeMinutes = (exitDate - entryDate) / (1000 * 60);
                                
                                // Handle zero or negative holding time
                                if (holdingTimeMinutes > 0) {
                                    const pnl = calculateNetPnl(trade);
                                    if (isFinite(pnl)) {
                                        const pnlPerMinute = pnl / holdingTimeMinutes;
                                        totalEfficiency += pnlPerMinute;
                                        totalHoldingTime += holdingTimeMinutes;
                                        totalPnL += pnl;
                                        validTrades++;
                                        
                                        tradeEfficiencies.push({
                                            pnlPerMinute: pnlPerMinute,
                                            holdingTimeMinutes: holdingTimeMinutes,
                                            pnl: pnl,
                                            asset: trade.asset || 'Unknown'
                                        });
                                    }
                                } else {
                                    // Handle zero holding time trades (same-day trades)
                                    const pnl = calculateNetPnl(trade);
                                    if (isFinite(pnl)) {
                                        // For same-day trades, assign 0 efficiency or skip
                                        // We'll skip them to avoid division by zero
                                        console.log('Skipping trade with zero holding time:', trade.id);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        console.warn('Error processing trade for efficiency calculation:', trade.id, error);
                    }
                });

                console.log('Valid trades for efficiency:', validTrades);
                console.log('Total holding time (minutes):', totalHoldingTime);
                console.log('Total P&L:', totalPnL);

                if (validTrades === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Valid Data', 
                        recommendation: 'Need trades with valid holding periods',
                        efficiencyData: {}
                    };
                }

                const avgEfficiency = totalEfficiency / validTrades;
                const avgHoldingTime = totalHoldingTime / validTrades;
                const avgPnL = totalPnL / validTrades;

                // Determine interpretation and recommendation
                let interpretation = '';
                let recommendation = '';
                
                if (avgEfficiency > 10) {
                    interpretation = `Excellent efficiency - ₹${avgEfficiency.toFixed(2)} per minute`;
                    recommendation = 'Outstanding time efficiency - maximize your trading time';
                } else if (avgEfficiency > 5) {
                    interpretation = `Good efficiency - ₹${avgEfficiency.toFixed(2)} per minute`;
                    recommendation = 'Good time efficiency - consider optimizing further';
                } else if (avgEfficiency > 1) {
                    interpretation = `Moderate efficiency - ₹${avgEfficiency.toFixed(2)} per minute`;
                    recommendation = 'Consider longer holding periods or higher frequency strategies';
                } else if (avgEfficiency > 0) {
                    interpretation = `Low efficiency - ₹${avgEfficiency.toFixed(2)} per minute`;
                    recommendation = 'Focus on improving trade selection and timing';
                } else {
                    interpretation = `Negative efficiency - ₹${avgEfficiency.toFixed(2)} per minute`;
                    recommendation = 'Review trading strategy - losses per minute indicate issues';
                }

                // Add additional insights
                const bestTrade = tradeEfficiencies.reduce((best, current) => 
                    current.pnlPerMinute > best.pnlPerMinute ? current : best, tradeEfficiencies[0]);
                const worstTrade = tradeEfficiencies.reduce((worst, current) => 
                    current.pnlPerMinute < worst.pnlPerMinute ? current : worst, tradeEfficiencies[0]);

                if (bestTrade && worstTrade) {
                    interpretation += `. Best: ${bestTrade.asset} (₹${bestTrade.pnlPerMinute.toFixed(2)}/min), Worst: ${worstTrade.asset} (₹${worstTrade.pnlPerMinute.toFixed(2)}/min)`;
                }

                return {
                    value: avgEfficiency,
                    interpretation: interpretation,
                    recommendation: recommendation,
                    efficiencyData: {
                        avgEfficiency: avgEfficiency,
                        avgHoldingTime: avgHoldingTime,
                        avgPnL: avgPnL,
                        validTrades: validTrades,
                        totalHoldingTime: totalHoldingTime,
                        tradeEfficiencies: tradeEfficiencies
                    }
                };

            } catch (error) {
                console.error('Error calculating trade efficiency:', error);
                return { 
                    value: 0, 
                    interpretation: 'Error', 
                    recommendation: 'Analysis unavailable',
                    efficiencyData: {}
                };
            }
        };

        // Calculate Capital Utilization Ratio
        const calculateCapitalUtilization = (closedTrades, currentAccountValue) => {
            try {
                console.log('calculateCapitalUtilization called with trades:', closedTrades?.length || 0, 'account value:', currentAccountValue);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Data', 
                        recommendation: 'Add closed trades to see capital utilization',
                        utilizationData: {}
                    };
                }

                if (!currentAccountValue || currentAccountValue <= 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Account Value', 
                        recommendation: 'Account value not available for calculation',
                        utilizationData: {}
                    };
                }

                let totalDeployedCapital = 0;
                let validTrades = 0;
                const capitalUtilizations = [];

                closedTrades.forEach(trade => {
                    try {
                        if (trade.entry_price && trade.quantity) {
                            const entryPrice = parseFloat(trade.entry_price);
                            const quantity = parseFloat(trade.quantity);
                            
                            if (isFinite(entryPrice) && isFinite(quantity) && entryPrice > 0 && quantity > 0) {
                                const deployedCapital = entryPrice * quantity;
                                totalDeployedCapital += deployedCapital;
                                validTrades++;
                                
                                capitalUtilizations.push({
                                    deployedCapital: deployedCapital,
                                    entryPrice: entryPrice,
                                    quantity: quantity,
                                    asset: trade.asset || 'Unknown',
                                    utilizationPercentage: (deployedCapital / currentAccountValue) * 100
                                });
                            }
                        }
                    } catch (error) {
                        console.warn('Error processing trade for capital utilization calculation:', trade.id, error);
                    }
                });

                console.log('Valid trades for capital utilization:', validTrades);
                console.log('Total deployed capital:', totalDeployedCapital);
                console.log('Current account value:', currentAccountValue);

                if (validTrades === 0) {
                    return { 
                        value: 0, 
                        interpretation: 'No Valid Data', 
                        recommendation: 'Need trades with valid entry prices and quantities',
                        utilizationData: {}
                    };
                }

                const avgDeployedCapital = totalDeployedCapital / validTrades;
                const utilizationRatio = (avgDeployedCapital / currentAccountValue) * 100;

                // Determine interpretation and recommendation
                let interpretation = '';
                let recommendation = '';
                
                if (utilizationRatio > 20) {
                    interpretation = `High capital utilization - ${utilizationRatio.toFixed(1)}% per trade`;
                    recommendation = 'High risk exposure - consider position sizing';
                } else if (utilizationRatio > 10) {
                    interpretation = `Moderate capital utilization - ${utilizationRatio.toFixed(1)}% per trade`;
                    recommendation = 'Balanced approach - monitor risk levels';
                } else if (utilizationRatio > 5) {
                    interpretation = `Conservative capital utilization - ${utilizationRatio.toFixed(1)}% per trade`;
                    recommendation = 'Conservative approach - consider larger positions';
                } else if (utilizationRatio > 0) {
                    interpretation = `Very conservative capital utilization - ${utilizationRatio.toFixed(1)}% per trade`;
                    recommendation = 'Very conservative - consider increasing position sizes';
                } else {
                    interpretation = `No capital utilization - ${utilizationRatio.toFixed(1)}% per trade`;
                    recommendation = 'No capital deployed - start trading to see utilization';
                }

                // Add additional insights
                const maxUtilization = capitalUtilizations.length > 0 ? Math.max(...capitalUtilizations.map(c => c.utilizationPercentage)) : 0;
                const minUtilization = capitalUtilizations.length > 0 ? Math.min(...capitalUtilizations.map(c => c.utilizationPercentage)) : 0;
                const avgUtilization = capitalUtilizations.length > 0 ? capitalUtilizations.reduce((sum, c) => sum + c.utilizationPercentage, 0) / capitalUtilizations.length : 0;

                if (maxUtilization > 0) {
                    interpretation += `. Range: ${minUtilization.toFixed(1)}% - ${maxUtilization.toFixed(1)}%`;
                }

                return {
                    value: utilizationRatio,
                    interpretation: interpretation,
                    recommendation: recommendation,
                    utilizationData: {
                        avgDeployedCapital: avgDeployedCapital,
                        totalDeployedCapital: totalDeployedCapital,
                        validTrades: validTrades,
                        currentAccountValue: currentAccountValue,
                        maxUtilization: maxUtilization,
                        minUtilization: minUtilization,
                        avgUtilization: avgUtilization,
                        capitalUtilizations: capitalUtilizations
                    }
                };

            } catch (error) {
                console.error('Error calculating capital utilization:', error);
                return { 
                    value: 0, 
                    interpretation: 'Error', 
                    recommendation: 'Analysis unavailable',
                    utilizationData: {}
                };
            }
        };

        // Calculate Recent Win Rate (Predictive Win Probability)
        const calculateRecentWinRate = (closedTrades, lookbackCount = 20) => {
            try {
                console.log('calculateRecentWinRate called with trades:', closedTrades?.length || 0, 'lookback:', lookbackCount);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        winRate: 0, 
                        interpretation: 'No Data',
                        recentTradesCount: 0,
                        wins: 0
                    };
                }

                // Sort trades by exit_date (most recent first)
                const sortedTrades = closedTrades
                    .filter(trade => trade.exit_date) // Ensure exit_date exists
                    .sort((a, b) => new Date(b.exit_date) - new Date(a.exit_date));

                if (sortedTrades.length === 0) {
                    return { 
                        winRate: 0, 
                        interpretation: 'No Valid Data',
                        recentTradesCount: 0,
                        wins: 0
                    };
                }

                // Take the last lookbackCount trades (most recent)
                const recentTrades = sortedTrades.slice(0, Math.min(lookbackCount, sortedTrades.length));
                let wins = 0;

                recentTrades.forEach(trade => {
                    try {
                        const pnl = calculateNetPnl(trade);
                        if (isFinite(pnl) && pnl > 0) {
                            wins++;
                        }
                    } catch (error) {
                        console.warn('Error calculating P&L for recent win rate:', trade.id, error);
                    }
                });

                const winRate = recentTrades.length > 0 ? (wins / recentTrades.length) * 100 : 0;
                const interpretation = `Based on your last ${recentTrades.length} trades`;

                console.log('Recent win rate calculation:', {
                    totalTrades: closedTrades.length,
                    recentTrades: recentTrades.length,
                    wins: wins,
                    winRate: winRate
                });

                return {
                    winRate: winRate,
                    interpretation: interpretation,
                    recentTradesCount: recentTrades.length,
                    wins: wins
                };

            } catch (error) {
                console.error('Error calculating recent win rate:', error);
                return { 
                    winRate: 0, 
                    interpretation: 'Error',
                    recentTradesCount: 0,
                    wins: 0
                };
            }
        };

        // Calculate Trading Discipline Score
        const calculateDisciplineScore = (closedTrades, metrics) => {
            try {
                console.log('calculateDisciplineScore called with trades:', closedTrades?.length || 0, 'metrics:', metrics);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        score: 0, 
                        interpretation: 'No Data',
                        stopLossUsage: 0,
                        mistakeFreePercentage: 0,
                        totalTrades: 0,
                        mistakeFreeTrades: 0
                    };
                }

                if (!metrics) {
                    return { 
                        score: 0, 
                        interpretation: 'No Metrics',
                        stopLossUsage: 0,
                        mistakeFreePercentage: 0,
                        totalTrades: 0,
                        mistakeFreeTrades: 0
                    };
                }

                // Get stop loss usage from existing metrics
                const stopLossUsage = metrics.stopLossUsage || 0;
                
                // Calculate mistake-free trades percentage
                const totalTrades = closedTrades.length;
                const mistakeFreeTrades = closedTrades.filter(trade => {
                    // Check if trade has no mistakes or empty mistakes array
                    return !trade.mistakes || trade.mistakes.length === 0;
                }).length;
                
                const mistakeFreePercentage = totalTrades > 0 ? 
                    (mistakeFreeTrades / totalTrades) * 100 : 0;
                
                // Weighted average: 50% stop loss usage + 50% mistake-free percentage
                const disciplineScore = (stopLossUsage * 0.5) + (mistakeFreePercentage * 0.5);
                
                // Determine interpretation based on score
                let interpretation = '';
                if (disciplineScore >= 80) {
                    interpretation = 'Excellent discipline - consistent risk management';
                } else if (disciplineScore >= 65) {
                    interpretation = 'Good discipline - minor improvements needed';
                } else if (disciplineScore >= 50) {
                    interpretation = 'Moderate discipline - focus on consistency';
                } else if (disciplineScore >= 30) {
                    interpretation = 'Needs improvement - strengthen risk management';
                } else {
                    interpretation = 'Poor discipline - major improvements required';
                }

                console.log('Discipline score calculation:', {
                    totalTrades: totalTrades,
                    mistakeFreeTrades: mistakeFreeTrades,
                    mistakeFreePercentage: mistakeFreePercentage,
                    stopLossUsage: stopLossUsage,
                    disciplineScore: disciplineScore
                });

                return {
                    score: disciplineScore,
                    interpretation: interpretation,
                    stopLossUsage: stopLossUsage,
                    mistakeFreePercentage: mistakeFreePercentage,
                    totalTrades: totalTrades,
                    mistakeFreeTrades: mistakeFreeTrades
                };

            } catch (error) {
                console.error('Error calculating discipline score:', error);
                return { 
                    score: 0, 
                    interpretation: 'Error',
                    stopLossUsage: 0,
                    mistakeFreePercentage: 0,
                    totalTrades: 0,
                    mistakeFreeTrades: 0
                };
            }
        };

        // Calculate Stress Index (Performance Under Volatility)
        const calculateStressIndex = (closedTrades, startingBalance) => {
            try {
                console.log('calculateStressIndex called with trades:', closedTrades?.length || 0);
                
                if (!closedTrades || closedTrades.length === 0) {
                    return { 
                        highVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        lowVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        interpretation: 'No Data',
                        stressIndex: 0
                    };
                }

                // Generate daily P&L time-series (reuse logic from Consistency Index)
                const dailyPnL = {};
                
                closedTrades.forEach(trade => {
                    try {
                        const pnl = calculateNetPnl(trade);
                        if (isFinite(pnl)) {
                            const exitDate = new Date(trade.exit_date);
                            const dateKey = exitDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                            
                            if (!dailyPnL[dateKey]) {
                                dailyPnL[dateKey] = 0;
                            }
                            dailyPnL[dateKey] += pnl;
                        }
                    } catch (error) {
                        console.warn('Error calculating P&L for stress index:', trade.id, error);
                    }
                });

                // Convert to array of daily P&L values
                const dailyPnLValues = Object.values(dailyPnL);
                
                if (dailyPnLValues.length === 0) {
                    return { 
                        highVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        lowVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        interpretation: 'No Data',
                        stressIndex: 0
                    };
                }

                // Calculate average daily P&L and standard deviation
                const avgDailyPnL = dailyPnLValues.reduce((sum, pnl) => sum + pnl, 0) / dailyPnLValues.length;
                const variance = dailyPnLValues.reduce((sum, pnl) => sum + Math.pow(pnl - avgDailyPnL, 2), 0) / dailyPnLValues.length;
                const standardDeviation = Math.sqrt(variance);
                
                // Handle edge case where standard deviation is zero (all days have same P&L)
                if (standardDeviation === 0) {
                    return { 
                        highVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        lowVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                        interpretation: 'No volatility detected - all trading days had similar P&L',
                        stressIndex: 0
                    };
                }

                // Define volatility thresholds based on standard deviation
                const highVolatilityThreshold = 1.5 * standardDeviation;
                const lowVolatilityThreshold = 0.5 * standardDeviation;

                // Group trades by volatility level
                const highVolTrades = [];
                const lowVolTrades = [];
                const neutralTrades = [];

                closedTrades.forEach(trade => {
                    try {
                        const pnl = calculateNetPnl(trade);
                        if (isFinite(pnl)) {
                            const exitDate = new Date(trade.exit_date);
                            const dateKey = exitDate.toISOString().split('T')[0];
                            const dailyPnLValue = dailyPnL[dateKey] || 0;
                            
                            // Calculate how far this day's P&L is from the average (volatility measure)
                            const deviationFromMean = Math.abs(dailyPnLValue - avgDailyPnL);
                            
                            // Determine volatility level based on deviation from mean
                            if (deviationFromMean > highVolatilityThreshold) {
                                highVolTrades.push({ ...trade, dailyPnL: dailyPnLValue, deviation: deviationFromMean });
                            } else if (deviationFromMean < lowVolatilityThreshold) {
                                lowVolTrades.push({ ...trade, dailyPnL: dailyPnLValue, deviation: deviationFromMean });
                            } else {
                                neutralTrades.push({ ...trade, dailyPnL: dailyPnLValue, deviation: deviationFromMean });
                            }
                        }
                    } catch (error) {
                        console.warn('Error processing trade for stress index:', trade.id, error);
                    }
                });

                // Calculate performance metrics for each group
                const calculateGroupPerformance = (trades) => {
                    if (trades.length === 0) {
                        return { avgPnL: 0, winRate: 0, tradeCount: 0 };
                    }

                    let totalPnL = 0;
                    let wins = 0;

                    trades.forEach(trade => {
                        const pnl = calculateNetPnl(trade);
                        if (isFinite(pnl)) {
                            totalPnL += pnl;
                            if (pnl > 0) wins++;
                        }
                    });

                    const avgPnL = totalPnL / trades.length;
                    const winRate = (wins / trades.length) * 100;

                    return { avgPnL, winRate, tradeCount: trades.length };
                };

                const highVolPerformance = calculateGroupPerformance(highVolTrades);
                const lowVolPerformance = calculateGroupPerformance(lowVolTrades);

                // Calculate stress index (performance difference)
                let stressIndex = 0;
                let interpretation = '';

                if (highVolPerformance.tradeCount > 0 && lowVolPerformance.tradeCount > 0) {
                    // Calculate performance difference (simplified and more accurate)
                    const highVolScore = highVolPerformance.avgPnL * (highVolPerformance.winRate / 100);
                    const lowVolScore = lowVolPerformance.avgPnL * (lowVolPerformance.winRate / 100);
                    
                    stressIndex = highVolScore - lowVolScore;
                    
                    // Generate interpretation based on performance difference
                    const performanceDiffPercent = lowVolPerformance.avgPnL !== 0 ? 
                        ((highVolPerformance.avgPnL - lowVolPerformance.avgPnL) / Math.abs(lowVolPerformance.avgPnL)) * 100 : 0;
                    
                    if (performanceDiffPercent > 50) {
                        interpretation = 'You thrive under pressure - maintain current approach';
                    } else if (performanceDiffPercent > 10) {
                        interpretation = 'You perform well under stress - good emotional control';
                    } else if (performanceDiffPercent > -10) {
                        interpretation = 'You perform similarly under stress and calm conditions';
                    } else if (performanceDiffPercent > -50) {
                        interpretation = 'You perform worse under stress - focus on emotional control';
                    } else {
                        interpretation = 'You struggle significantly under stress - consider stress management techniques';
                    }
                } else {
                    interpretation = 'Insufficient data for stress analysis';
                }

                console.log('Stress index calculation:', {
                    totalTrades: closedTrades.length,
                    dailyPnLValues: dailyPnLValues.length,
                    avgDailyPnL: avgDailyPnL,
                    standardDeviation: standardDeviation,
                    highVolatilityThreshold: highVolatilityThreshold,
                    lowVolatilityThreshold: lowVolatilityThreshold,
                    highVolTrades: highVolTrades.length,
                    lowVolTrades: lowVolTrades.length,
                    neutralTrades: neutralTrades.length,
                    highVolPerformance,
                    lowVolPerformance,
                    stressIndex,
                    interpretation,
                    performanceDiffPercent: lowVolPerformance.avgPnL !== 0 ? 
                        ((highVolPerformance.avgPnL - lowVolPerformance.avgPnL) / Math.abs(lowVolPerformance.avgPnL)) * 100 : 0
                });

                return {
                    highVolatility: highVolPerformance,
                    lowVolatility: lowVolPerformance,
                    interpretation: interpretation,
                    stressIndex: stressIndex,
                    totalTrades: closedTrades.length,
                    highVolTrades: highVolTrades.length,
                    lowVolTrades: lowVolTrades.length
                };

            } catch (error) {
                console.error('Error calculating stress index:', error);
                return { 
                    highVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                    lowVolatility: { avgPnL: 0, winRate: 0, tradeCount: 0 },
                    interpretation: 'Error',
                    stressIndex: 0
                };
            }
        };

        // Advanced Trading Metrics Calculation Functions
        
        // Calculate Sharpe Ratio (Risk-adjusted return)
        const calculateSharpeRatio = (trades) => {
            try {
                if (!trades || trades.length === 0) return { value: 0, status: 'no-data' };
                
                const returns = trades.map(trade => {
                    const pnl = calculateNetPnl(trade);
                    return pnl;
                }).filter(r => isFinite(r));
                
                if (returns.length === 0) return { value: 0, status: 'no-returns' };
                
                const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                const variance = returns.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / returns.length;
                const stdDev = Math.sqrt(variance);
                
                if (stdDev === 0) return { value: 0, status: 'no-volatility' };
                
                // Annualize the Sharpe ratio (assuming daily returns)
                const sharpeRatio = (avgReturn / stdDev) * Math.sqrt(252); // 252 trading days per year
                
                return { 
                    value: sharpeRatio, 
                    status: sharpeRatio > 1 ? 'good' : sharpeRatio > 0.5 ? 'moderate' : 'needs-improvement' 
                };
            } catch (error) {
                console.warn('Error calculating Sharpe Ratio:', error);
                return { value: 0, status: 'error' };
            }
        };

        // Calculate Sortino Ratio (Downside risk-adjusted return)
        const calculateSortinoRatio = (trades) => {
            try {
                if (!trades || trades.length === 0) return { value: 0, status: 'no-data' };
                
                const returns = trades.map(trade => {
                    const pnl = calculateNetPnl(trade);
                    return pnl;
                }).filter(r => isFinite(r));
                
                if (returns.length === 0) return { value: 0, status: 'no-returns' };
                
                const avgReturn = returns.reduce((sum, r) => sum + r, 0) / returns.length;
                const negativeReturns = returns.filter(r => r < 0);
                
                if (negativeReturns.length === 0) return { value: 0, status: 'no-downside' };
                
                const downsideVariance = negativeReturns.reduce((sum, r) => sum + Math.pow(r, 2), 0) / negativeReturns.length;
                const downsideDeviation = Math.sqrt(downsideVariance);
                
                if (downsideDeviation === 0) return { value: 0, status: 'no-downside-volatility' };
                
                // Annualize the Sortino ratio
                const sortinoRatio = (avgReturn / downsideDeviation) * Math.sqrt(252);
                
                return { 
                    value: sortinoRatio, 
                    status: sortinoRatio > 1 ? 'good' : sortinoRatio > 0.5 ? 'moderate' : 'needs-improvement' 
                };
            } catch (error) {
                console.warn('Error calculating Sortino Ratio:', error);
                return { value: 0, status: 'error' };
            }
        };

        // Calculate Average MAE (Maximum Adverse Excursion) for winning trades
        const calculateAverageMAE = (trades) => {
            try {
                if (!trades || trades.length === 0) return { value: 0, status: 'no-data' };
                
                const winningTrades = trades.filter(trade => {
                    const pnl = calculateNetPnl(trade);
                    return isFinite(pnl) && pnl > 0;
                });
                
                if (winningTrades.length === 0) return { value: 0, status: 'no-winners' };
                
                // Calculate MAE using a more realistic approach
                // MAE represents the maximum drawdown during a winning trade
                const maeValues = winningTrades.map(trade => {
                    const entryPrice = parseFloat(trade.entry_price) || 0;
                    const exitPrice = parseFloat(trade.exit_price) || 0;
                    const quantity = parseFloat(trade.quantity) || 0;
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    
                    if (entryPrice === 0 || exitPrice === 0 || quantity === 0) return 0;
                    
                    // Calculate the maximum adverse movement
                    // For MAE, we estimate based on the trade's volatility and duration
                    const priceRange = Math.abs(exitPrice - entryPrice);
                    const volatility = priceRange / entryPrice; // Price volatility percentage
                    
                    // Estimate MAE as a percentage of the trade's volatility
                    // This is a simplified approach - real MAE requires intraday data
                    const estimatedMAE = priceRange * 0.3; // Assume 30% of price movement was adverse
                    
                    if (isShort) {
                        // For short trades, adverse movement is price going up
                        return estimatedMAE * quantity;
                    } else {
                        // For long trades, adverse movement is price going down
                        return estimatedMAE * quantity;
                    }
                }).filter(mae => isFinite(mae) && mae > 0);
                
                if (maeValues.length === 0) return { value: 0, status: 'no-mae-data' };
                
                const avgMAE = maeValues.reduce((sum, mae) => sum + mae, 0) / maeValues.length;
                
                return { 
                    value: -Math.abs(avgMAE), // Negative value to show "pain"
                    status: avgMAE < 1000 ? 'good' : avgMAE < 5000 ? 'moderate' : 'high-pain' 
                };
            } catch (error) {
                console.warn('Error calculating Average MAE:', error);
                return { value: 0, status: 'error' };
            }
        };

        // Calculate Average MFE (Maximum Favorable Excursion) for losing trades
        const calculateAverageMFE = (trades) => {
            try {
                if (!trades || trades.length === 0) return { value: 0, status: 'no-data' };
                
                const losingTrades = trades.filter(trade => {
                    const pnl = calculateNetPnl(trade);
                    return isFinite(pnl) && pnl < 0;
                });
                
                if (losingTrades.length === 0) return { value: 0, status: 'no-losers' };
                
                // Calculate MFE using a more realistic approach
                // MFE represents the maximum profit during a losing trade
                const mfeValues = losingTrades.map(trade => {
                    const entryPrice = parseFloat(trade.entry_price) || 0;
                    const exitPrice = parseFloat(trade.exit_price) || 0;
                    const quantity = parseFloat(trade.quantity) || 0;
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    
                    if (entryPrice === 0 || exitPrice === 0 || quantity === 0) return 0;
                    
                    // Calculate the maximum favorable movement
                    // For MFE, we estimate based on the trade's volatility and duration
                    const priceRange = Math.abs(exitPrice - entryPrice);
                    const volatility = priceRange / entryPrice; // Price volatility percentage
                    
                    // Estimate MFE as a percentage of the trade's volatility
                    // This is a simplified approach - real MFE requires intraday data
                    const estimatedMFE = priceRange * 0.4; // Assume 40% of price movement was favorable
                    
                    if (isShort) {
                        // For short trades, favorable movement is price going down
                        return estimatedMFE * quantity;
                    } else {
                        // For long trades, favorable movement is price going up
                        return estimatedMFE * quantity;
                    }
                }).filter(mfe => isFinite(mfe) && mfe > 0);
                
                if (mfeValues.length === 0) return { value: 0, status: 'no-mfe-data' };
                
                const avgMFE = mfeValues.reduce((sum, mfe) => sum + mfe, 0) / mfeValues.length;
                
                return { 
                    value: avgMFE,
                    status: avgMFE > 2000 ? 'high-mfe' : avgMFE > 1000 ? 'moderate-mfe' : 'low-mfe' 
                };
            } catch (error) {
                console.warn('Error calculating Average MFE:', error);
                return { value: 0, status: 'error' };
            }
        };

        // Calculate Cost Analysis (Impact of Charges)
        const calculateCostAnalysis = (trades) => {
            try {
                if (!trades || trades.length === 0) return { 
                    grossPnl: 0, 
                    totalCharges: 0, 
                    netPnl: 0, 
                    chargesPercentage: 0 
                };
                
                let grossPnl = 0;
                let totalCharges = 0;
                
                trades.forEach(trade => {
                    // Calculate GROSS P&L (before any charges)
                    const entryPrice = parseFloat(trade.entry_price) || 0;
                    const exitPrice = parseFloat(trade.exit_price) || 0;
                    const quantity = parseFloat(trade.quantity) || 0;
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    
                    let grossPnlTrade = 0;
                    if (entryPrice > 0 && exitPrice > 0 && quantity > 0) {
                        if (isShort) {
                            // Short trade: profit when entry > exit
                            grossPnlTrade = (entryPrice - exitPrice) * quantity;
                        } else {
                            // Long trade: profit when exit > entry
                            grossPnlTrade = (exitPrice - entryPrice) * quantity;
                        }
                    }
                    grossPnl += grossPnlTrade;
                    
                    // Calculate total charges
                    const brokerage = parseFloat(trade.brokerage || 0);
                    const otherFees = parseFloat(trade.other_fees || 0);
                    const charges = brokerage + otherFees;
                    totalCharges += charges;
                });
                
                // Calculate net P&L (after charges)
                const netPnl = grossPnl - totalCharges;
                
                // Calculate charges as percentage of gross profit
                const chargesPercentage = grossPnl > 0 ? (totalCharges / grossPnl) * 100 : 0;
                
                // Debug logging
                console.log('Cost Analysis Calculation:', {
                    totalTrades: trades.length,
                    grossPnl: grossPnl,
                    totalCharges: totalCharges,
                    netPnl: netPnl,
                    chargesPercentage: chargesPercentage
                });
                
                return {
                    grossPnl,
                    totalCharges,
                    netPnl,
                    chargesPercentage
                };
            } catch (error) {
                console.warn('Error calculating Cost Analysis:', error);
                return { 
                    grossPnl: 0, 
                    totalCharges: 0, 
                    netPnl: 0, 
                    chargesPercentage: 0 
                };
            }
        };

        // Calculate Financial Impact of Mistakes
        const calculateMistakeImpact = (trades) => {
            try {
                if (!trades || trades.length === 0) return [];
                
                const mistakeMap = new Map();
                
                trades.forEach(trade => {
                    const mistakes = trade.mistakes || [];
                    const pnl = calculateNetPnl(trade);
                    
                    mistakes.forEach(mistake => {
                        if (!mistakeMap.has(mistake)) {
                            mistakeMap.set(mistake, { totalImpact: 0, count: 0 });
                        }
                        mistakeMap.get(mistake).totalImpact += pnl;
                        mistakeMap.get(mistake).count += 1;
                    });
                });
                
                // Convert to array and sort by impact (most costly first)
                return Array.from(mistakeMap.entries())
                    .map(([mistake, data]) => ({
                        mistake,
                        totalImpact: data.totalImpact,
                        count: data.count
                    }))
                    .sort((a, b) => a.totalImpact - b.totalImpact); // Most negative first
            } catch (error) {
                console.warn('Error calculating Mistake Impact:', error);
                return [];
            }
        };

        // Calculate Detailed Performance by Day of the Week
        const calculateDayPerformance = (trades) => {
            try {
                if (!trades || trades.length === 0) return [];
                
                const dayMap = new Map();
                const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                
                // Initialize all days
                days.forEach(day => {
                    dayMap.set(day, {
                        totalPnl: 0,
                        totalTrades: 0,
                        winningTrades: 0,
                        losingTrades: 0
                    });
                });
                
                trades.forEach(trade => {
                    try {
                        const tradeDate = new Date(trade.entry_date);
                        const dayName = tradeDate.toLocaleDateString('en-US', { weekday: 'long' });
                        
                        if (dayMap.has(dayName)) {
                            const pnl = calculateNetPnl(trade);
                            const dayData = dayMap.get(dayName);
                            
                            dayData.totalPnl += pnl;
                            dayData.totalTrades += 1;
                            
                            if (pnl > 0) dayData.winningTrades += 1;
                            else if (pnl < 0) dayData.losingTrades += 1;
                        }
                    } catch (dateError) {
                        console.warn('Error processing trade date:', trade.entry_date, dateError);
                    }
                });
                
                // Calculate metrics for each day
                return days.map(day => {
                    const data = dayMap.get(day);
                    const winRate = data.totalTrades > 0 ? (data.winningTrades / data.totalTrades) * 100 : 0;
                    const avgPnl = data.totalTrades > 0 ? data.totalPnl / data.totalTrades : 0;
                    
                    return {
                        day,
                        totalPnl: data.totalPnl,
                        winRate: winRate,
                        avgPnl: avgPnl,
                        totalTrades: data.totalTrades
                    };
                });
            } catch (error) {
                console.warn('Error calculating Day Performance:', error);
                return [];
            }
        };

        // Calculate Trade Duration Analysis
        const calculateTradeDuration = (trades) => {
            try {
                if (!trades || trades.length === 0) return [];
                
                const durationBuckets = [
                    { name: 'Under 5 mins', min: 0, max: 5 },
                    { name: '5-30 mins', min: 5, max: 30 },
                    { name: '30 mins - 1 hour', min: 30, max: 60 },
                    { name: '1-4 hours', min: 60, max: 240 },
                    { name: '4+ hours', min: 240, max: Infinity }
                ];
                
                const bucketMap = new Map();
                
                // Initialize all buckets
                durationBuckets.forEach(bucket => {
                    bucketMap.set(bucket.name, {
                        totalPnl: 0,
                        totalTrades: 0,
                        winningTrades: 0,
                        losingTrades: 0
                    });
                });
                
                trades.forEach(trade => {
                    try {
                        // Calculate trade duration in minutes
                        const entryDate = new Date(trade.entry_date + ' ' + (trade.entry_time || '00:00'));
                        const exitDate = new Date(trade.exit_date + ' ' + (trade.exit_time || '00:00'));
                        const durationMinutes = (exitDate - entryDate) / (1000 * 60);
                        
                        const pnl = calculateNetPnl(trade);
                        
                        // Find the appropriate bucket
                        const bucket = durationBuckets.find(b => 
                            durationMinutes >= b.min && durationMinutes < b.max
                        );
                        
                        if (bucket) {
                            const bucketData = bucketMap.get(bucket.name);
                            bucketData.totalPnl += pnl;
                            bucketData.totalTrades += 1;
                            
                            if (pnl > 0) bucketData.winningTrades += 1;
                            else if (pnl < 0) bucketData.losingTrades += 1;
                        }
                    } catch (dateError) {
                        console.warn('Error processing trade duration:', trade.id, dateError);
                    }
                });
                
                // Calculate metrics for each bucket
                return durationBuckets.map(bucket => {
                    const data = bucketMap.get(bucket.name);
                    const winRate = data.totalTrades > 0 ? (data.winningTrades / data.totalTrades) * 100 : 0;
                    const avgPnl = data.totalTrades > 0 ? data.totalPnl / data.totalTrades : 0;
                    
                    return {
                        duration: bucket.name,
                        totalPnl: data.totalPnl,
                        winRate: winRate,
                        avgPnl: avgPnl,
                        totalTrades: data.totalTrades
                    };
                });
            } catch (error) {
                console.warn('Error calculating Trade Duration:', error);
                return [];
            }
        };

        // Calculate R-Value Analysis
        const calculateRValue = (trades) => {
            try {
                if (!trades || trades.length === 0) return { 
                    avgRValue: 0, 
                    bestRValue: 0, 
                    worstRValue: 0, 
                    totalRValue: 0,
                    winningRValue: 0,
                    losingRValue: 0,
                    rValueDistribution: []
                };
                
                const rValues = [];
                const winningRValues = [];
                const losingRValues = [];
                let totalRValue = 0;
                let bestRValue = -Infinity;
                let worstRValue = Infinity;
                
                trades.forEach(trade => {
                    const pnl = calculateNetPnl(trade);
                    
                    // Calculate 1R (initial risk) from stop loss
                    const entryPrice = parseFloat(trade.entry_price) || 0;
                    const stopLoss = parseFloat(trade.stop_loss) || 0;
                    const quantity = parseFloat(trade.quantity) || 0;
                    
                    if (entryPrice > 0 && stopLoss > 0 && quantity > 0) {
                        const stopLossDistance = Math.abs(entryPrice - stopLoss);
                        const oneR = stopLossDistance * quantity;
                        
                        if (oneR > 0) {
                            const rValue = pnl / oneR;
                            rValues.push(rValue);
                            totalRValue += rValue;
                            
                            if (rValue > bestRValue) bestRValue = rValue;
                            if (rValue < worstRValue) worstRValue = rValue;
                            
                            if (rValue > 0) winningRValues.push(rValue);
                            else if (rValue < 0) losingRValues.push(rValue);
                        }
                    }
                });
                
                const avgRValue = rValues.length > 0 ? totalRValue / rValues.length : 0;
                const avgWinningRValue = winningRValues.length > 0 ? 
                    winningRValues.reduce((sum, r) => sum + r, 0) / winningRValues.length : 0;
                const avgLosingRValue = losingRValues.length > 0 ? 
                    losingRValues.reduce((sum, r) => sum + r, 0) / losingRValues.length : 0;
                
                return {
                    avgRValue,
                    bestRValue: bestRValue === -Infinity ? 0 : bestRValue,
                    worstRValue: worstRValue === Infinity ? 0 : worstRValue,
                    totalRValue,
                    winningRValue: avgWinningRValue,
                    losingRValue: avgLosingRValue,
                    rValueDistribution: rValues
                };
            } catch (error) {
                console.warn('Error calculating R-Value:', error);
                return { 
                    avgRValue: 0, 
                    bestRValue: 0, 
                    worstRValue: 0, 
                    totalRValue: 0,
                    winningRValue: 0,
                    losingRValue: 0,
                    rValueDistribution: []
                };
            }
        };

        // Calculate P&L by Quantity Traded Tier
            const calculateQuantityTier = (trades) => {
                try {
                    if (!trades || trades.length === 0) return [];
                    
                    const quantityTiers = [
                        { name: '1-100 shares', min: 1, max: 100 },
                        { name: '101-500 shares', min: 101, max: 500 },
                        { name: '501-1000 shares', min: 501, max: 1000 },
                        { name: '1001-1500 shares', min: 1001, max: 1500 },
                        { name: '1501-2000 shares', min: 1501, max: 2000 },
                        { name: '>2000 shares', min: 2001, max: Infinity }
                    ];
                
                const tierMap = new Map();
                
                // Initialize all tiers
                quantityTiers.forEach(tier => {
                    tierMap.set(tier.name, {
                        totalPnl: 0,
                        totalTrades: 0,
                        winningTrades: 0,
                        losingTrades: 0
                    });
                });
                
                trades.forEach(trade => {
                    const quantity = parseFloat(trade.quantity) || 0;
                    const pnl = calculateNetPnl(trade);
                    
                    // Find the appropriate tier
                    const tier = quantityTiers.find(t => 
                        quantity >= t.min && quantity <= t.max
                    );
                    
                    if (tier) {
                        const tierData = tierMap.get(tier.name);
                        tierData.totalPnl += pnl;
                        tierData.totalTrades += 1;
                        
                        if (pnl > 0) tierData.winningTrades += 1;
                        else if (pnl < 0) tierData.losingTrades += 1;
                    }
                });
                
                // Calculate metrics for each tier
                return quantityTiers.map(tier => {
                    const data = tierMap.get(tier.name);
                    const winRate = data.totalTrades > 0 ? (data.winningTrades / data.totalTrades) * 100 : 0;
                    const avgPnl = data.totalTrades > 0 ? data.totalPnl / data.totalTrades : 0;
                    
                    return {
                        tier: tier.name,
                        totalPnl: data.totalPnl,
                        winRate: winRate,
                        avgPnl: avgPnl,
                        totalTrades: data.totalTrades
                    };
                });
            } catch (error) {
                console.warn('Error calculating Quantity Tier:', error);
                return [];
            }
        };

        // Function to calculate P&L for partial exit trades using stored partial exit data (sync version)
        const calculatePartialExitPnlSync = (trade) => {
            try {
                // For sync version, we'll use a fallback calculation
                // The async version will be used when we have cached data
                const exitQty = trade.exit_quantity || trade.quantity;
                const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                const grossPnl = (parseFloat(trade.exit_price) - parseFloat(trade.entry_price)) * exitQty * (isShort ? -1 : 1);
                const brokerage = parseFloat(trade.brokerage) || 0;
                const otherFees = parseFloat(trade.other_fees) || 0;
                return grossPnl - brokerage - otherFees;
            } catch (error) {
                console.warn('Error in calculatePartialExitPnlSync:', error);
                return 0;
            }
        };

        // Function to calculate P&L for partial exit trades using stored partial exit data (async version)
        const calculatePartialExitPnl = async (trade) => {
            try {
                // Get stored partial exits for this trade from Supabase
                const partialExits = await dataStore.getPartialExits(trade.id);
                
                if (partialExits.length === 0) {
                    // Fallback to main trade data if no partial exits found
                    const exitQty = trade.exit_quantity || trade.quantity;
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    const grossPnl = (trade.exit_price - trade.entry_price) * exitQty * (isShort ? -1 : 1);
                    const brokerage = trade.brokerage || 0;
                    const otherFees = trade.other_fees || 0;
                    return grossPnl - brokerage - otherFees;
                }
                
                // Calculate total P&L from all partial exits
                const entryPrice = trade.entry_price || 0;
                const directionMultiplier = trade.direction === 'Short' ? -1 : 1;
                let totalPnl = 0;
                
                partialExits.forEach(exit => {
                    const grossPnl = (exit.price - entryPrice) * exit.quantity * directionMultiplier;
                    const totalCharges = (exit.brokerage || 0) + (exit.charges || 0);
                    const netPnl = grossPnl - totalCharges;
                    totalPnl += netPnl;
                });
                
                console.log(`Partial Exit P&L Calculation for ${trade.asset}:`, {
                    partialExits: partialExits.length,
                    totalPnl: totalPnl,
                    entryPrice: entryPrice,
                    direction: trade.direction
                });
                
                return totalPnl;
            } catch (error) {
                console.error('Error calculating partial exit P&L:', error);
                return 0;
            }
        };

        // Function to get average entry and exit prices for partial trades
        const getPartialTradePrices = async (trade) => {
            try {
                // Check if this is a partial exit trade
                const isPartialExit = trade.exit_quantity && trade.exit_quantity > 0 && trade.exit_quantity < trade.quantity;
                
                if (!isPartialExit) {
                    // For full trades, return the original prices
                    return {
                        avgEntryPrice: trade.entry_price || 0,
                        avgExitPrice: trade.exit_price || 0
                    };
                }
                
                // Get stored partial exits for this trade from Supabase
                const partialExits = await dataStore.getPartialExits(trade.id);
                
                if (partialExits.length === 0) {
                    // Fallback to main trade data if no partial exits found
                    return {
                        avgEntryPrice: trade.entry_price || 0,
                        avgExitPrice: trade.exit_price || 0
                    };
                }
                
                // Calculate average exit price (weighted by quantity)
                const totalValue = partialExits.reduce((sum, exit) => sum + (exit.price * exit.quantity), 0);
                const totalQuantity = partialExits.reduce((sum, exit) => sum + exit.quantity, 0);
                const avgExitPrice = totalQuantity > 0 ? totalValue / totalQuantity : 0;
                
                // For entry price, we use the original entry price since it's typically entered at one price
                const avgEntryPrice = trade.entry_price || 0;
                
                console.log(`Partial Trade Prices for ${trade.asset}:`, {
                    avgEntryPrice: avgEntryPrice,
                    avgExitPrice: avgExitPrice,
                    partialExits: partialExits.length,
                    totalQuantity: totalQuantity
                });
                
                return {
                    avgEntryPrice: avgEntryPrice,
                    avgExitPrice: avgExitPrice
                };
            } catch (error) {
                console.error('Error calculating partial trade prices:', error);
                return {
                    avgEntryPrice: trade.entry_price || 0,
                    avgExitPrice: trade.exit_price || 0
                };
            }
        };
        
        const calculatePnlPercentage = (trade) => {
            if (!trade.exit_price || !trade.entry_price || !trade.quantity) return 0;
            // Calculate P&L percentage based on total investment and total return
            // This shows the actual return percentage on the total investment
            // For partial exits: shows what percentage of total investment was returned
            const netPnl = calculateNetPnl(trade);
            const totalInvestment = trade.entry_price * trade.quantity; // Always use full entry quantity for total investment
            return (netPnl / totalInvestment) * 100;
        };
        
        const updateLiveClock = () => {
            if (!liveTimeEl || !liveDateEl) return;
            const now = new Date();
            const timeOptions = { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true };
            liveTimeEl.textContent = now.toLocaleTimeString('en-IN', timeOptions);
            const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            liveDateEl.textContent = now.toLocaleDateString('en-IN', dateOptions);
        };

        // --- Trade Saved Modal ---
        const tradeSavedModal = document.getElementById('trade-saved-modal');
        const showTradeSavedModal = () => {
            const now = new Date();
            const todayStr = now.toISOString().split('T')[0];
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];
            let todaysPnl = 0;
            let yesterdaysPnl = 0;
            
            // Calculate today's P&L from trades that were closed today
            const closedTradesToday = appState.trades.filter(t => t.exit_date && t.exit_price);
            console.log('All closed trades:', closedTradesToday);
            
            closedTradesToday.forEach(trade => {
                try {
                    // Handle different date formats
                    let tradeDateStr;
                    if (!trade.exit_date || typeof trade.exit_date !== 'string') {
                        console.warn('Missing or invalid exit_date in trade saved modal:', trade.exit_date, 'for trade:', trade);
                        return;
                    }
                    
                    if (trade.exit_date.includes('T')) {
                        // ISO format: 2024-01-15T10:30:00
                        const exitDate = new Date(trade.exit_date);
                        if (!isNaN(exitDate.getTime())) {
                            tradeDateStr = exitDate.toISOString().split('T')[0];
                        } else {
                            console.warn('Invalid exit_date in trade saved modal:', trade.exit_date, 'for trade:', trade);
                            return; // Skip this trade
                        }
                    } else {
                        // Date only format: 2024-01-15
                        tradeDateStr = trade.exit_date.split('T')[0];
                    }
                    
                    const pnl = calculateNetPnl(trade);
                    console.log(`Trade: ${trade.asset}, Exit Date: ${trade.exit_date}, Date String: ${tradeDateStr}, P&L: ${pnl}`);
                    console.log(`Today: ${todayStr}, Yesterday: ${yesterdayStr}`);
                    console.log(`Date comparison - Today match: ${tradeDateStr === todayStr}, Yesterday match: ${tradeDateStr === yesterdayStr}`);
                    
                    if (tradeDateStr === todayStr) {
                        todaysPnl += pnl;
                        console.log(`Added to today's P&L: ${pnl}, Total today: ${todaysPnl}`);
                    } else if (tradeDateStr === yesterdayStr) {
                        yesterdaysPnl += pnl;
                        console.log(`Added to yesterday's P&L: ${pnl}, Total yesterday: ${yesterdaysPnl}`);
                    }
                } catch (error) {
                    console.error('Error processing closed trade in showTradeSavedModal:', error, 'for trade:', trade);
                }
            });
            
            // Also include any trades that were entered today (for open positions)
            const tradesEnteredToday = appState.trades.filter(t => t.entry_date);
            let openTradesToday = 0;
            let totalOpenValue = 0;
            
            tradesEnteredToday.forEach(trade => {
                try {
                    if (!trade.entry_date || typeof trade.entry_date !== 'string') {
                        console.warn('Missing or invalid entry_date in trade saved modal:', trade.entry_date, 'for trade:', trade);
                        return;
                    }
                    
                    const entryDate = new Date(trade.entry_date);
                    if (!isNaN(entryDate.getTime())) {
                        const entryDateStr = entryDate.toISOString().split('T')[0];
                        if (entryDateStr === todayStr && !trade.exit_date) {
                            openTradesToday++;
                            totalOpenValue += (trade.entry_price || 0) * (trade.quantity || 0);
                            console.log('Open trade entered today:', trade.asset, 'Value:', (trade.entry_price || 0) * (trade.quantity || 0));
                        }
                    } else {
                        console.warn('Invalid entry_date in trade saved modal:', trade.entry_date, 'for trade:', trade);
                    }
                } catch (error) {
                    console.error('Error processing trade in showTradeSavedModal:', error, 'for trade:', trade);
                }
            });
            console.log('Trade Saved Modal P&L Calculation:');
            console.log('Today:', todayStr, 'P&L:', todaysPnl);
            console.log('Yesterday:', yesterdayStr, 'P&L:', yesterdaysPnl);
            console.log('Total trades:', appState.trades.length);
            console.log('Closed trades today:', closedTradesToday.filter(t => {
                try {
                    if (!t.exit_date || typeof t.exit_date !== 'string') return false;
                    const exitDate = new Date(t.exit_date);
                    return !isNaN(exitDate.getTime()) && exitDate.toISOString().split('T')[0] === todayStr;
                } catch (error) {
                    console.error('Error filtering closed trades today:', error, 'for trade:', t);
                    return false;
                }
            }).length);
            console.log('Open trades entered today:', openTradesToday, 'Total value:', totalOpenValue);
            
            const pnlDifference = todaysPnl - yesterdaysPnl;
            const todayPnlEl = document.getElementById('tsm-today-pnl');
            
            // Show more meaningful information for today's P&L
            if (todaysPnl !== 0) {
                // Show actual realized P&L from closed trades
                todayPnlEl.textContent = `${todaysPnl >= 0 ? '+' : ''}${window.utils.formatCurrency(todaysPnl)}`;
                todayPnlEl.className = `font-bold text-lg ${todaysPnl >= 0 ? 'text-green-500' : 'text-red-500'}`;
            } else if (openTradesToday > 0) {
                // Show that you have open positions today
                todayPnlEl.textContent = `${openTradesToday} Open Position${openTradesToday > 1 ? 's' : ''}`;
                todayPnlEl.className = `font-bold text-lg text-blue-500`;
            } else {
                // No activity today
                todayPnlEl.textContent = '₹0.00';
                todayPnlEl.className = `font-bold text-lg text-gray-500`;
            }
            
            const yesterdayPnlEl = document.getElementById('tsm-yesterday-pnl');
            yesterdayPnlEl.textContent = `${yesterdaysPnl >= 0 ? '+' : ''}${window.utils.formatCurrency(yesterdaysPnl)}`;
            yesterdayPnlEl.className = `font-bold text-lg ${yesterdaysPnl >= 0 ? 'text-green-500' : 'text-red-500'}`;
            const comparisonTextEl = document.getElementById('tsm-comparison-text');
            const comparisonIconContainer = comparisonTextEl.previousElementSibling;
            if (pnlDifference >= 0) {
                comparisonTextEl.textContent = `You saw an increase of ${window.utils.formatCurrency(pnlDifference)} in your pnl compared to the last session!`;
                comparisonIconContainer.innerHTML = `<i data-feather="arrow-up" class="h-4 w-4 text-green-500 mr-1"></i>`;
            } else {
                comparisonTextEl.textContent = `You saw a decrease of ${window.utils.formatCurrency(Math.abs(pnlDifference))} in your pnl compared to the last session.`;
                comparisonIconContainer.innerHTML = `<i data-feather="arrow-down" class="h-4 w-4 text-red-500 mr-1"></i>`;
            }
            tradeSavedModal.classList.remove('hidden');
            feather.replace();
        };

        document.getElementById('trade-saved-close-btn').addEventListener('click', () => {
            tradeSavedModal.classList.add('hidden');
            navigateTo('trade-history');
        });

        // --- Confirmation Modal ---
        let confirmCallback = null;
        const showConfirmationModal = (message, onConfirm, title = "Confirm Deletion", confirmText = "Delete") => {
            document.getElementById('confirmation-message').textContent = message;
            document.getElementById('confirmation-title').textContent = title;
            document.getElementById('confirmation-confirm-btn').textContent = confirmText;
            confirmCallback = onConfirm;
            confirmationModal.classList.remove('hidden');
            feather.replace();
        };
        const hideConfirmationModal = () => {
            confirmationModal.classList.add('hidden');
            confirmCallback = null;
        };
        document.getElementById('confirmation-confirm-btn').addEventListener('click', () => {
            if (typeof confirmCallback === 'function') {
                confirmCallback();
            }
            hideConfirmationModal();
        });
        document.getElementById('confirmation-cancel-btn').addEventListener('click', hideConfirmationModal);

        // --- THEME MANAGEMENT ---
        const applyTheme = () => {
            const isDark = appState.theme === 'dark';
            document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
            if (themeToggleInput) {
                themeToggleInput.checked = isDark;
            }
            // Removed renderAllCharts() to prevent unnecessary chart recreation during theme switching
            // Charts will be updated efficiently by updateChartsOnThemeChange() instead
        };

        if (themeToggleInput) {
            themeToggleInput.addEventListener('change', () => {
                appState.theme = themeToggleInput.checked ? 'dark' : 'light';
                localStorage.setItem('theme', appState.theme);
                applyTheme();
                // Update charts immediately with new theme colors (no delay needed)
                updateChartsOnThemeChange();
                // Skip table re-rendering during theme changes to prevent flicker
                updateTradeDependentUI(true);
            });
        }
        
        // --- SIDEBAR TOGGLE FOR MOBILE ---
        const toggleSidebar = () => {
            sidebar.classList.toggle('-translate-x-full');
            sidebarOverlay.classList.toggle('hidden');
        };

        menuToggleBtn?.addEventListener('click', toggleSidebar);
        sidebarOverlay?.addEventListener('click', toggleSidebar);

        document.querySelectorAll('#sidebar .nav-item').forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth < 768) {
                    toggleSidebar();
                }
            });
        });

        // Track previous session to detect real login vs token refresh
        let previousSession = null;
        let isInitialLoad = true;

        // --- AUTHENTICATION & UI VISIBILITY ---
        auth.onAuthStateChanged(async (user) => {
            console.log('Auth state changed:', user ? 'User logged in' : 'User logged out');
            
            if (user) {
                // Check if this is a real login or just token refresh
                const isRealLogin = !previousSession || isInitialLoad;
                
                if (isRealLogin) {
                    console.log('Real login detected - running full initialization');
                    
                    appState.user = user;
                    
                    // delegate UI updates to extracted module
                    if (window.authState && typeof window.authState.handleAuthChange === 'function') {
                        window.authState.handleAuthChange(user);
                    }
                    
                    appState.unsubscribeTrades();
                    appState.unsubscribeLedger();
                    appState.unsubscribeProfile();
                    appState.unsubscribeChallenge();
                    appState.unsubscribeChallengeHistory();

                    if (appState.clockIntervalId) clearInterval(appState.clockIntervalId);
                    updateLiveClock();
                    appState.clockIntervalId = setInterval(updateLiveClock, 1000);

                    setupSupabaseListeners();
                    
                    // Get the saved page first
                    const savedPage = localStorage.getItem('currentPage') || 'dashboard';
                    
                    // Set the correct page as active BEFORE loading data to prevent flicker
                    const pages = document.querySelectorAll('.page');
                    const navItems = document.querySelectorAll('.nav-item');
                    
                    // Set the correct page as active immediately
                    pages.forEach(p => p.classList.remove('active'));
                    const targetPage = document.getElementById(savedPage);
                    if (targetPage) targetPage.classList.add('active');
                    
                    // Set the correct nav item as active
                    navItems.forEach(item => item.classList.remove('active'));
                    const activeNavItem = document.querySelector(`.nav-item[data-page="${savedPage}"]`);
                    if (activeNavItem) activeNavItem.classList.add('active');
                    
                    // Load all user data including challenges (without rendering all pages)
                    await loadUserDataOnly();
                    
                    // Navigate to the saved page (this will trigger page-specific logic)
                    navigateTo(savedPage);
                    applyTheme();
                    
                    // Load profile data immediately to update header with actual name
                    if (appState.user?.id) {
                        loadProfileData();
                    }
                } else {
                    console.log('Token refresh detected - skipping initialization to prevent auto refresh');
                    // Silent token refresh - no visual changes, no data reloading
                    // Just update the user reference silently
                    appState.user = user;
                }
                
                // Update session tracking
                previousSession = user;
                isInitialLoad = false;
            } else {
                appState.user = null;
                
                // delegate UI updates to extracted module
                if (window.authState && typeof window.authState.handleAuthChange === 'function') {
                    window.authState.handleAuthChange(null);
                }
                if (appState.clockIntervalId) clearInterval(appState.clockIntervalId);
                appState.clockIntervalId = null;
                
                // Reset session tracking
                previousSession = null;
                isInitialLoad = true;
            }
        });

        // --- AUTH FORM LOGIC ---
        // Auth logic moved to js/auth.js - backup saved in index.html.backup
        
        // --- DATA LISTENERS (Supabase Realtime) ---
        const setupSupabaseListeners = () => {
            console.log('setupSupabaseListeners called - user:', appState.user?.id);
            if (!appState.user) {
                console.log('No user found, skipping listener setup');
                return;
            }
            const userId = appState.user.id;
            console.log('Setting up Supabase listeners for user:', userId);
            
            // Clean up existing listeners
            if (appState.unsubscribeTrades) appState.unsubscribeTrades();
            if (appState.unsubscribeLedger) appState.unsubscribeLedger();
            if (appState.unsubscribeProfile) appState.unsubscribeProfile();
            if (appState.unsubscribeChallenge) appState.unsubscribeChallenge();
            if (appState.unsubscribeChallengeHistory) appState.unsubscribeChallengeHistory();
            
            // Set up Supabase realtime listeners
            const tradesChannel = supabase.channel(`trades-${userId}`)
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'trades', filter: `user_id=eq.${userId}` },
                    async (payload) => {
                        console.log('Supabase trades realtime update:', payload);
                        // Refresh trades data
                        appState.trades = await dataStore.getTrades();
                        console.log('Updated appState.trades with count:', appState.trades.length);
                        updateTradeDependentUI();
                        
                        // Force re-render of current page if it's data-dependent
                        const currentPage = document.querySelector('.page.active');
                        if (currentPage && ['trade-calendar', 'reports', 'trade-statement'].includes(currentPage.id)) {
                            console.log('Current page is data-dependent, forcing re-render:', currentPage.id);
                            setTimeout(() => {
                                if (currentPage.id === 'trade-calendar') {
                                    console.log('Re-rendering calendar with Supabase data');
                                    renderCalendar();
                                }
                                if (currentPage.id === 'reports') {
                                    console.log('Re-rendering reports with Supabase data');
                                    renderReports();
                                }
                                if (currentPage.id === 'trade-statement') {
                                    console.log('Re-rendering statement with Supabase data');
                                    renderStatement();
                                }
                            }, 10);
                        }
                    }
                )
                .subscribe();

            const ledgerChannel = supabase.channel(`ledger-${userId}`)
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'ledger', filter: `user_id=eq.${userId}` },
                    async (payload) => {
                        console.log('Supabase ledger realtime update:', payload);
                        // Refresh ledger data
                        appState.ledger = await dataStore.getLedger();
                        console.log('Updated appState.ledger with count:', appState.ledger.length);
                        updateLedgerDependentUI();
                        
                        // Force re-render of current page if it's ledger-dependent
                        const currentPage = document.querySelector('.page.active');
                        if (currentPage && ['trade-statement'].includes(currentPage.id)) {
                            console.log('Current page is ledger-dependent, forcing re-render:', currentPage.id);
                            setTimeout(() => {
                                if (currentPage.id === 'trade-statement') {
                                    console.log('Re-rendering statement with Supabase ledger data');
                                    renderStatement();
                                }
                            }, 10);
                        }
                    }
                )
                .subscribe();

            const profileChannel = supabase.channel(`profiles-${userId}`)
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'profiles', filter: `id=eq.${userId}` },
                    async (payload) => {
                        console.log('Supabase profile realtime update:', payload);
                        if (payload.new) {
                            renderProfilePage(payload.new);
                        }
                    }
                )
                .subscribe();

            const challengeChannel = supabase.channel(`challenges-${userId}`)
                .on('postgres_changes', 
                    { event: '*', schema: 'public', table: 'challenges', filter: `user_id=eq.${userId}` },
                    async (payload) => {
                        console.log('Supabase challenge realtime update:', payload);
                        // Refresh challenge data
                        const { data: activeChallenge } = await supabase
                            .from('challenges')
                            .select('*')
                            .eq('user_id', userId)
                            .eq('status', 'active')
                            .limit(1)
                            .single();
                        appState.challenge = activeChallenge;
                        renderChallenge();
                    }
                )
                .subscribe();

            // Store unsubscribe functions
            appState.unsubscribeTrades = () => supabase.removeChannel(tradesChannel);
            appState.unsubscribeLedger = () => supabase.removeChannel(ledgerChannel);
            appState.unsubscribeProfile = () => supabase.removeChannel(profileChannel);
            appState.unsubscribeChallenge = () => supabase.removeChannel(challengeChannel);
            appState.unsubscribeChallengeHistory = () => {}; // No separate history listener needed
        };
        
        const updateTradeDependentUI = (skipTableRendering = false) => {
            console.log('updateTradeDependentUI called - trades count:', appState.trades?.length || 0);
            
            // Clear performance cache when trade data changes
            performanceCache.clearCache();

            // Only clear page-specific caches for data changes, not theme changes
            if (!skipTableRendering) {
                tradeHistoryCache = null;
                tradeHistoryLastHash = null;
                statementCache = null;
                statementLastHash = null;
                
                // Clear open positions cache
                openPositionsCache = null;
                openPositionsLastHash = null;
            }
            
            // Render all pages first (without changing sidebar state)
            window.main.loadDashboardData().then(data => {
              window.ui.renderDashboardUI(data);
            }).catch(err => {
              console.error('loadDashboardData error', err);
            });
            if (!skipTableRendering) {
                renderTradeHistory();
                renderStatement();
            }
            renderCalendar();
            renderReports();
            renderChallenge();
            renderAllCharts(true); // Force immediate render for data changes
            
            // Refresh AI Analyst if it's the current page
            if (document.getElementById('ai-analyst').classList.contains('active')) {
                renderAIAnalyst();
            }
            
            // Ensure current page re-renders when data loads (renders last to prevent sidebar flicker)
            const currentPage = document.querySelector('.page.active');
            if (currentPage) {
                const pageId = currentPage.id;
                console.log('Current page detected:', pageId, 're-rendering...');
                switch(pageId) {
                    case 'dashboard':
                        window.main.loadDashboardData().then(data => {
                          window.ui.renderDashboardUI(data);
                        }).catch(err => {
                          console.error('loadDashboardData error', err);
                        });
                        break;
                    case 'trade-history':
                        renderTradeHistory();
                        break;
                    case 'trade-calendar':
                        console.log('Re-rendering calendar with data count:', appState.trades?.length || 0);
                        renderCalendar();
                        break;
                    case 'reports':
                        renderReports();
                        break;
                    case 'ai-analyst':
                        renderAIAnalyst();
                        break;
                    case 'challenge':
            renderChallenge();
                        break;
                    case 'trade-statement':
                        renderStatement();
                        break;
                    case 'profile':
                        loadProfileData();
                        break;
                }
            }
            
            // Force challenge page update if it's currently visible
            const challengePage = document.getElementById('challenge');
            if (challengePage && !challengePage.classList.contains('hidden')) {
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    renderChallenge();
                    renderChallengeHistory();
                }, 100);
            }
        };

        const updateLedgerDependentUI = () => {
            window.main.loadDashboardData().then(data => {
              window.ui.renderDashboardUI(data);
            }).catch(err => {
              console.error('loadDashboardData error', err);
            });
            renderFundManagement();
            renderStatement();
        };

        // --- LOGOUT BUTTONS ---
        // REMOVED: Logout button handlers have been moved to js/auth.js

        // --- PAGE NAVIGATION ---
        const pages = document.querySelectorAll('.page');
        const navItems = document.querySelectorAll('.nav-item');
        const navigateTo = (pageId) => {
            pages.forEach(p => p.classList.remove('active'));
            const newPage = document.getElementById(pageId);
            if (newPage) newPage.classList.add('active');
            mainContent.scrollTo(0, 0); 
            navItems.forEach(item => item.classList.remove('active'));
            const activeNavItem = document.querySelector(`.nav-item[data-page="${pageId}"]`);
            if(activeNavItem) {
                activeNavItem.classList.add('active');
                // Don't show title for dashboard, add-trade, trade-calendar, trade-history, fund-management, reports, trade-statement, challenge, ai-analyst, and profile pages
                if (pageId === 'dashboard' || pageId === 'add-trade' || pageId === 'trade-calendar' || pageId === 'trade-history' || pageId === 'fund-management' || pageId === 'reports' || pageId === 'trade-statement' || pageId === 'challenge' || pageId === 'ai-analyst' || pageId === 'profile') {
                    pageTitle.textContent = '';
                } else {
                    pageTitle.textContent = activeNavItem.querySelector('span').textContent.trim();
                }
            }
                // Store current page in localStorage for persistence
                localStorage.setItem('currentPage', pageId);
            if (pageId === 'add-trade') {
                clearTradeForm();
                // Set Trade tab as default when navigating to add trade page
                setTimeout(() => {
                    const tradeTab = document.getElementById('trade-tab');
                    const journalTab = document.getElementById('journal-tab');
                    const tradeTabContent = document.getElementById('trade-tab-content');
                    const journalTabContent = document.getElementById('journal-tab-content');
                    
                    if (tradeTab && journalTab && tradeTabContent && journalTabContent) {
                        // Set Trade tab as active
                        tradeTab.style.backgroundColor = 'var(--bg-primary)';
                        tradeTab.style.color = 'var(--text-primary)';
                        journalTab.style.backgroundColor = 'var(--bg-tertiary)';
                        journalTab.style.color = 'var(--text-secondary)';
                        
                        // Show Trade tab content, hide Journal tab content
                        tradeTabContent.classList.remove('hidden');
                        journalTabContent.classList.add('hidden');
                    }
                    
                    setupButtonGroups();
                }, 100);
            }
            if (pageId === 'dashboard') {
                window.main.loadDashboardData().then(data => {
                  window.ui.renderDashboardUI(data);
                }).catch(err => {
                  console.error('loadDashboardData error', err);
                });
            }
            if (pageId === 'trade-history') {
                console.log('Navigating to trade-history page');
                // Show immediate loading state for better UX
                const tbody = document.getElementById('trade-history-tbody');
                if (tbody && appState.trades && appState.trades.length > 1000) {
                    tbody.innerHTML = '<tr><td colspan="10" class="text-center py-4">Loading trades...</td></tr>';
                }
                // Use setTimeout for faster navigation response
                setTimeout(() => renderTradeHistory(), 0);
            }
            if (pageId === 'fund-management') {
                renderFundManagement();
            }
            if (pageId === 'trade-statement') {
                // Show immediate loading state for better UX
                const statementBody = document.getElementById('statement-tbody');
                if (statementBody && appState.trades && appState.trades.length > 1000) {
                    statementBody.innerHTML = '<tr><td colspan="15" class="text-center py-4">Loading statement...</td></tr>';
                }
                // Use setTimeout for faster navigation response
                setTimeout(() => renderStatement(), 0);
            }
            if (pageId === 'reports') {
                renderReports();
                // Replace feather icons for the new metric cards
                setTimeout(() => {
                    feather.replace();
                }, 100);
            }
            if (pageId === 'profile') {
                loadProfileData();
            }
            if (pageId === 'trade-calendar') {
                    console.log('Navigating to trade-calendar - current trades count:', appState.trades?.length || 0);
                    // Check if we have data, if not, wait for it
                    if (appState.trades && appState.trades.length > 0) {
                        console.log('Data available, rendering calendar immediately');
                        renderCalendar();
                    } else {
                        console.log('No data available, starting polling for data...');
                    // Wait for data to load, then render (optimized polling)
                    let attempts = 0;
                    const maxAttempts = 20; // 2 seconds max wait
                    const checkData = () => {
                        console.log(`Data check attempt ${attempts + 1}/${maxAttempts} - trades count:`, appState.trades?.length || 0);
                        if (appState.trades && appState.trades.length > 0) {
                            console.log('Data found, rendering calendar');
                            renderCalendar();
                        } else if (attempts < maxAttempts) {
                            attempts++;
                            setTimeout(checkData, 50); // Reduced from 100ms to 50ms
                        } else {
                            console.log('Timeout reached, rendering calendar anyway');
                            // Render anyway after timeout (will show empty state)
                            renderCalendar();
                        }
                    };
                    checkData();
                    }
            }
            if (pageId === 'challenge') {
                    // Check if we have challenge data loaded
                    const hasChallengeData = appState.challenge !== undefined || (appState.challengeHistory && appState.challengeHistory.length >= 0);
                    
                    // If challenge data hasn't been loaded yet, load it first
                    if (!hasChallengeData && appState.user?.id) {
                        console.log('Challenge data not loaded, loading now...');
                        loadInitialData().then(() => {
                            renderChallenge();
                            renderChallengeHistory();
                        });
                    } else if (appState.trades && appState.trades.length > 0) {
                        renderChallenge();
                        renderChallengeHistory();
                    } else {
                    // Wait for data to load, then render (optimized polling)
                    let attempts = 0;
                    const maxAttempts = 20; // 2 seconds max wait
                    const checkData = () => {
                        if (appState.trades && appState.trades.length > 0) {
                            renderChallenge();
                            renderChallengeHistory();
                        } else if (attempts < maxAttempts) {
                            attempts++;
                            setTimeout(checkData, 200); // Optimized to 200ms to prevent jitter
                        } else {
                            // Render anyway after timeout (will show empty state)
                            renderChallenge();
                            renderChallengeHistory();
                        }
                    };
                    checkData();
                    }
            }
            if (pageId === 'ai-analyst') {
                    // Check if we have data, if not, wait for it
                    if (appState.trades && appState.trades.length > 0) {
                        renderAIAnalyst();
                    } else {
                    // Wait for data to load, then render (optimized polling)
                    let attempts = 0;
                    const maxAttempts = 20; // 2 seconds max wait
                    const checkData = () => {
                        if (appState.trades && appState.trades.length > 0) {
                            renderAIAnalyst();
                        } else if (attempts < maxAttempts) {
                            attempts++;
                            setTimeout(checkData, 50); // Reduced from 100ms to 50ms
                        } else {
                            // Render anyway after timeout (will show empty state)
                            renderAIAnalyst();
                        }
                    };
                    checkData();
                    }
            }
        };
        navItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                navigateTo(item.dataset.page);
            });
        });

        // --- FUND MANAGEMENT MODAL LOGIC ---
        const transactionModal = document.getElementById('transaction-modal');
        const transactionForm = document.getElementById('transaction-form');
        const fmDepositBtn = document.getElementById('fm-deposit-btn');
        const fmWithdrawBtn = document.getElementById('fm-withdraw-btn');
        const transactionTitle = document.getElementById('transaction-modal-title');
        const transactionSubmitBtn = document.getElementById('transaction-submit-btn');
        let currentTxType = 'Deposit';
        let isEditMode = false;
        let editingEntry = null;

        const openTransactionModal = (type) => {
            currentTxType = type;
            isEditMode = false;
            editingEntry = null;
            transactionTitle.textContent = type === 'Deposit' ? 'Deposit Funds' : 'Withdraw Funds';
            transactionSubmitBtn.querySelector('.btn-text').textContent = type === 'Deposit' ? 'Add Deposit' : 'Add Withdrawal';
            transactionForm.reset();
            transactionModal.classList.remove('hidden');
        };
        const closeTransactionModal = () => {
            transactionModal.classList.add('hidden');
            // Reset edit mode when modal is closed
            isEditMode = false;
            editingEntry = null;
        };
        document.querySelectorAll('#transaction-modal .close-modal-btn').forEach(btn => btn.addEventListener('click', closeTransactionModal));
        fmDepositBtn?.addEventListener('click', () => openTransactionModal('Deposit'));
        fmWithdrawBtn?.addEventListener('click', () => openTransactionModal('Withdrawal'));
        transactionForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const amount = parseFloat(document.getElementById('transaction-amount').value) || 0;
            const date = document.getElementById('transaction-date').value || new Date().toISOString().slice(0,10);
            const notes = document.getElementById('transaction-notes').value || '';
            
            try {
                if (isEditMode && editingEntry) {
                    // Update existing entry
                    console.log('Updating entry:', editingEntry);
                    const updatedEntry = { ...editingEntry, amount, date, notes };
                    await dataStore.upsertLedger(updatedEntry);
                    appState.ledger = await dataStore.getLedger();
                    
                    try {
                        renderFundManagement();
                        window.main.loadDashboardData().then(data => {
                          window.ui.renderDashboardUI(data);
                        }).catch(err => {
                          console.error('loadDashboardData error', err);
                        });
                    } catch (renderErr) {
                        console.error('Render error:', renderErr);
                    }
                    
                    window.utils.showToast(`${editingEntry.type} updated successfully!`, 'success');
                    closeTransactionModal();
                } else {
                    // Create new entry
                    const entry = { 
                        id: window.utils.generateUUID(), 
                        user_id: appState.user?.id || 'anonymous',
                        type: currentTxType, 
                        amount, 
                        date, 
                        notes 
                    };
                    await dataStore.upsertLedger(entry);
                    appState.ledger = await dataStore.getLedger();
                    
                    try {
                        renderFundManagement();
                        window.main.loadDashboardData().then(data => {
                          window.ui.renderDashboardUI(data);
                        }).catch(err => {
                          console.error('loadDashboardData error', err);
                        });
                    } catch (renderErr) {
                        console.error('Render error:', renderErr);
                    }
                    
                    window.utils.showToast(`${currentTxType} of ${window.utils.formatCurrency(amount)} completed successfully!`, 'success');
                    closeTransactionModal();
                }
            } catch (err) {
                console.error('Failed to save ledger entry', err);
                window.utils.showToast('Failed to save transaction. Please try again.', 'error');
            }
        });

        // --- FULL RENDER FUNCTIONS ---
        const renderDashboard = async () => {
            try {
                // Check if filter is active - if so, skip this render to avoid overriding filtered data
                const dateFilter = document.getElementById('dateFilter');
                if (dateFilter && dateFilter.value !== 'all-time') {
                    // Filter is active, let the filter system handle the rendering
                    return;
                }
                
                // Ensure we have latest data
                appState.trades = await dataStore.getTrades();
                appState.ledger = await dataStore.getLedger();
                
            const { trades, ledger } = appState;
            const closedTrades = trades.filter(t => t.exit_price && t.exit_date);
            let netPnl = 0, grossProfit = 0, grossLoss = 0, totalNetProfit = 0, totalNetLoss = 0, wins = 0, losses = 0;
                
            closedTrades.forEach(trade => {
                const netPnlValue = calculateNetPnl(trade);
                netPnl += netPnlValue;
                
                // Calculate gross P&L (before charges)
                const exitPrice = parseFloat(trade.exit_price);
                const entryPrice = parseFloat(trade.entry_price);
                const quantity = parseFloat(trade.quantity);
                const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                const grossPnlValue = (exitPrice - entryPrice) * quantity * (isShort ? -1 : 1);
                
                // Use NET P&L to determine if it's a win or loss
                if (netPnlValue > 0) {
                    wins++;
                    grossProfit += netPnlValue;  // Use net P&L consistently
                    totalNetProfit += netPnlValue;
                } else if (netPnlValue < 0) {
                    losses++;
                    grossLoss += Math.abs(netPnlValue);  // Use net P&L consistently
                    totalNetLoss += Math.abs(netPnlValue);
                }
            });
                
                const totalTrades = closedTrades.length;
                const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
                const profitFactor = grossLoss > 0 ? grossProfit / grossLoss : (grossProfit > 0 ? '∞' : 0);
                const avgWin = wins > 0 ? grossProfit / wins : 0;
                const avgLoss = losses > 0 ? grossLoss / losses : 0;
                const avgWinLossRatio = avgLoss > 0 ? avgWin / avgLoss : (avgWin > 0 ? '∞' : 0);
                
                // Update main metrics
                const netPnlEl = document.getElementById('db-net-pnl');
                if (netPnlEl) {
                    netPnlEl.textContent = window.utils.formatCurrency(netPnl);
                    netPnlEl.className = `text-2xl font-bold mt-2 ${netPnl >= 0 ? 'text-green-500' : 'text-red-500'}`;
                }
                
                // Calculate and update Net P&L percentage
                const totalDeposits = ledger.filter(l => l.type === 'Deposit').reduce((s, l) => s + (l.amount || 0), 0);
                const netPnlPercentage = totalDeposits > 0 ? (netPnl / totalDeposits) * 100 : 0;
                const netPnlPercentageEl = document.getElementById('db-net-pnl-percentage');
                if (netPnlPercentageEl) {
                    netPnlPercentageEl.textContent = `${netPnlPercentage >= 0 ? '+' : ''}${netPnlPercentage.toFixed(2)}%`;
                    netPnlPercentageEl.className = 'text-xs font-bold';
                    netPnlPercentageEl.style.color = netPnlPercentage >= 0 ? '#10b981' : '#ef4444'; // Green or Red
                }
                
                const totalTradesEl = document.getElementById('db-total-trades');
                if (totalTradesEl) totalTradesEl.textContent = `${totalTrades} trades`;
                
                const winRateEl = document.getElementById('db-win-rate');
                if (winRateEl) winRateEl.textContent = `${winRate.toFixed(1)}%`;
                
                const wonTradesEl = document.getElementById('db-won-trades');
                if (wonTradesEl) wonTradesEl.textContent = `${wins} won`;
                
                const lostTradesEl = document.getElementById('db-lost-trades');
                if (lostTradesEl) lostTradesEl.textContent = `${losses} lost`;
                
                const profitFactorEl = document.getElementById('db-profit-factor');
                if (profitFactorEl) profitFactorEl.textContent = typeof profitFactor === 'number' ? profitFactor.toFixed(2) : profitFactor;
                
                const profitFactorRatioEl = document.getElementById('profit-factor-ratio');
                if (profitFactorRatioEl) profitFactorRatioEl.textContent = typeof profitFactor === 'number' ? profitFactor.toFixed(2) : profitFactor;
                
                const avgWinLossEl = document.getElementById('db-avg-win-loss');
                if (avgWinLossEl) avgWinLossEl.textContent = typeof avgWinLossRatio === 'number' ? avgWinLossRatio.toFixed(2) : avgWinLossRatio;
                
                const avgWinEl = document.getElementById('db-avg-win');
                if (avgWinEl) avgWinEl.textContent = `+${window.utils.formatCurrency(avgWin)}`;
                
                const avgLossEl = document.getElementById('db-avg-loss');
                if (avgLossEl) avgLossEl.textContent = `-${window.utils.formatCurrency(avgLoss)}`;
                
                // Calculate account metrics
                const deposits = ledger.filter(l => l.type === 'Deposit').reduce((s, l) => s + (l.amount || 0), 0);
                const withdrawals = ledger.filter(l => l.type === 'Withdrawal').reduce((s, l) => s + (l.amount || 0), 0);
                const deployedCapital = trades.filter(t => !t.exit_date).reduce((s, t) => s + ((t.entry_price || 0) * (t.quantity || 0)), 0);
            const accountValue = deposits - withdrawals + netPnl;
            appState.accountValue = accountValue;
                const availableCash = Math.max(0, accountValue - deployedCapital);
                
                // Calculate starting balance (first deposit or 0)
                const startingBalance = ledger.length > 0 ? 
                    ledger.filter(l => l.type === 'Deposit')[0]?.amount || 0 : 0;
                
                // Calculate open risk percentage and amount from active trades (same as Fund Management)
                const openRiskData = (() => {
                    const activeTrades = trades.filter(trade => !trade.exit_date || !trade.exit_price);
                    if (activeTrades.length === 0) return { percentage: 0, amount: 0 };
                    
                    const totalRiskAmount = activeTrades.reduce((total, trade) => {
                        // Risk is the potential loss if trade goes against us
                        // For Long: risk = entry_price * quantity (if price goes to 0)
                        // For Short: risk = (current_price - entry_price) * quantity (if price goes to infinity)
                        const tradeValue = trade.entry_price * trade.quantity;
                        return total + tradeValue;
                    }, 0);
                    
                    const totalAccountValue = accountValue > 0 ? accountValue : 1; // Avoid division by zero
                    const percentage = (totalRiskAmount / totalAccountValue) * 100;
                    
                    return { percentage, amount: totalRiskAmount };
                })();
                
                // Update account summary
            const summaryEl = document.getElementById('db-account-summary');
                if (summaryEl) {
            const txt = "text-2xl font-bold";
            summaryEl.innerHTML = `
                <div><p class="text-sm" style="color: var(--text-secondary);">NET ACCOUNT VALUE</p><p class="${txt} ${accountValue >= 0 ? 'text-green-500' : 'text-red-500'}">${window.utils.formatCurrency(accountValue)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">NET REALIZED P&L</p><p class="${txt} ${netPnl >= 0 ? 'text-green-500' : 'text-red-500'}">${window.utils.formatCurrency(netPnl)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">AVAILABLE CASH</p><p class="${txt}">${window.utils.formatCurrency(availableCash)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">DEPLOYED CAPITAL</p><p class="${txt}">${window.utils.formatCurrency(deployedCapital)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL DEPOSITS</p><p class="${txt}">${window.utils.formatCurrency(deposits)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL WITHDRAWN</p><p class="${txt}">${window.utils.formatCurrency(withdrawals)}</p></div>
                <div><p class="text-sm" style="color: var(--text-secondary);">STARTING BALANCE</p><p class="${txt}">${window.utils.formatCurrency(startingBalance)}</p></div>
                <div><p class="text-sm font-medium" style="color: var(--text-secondary);">TOTAL OPEN RISK <span class="text-xs">(${openRiskData.percentage.toFixed(1)}%)</span></p><p class="${txt}">${window.utils.formatCurrency(openRiskData.amount)}</p></div>`;
                }
                
                // Render dependent components
            renderOpenPositionsOverview(); // This will call renderTopTrades with dynamic count
            renderAllCharts();
                wireCsvButtons();
                
            } catch (e) {
                console.error('renderDashboard error', e);
            }
        };
        // --- CSV EXPORTS ---
        const toCsv = (rows) => rows.map(r => r.map(v => {
            if (v == null) return '';
            const s = String(v).replace(/"/g, '""');
            return /[",\n]/.test(s) ? `"${s}"` : s;
        }).join(','))
        .join('\n');

        const downloadCsv = (filename, rows) => {
            const blob = new Blob([toCsv(rows)], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            a.remove();
        };

        const wireCsvButtons = () => {
            // Export Statement CSV functionality removed
        };
        // Optimized renderTradeHistory with caching and lazy loading
        let tradeHistoryCache = null;
        let tradeHistoryLastHash = null;
        let tradeHistoryRendering = false; // Prevent race conditions
        
        const renderTradeHistory = async (skipDelay = false, filters = {}) => {
            try {
                const tbody = document.getElementById('trade-history-tbody');
                if (!tbody) return;
                
                // Prevent multiple simultaneous renders
                if (tradeHistoryRendering) return;
                tradeHistoryRendering = true;
                
                // Use existing appState.trades if available, avoid unnecessary fetch
                let trades = appState.trades;
                if (!trades || trades.length === 0) {
                    trades = await dataStore.getTrades();
                    appState.trades = trades;
                }
                
                // Apply filters to trades before rendering
                let filteredTrades = trades;
                if (Object.keys(filters).length > 0) {
                    filteredTrades = applyTradeHistoryFilters(trades, filters);
                }
                
                // Check if we can use cached HTML (only if no filters)
                const currentHash = performanceCache.getTradesHash(filteredTrades);
                if (tradeHistoryCache && tradeHistoryLastHash === currentHash && Object.keys(filters).length === 0) {
                    tbody.innerHTML = tradeHistoryCache;
                    tradeHistoryRendering = false;
                    return;
                }
                
                // Show loading state for large datasets (skip delay for theme changes)
                if (filteredTrades.length > 1000 && !skipDelay) {
                    tbody.innerHTML = '<tr><td colspan="15" class="text-center py-4">Loading trades...</td></tr>';
                    
                    // Use requestAnimationFrame for smoother rendering
                    requestAnimationFrame(() => {
                        renderTradeHistoryContent(filteredTrades, tbody);
                        tradeHistoryRendering = false;
                    });
                } else {
                    // Render immediately for theme changes or small datasets
                    renderTradeHistoryContent(filteredTrades, tbody);
                    tradeHistoryRendering = false;
                }
                
            } catch (e) {
                console.error('renderTradeHistory error', e);
                tradeHistoryRendering = false;
            }
        };
        
        // Filter logic for trade history
        const applyTradeHistoryFilters = (trades, filters) => {
            return trades.filter(trade => {
                // Status filter
                if (filters.status) {
                    const isClosed = trade.exit_date && trade.exit_price && (!trade.exit_quantity || trade.exit_quantity >= trade.quantity);
                    const isPartialExit = trade.exit_date && trade.exit_price && trade.exit_quantity && trade.exit_quantity < trade.quantity;
                    
                    let tradeStatus = 'Open';
                    if (isClosed) tradeStatus = 'Closed';
                    else if (isPartialExit) tradeStatus = 'Partial Exit';
                    
                    if (tradeStatus !== filters.status) return false;
                }
                
                // Date filters
                if (filters.startDate) {
                    const entryDate = new Date(trade.entry_date);
                    const startDate = new Date(filters.startDate);
                    if (entryDate < startDate) return false;
                }
                
                if (filters.endDate) {
                    const entryDate = new Date(trade.entry_date);
                    const endDate = new Date(filters.endDate);
                    if (entryDate > endDate) return false;
                }
                
                // Symbol filter
                if (filters.symbol) {
                    const symbol = trade.asset || '';
                    if (!symbol.toLowerCase().includes(filters.symbol.toLowerCase())) {
                        return false;
                    }
                }
                
                return true;
            });
        };
        
        const renderTradeHistoryContent = (trades, tbody) => {
            const rowsHtml = trades.map(t => {
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    const pnl = (isClosed || isPartialExit) ? calculateNetPnl(t) : 0;
                    const netProfitPercentage = (isClosed || isPartialExit) && t.entry_price ? ((pnl / (t.entry_price * (t.quantity || 0))) * 100) : 0;
                    let status = 'Open';
                    if (isClosed) status = 'Closed';
                    else if (isPartialExit) status = 'Partial Exit';
                    const type = t.direction || '—';
                    return `
                        <tr class="border-b" style="border-color: var(--border-color);">
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color); width: 40px;">
                                <input type="checkbox" class="trade-checkbox w-4 h-4 rounded border-gray-300" data-trade-id="${t.id}" title="Select this trade">
                            </td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.asset || '—'}</td>
                            <td class="px-3 py-2 border-r ${pnl >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${window.utils.formatCurrency(pnl)}</td>
                            <td class="px-3 py-2 border-r ${netProfitPercentage >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${(isClosed || isPartialExit) ? (netProfitPercentage ? netProfitPercentage.toFixed(2) + '%' : '—') : '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">
                                ${isPartialExit ? 
                                    `<span class="text-blue-600 underline cursor-pointer" data-action="view-partial" data-id="${t.id}">${status}</span>` : 
                                    status
                                }
                            </td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.entry_price ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.quantity ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${type}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.segment || '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${window.utils.formatDateForDisplay(t.entry_date) || '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.stop_loss ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.target_price ?? t.target ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.exit_price ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${t.exit_quantity ?? '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${window.utils.formatDateForDisplay(t.exit_date) || '—'}</td>
                            <td class="px-3 py-2 actions-cell" style="border-color: var(--border-color);">
                                ${isClosed ? 
                                    // Closed trades: Show Edit and Delete icons only
                                    `<button class="action-icon" data-action="edit" data-id="${t.id}" title="Edit Trade">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                        </svg>
                                    </button>
                                    <button class="action-icon" data-action="delete" data-id="${t.id}" title="Delete Trade">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <polyline points="3,6 5,6 21,6"></polyline>
                                            <path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                                        </svg>
                                    </button>` :
                                    // Partial/Open trades: Show Exit button and three-dot menu
                                    `<button class="exit-btn" data-action="exit" data-id="${t.id}">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 4px;">
                                            <path d="M7 17L17 7M17 7H7M17 7V17"></path>
                                        </svg>
                                        Exit
                                    </button>
                                    <div class="relative">
                                        <button class="action-icon overflow-menu-btn" data-action="menu" data-id="${t.id}" title="More Actions">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <circle cx="12" cy="12" r="1"></circle>
                                                <circle cx="19" cy="12" r="1"></circle>
                                                <circle cx="5" cy="12" r="1"></circle>
                                            </svg>
                                        </button>
                                        <div class="overflow-menu hidden" data-menu-for="${t.id}">
                                            <button class="menu-item" data-action="exit" data-id="${t.id}">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <path d="M7 17L17 7M17 7H7M17 7V17"></path>
                                                </svg>
                                                Exit Trade
                                            </button>
                                            <button class="menu-item" data-action="edit" data-id="${t.id}">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                                </svg>
                                                Edit
                                            </button>
                                            <button class="menu-item" data-action="delete" data-id="${t.id}">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polyline points="3,6 5,6 21,6"></polyline>
                                                    <path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                                                </svg>
                                                Delete
                                            </button>
                                        </div>
                                    </div>`
                                }
                            </td>
                        </tr>`;
                }).join('');
                
                // Cache the generated HTML
                tradeHistoryCache = rowsHtml;
                tradeHistoryLastHash = performanceCache.getTradesHash(trades);
                
                tbody.innerHTML = rowsHtml;
        };

        // Document-level event delegation for trade table actions (works regardless of re-renders)
        const setupTradeTableEventListeners = () => {
            console.log('Setting up document-level trade table event listeners...');
            
            // Use document-level event delegation - this will work even if elements are re-rendered
            document.addEventListener('click', (e) => {
                // Only handle clicks within the trade history table
                const tradeTable = e.target.closest('#trade-history-tbody');
                if (!tradeTable) return;
                
                console.log('Trade table clicked:', e.target);
                const target = e.target.closest('[data-action]');
                if (!target) {
                    console.log('No data-action found');
                    return;
                }
                
                const action = target.getAttribute('data-action');
                const id = target.getAttribute('data-id');
                console.log('Action:', action, 'ID:', id);
                
                if (action === 'edit') {
                    console.log('Edit action triggered for trade ID:', id);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Find the trade and populate the modal
                    const trade = appState.trades.find(x => String(x.id) === String(id));
                    if (!trade) {
                        console.error('Trade not found for ID:', id);
                        return;
                    }
                    
                    console.log('Found trade:', trade);
                    
                    // Populate edit modal with trade data
                    showEditTradeModal(trade);
                    
                } else if (action === 'delete') {
                    e.preventDefault();
                    e.stopPropagation();
                    showConfirmationModal('Delete this trade?', async () => {
                        try {
                            await dataStore.deleteTrade(id);
                            appState.trades = await dataStore.getTrades();
                            renderTradeHistory();
                            window.main.loadDashboardData().then(data => {
                              window.ui.renderDashboardUI(data);
                            }).catch(err => {
                              console.error('loadDashboardData error', err);
                            });
                            // Refresh AI Analyst if it's the current page
                            if (document.getElementById('ai-analyst').classList.contains('active')) {
                                renderAIAnalyst();
                            }
                        } catch (err) { console.error('delete trade failed', err); }
                    }, 'Confirm Deletion', 'Delete');
                    
                } else if (action === 'exit') {
                    e.preventDefault();
                    e.stopPropagation();
                    const trade = appState.trades.find(x => String(x.id) === String(id));
                    if (!trade) return;
                    showExitTradeModal(trade);
                    
                } else if (action === 'menu') {
                    // Toggle overflow menu
                    const menu = document.querySelector(`[data-menu-for="${id}"]`);
                    if (menu) {
                        // Close all other menus first
                        document.querySelectorAll('.overflow-menu').forEach(m => {
                            if (m !== menu) m.classList.add('hidden');
                        });
                        menu.classList.toggle('hidden');
                    }
                } else if (action === 'view-partial') {
                    e.preventDefault();
                    e.stopPropagation();
                    const trade = appState.trades.find(x => String(x.id) === String(id));
                    if (!trade) return;
                    showPartialExitDetailsModal(trade);
                }
            });
            
            console.log('Document-level trade table event listener attached successfully');
        };

        // Bulk Delete Functionality
        let isBulkDeleteInProgress = false; // Prevent concurrent operations
        
        const setupBulkDeleteListeners = () => {
            console.log('Setting up bulk delete event listeners...');
            
            // Select All checkbox functionality
            const selectAllCheckbox = document.getElementById('select-all-trades');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', (e) => {
                    const isChecked = e.target.checked;
                    const tradeCheckboxes = document.querySelectorAll('.trade-checkbox');
                    tradeCheckboxes.forEach(checkbox => {
                        checkbox.checked = isChecked;
                    });
                    updateBulkActionsUI();
                });
            }

            // Individual trade checkbox functionality
            document.addEventListener('change', (e) => {
                if (e.target.classList.contains('trade-checkbox')) {
                    if (isBulkDeleteInProgress) {
                        e.target.checked = !e.target.checked; // Revert change
                        window.utils.showToast('Cannot modify selection during delete operation', 'warning');
                        return;
                    }
                    updateBulkActionsUI();
                }
            });

            // Delete Selected button
            const deleteSelectedBtn = document.getElementById('delete-selected-btn');
            if (deleteSelectedBtn) {
                deleteSelectedBtn.addEventListener('click', async () => {
                    if (isBulkDeleteInProgress) {
                        window.utils.showToast('Delete operation already in progress', 'warning');
                        return;
                    }

                    const selectedIds = getSelectedTradeIds();
                    if (selectedIds.length === 0) {
                        window.utils.showToast('Please select trades to delete', 'error');
                        return;
                    }

                    // Validate IDs
                    if (!selectedIds.every(id => id && id.trim())) {
                        window.utils.showToast('Invalid trade selection. Please refresh and try again.', 'error');
                        return;
                    }

                    showConfirmationModal(
                        `Delete ${selectedIds.length} selected trade${selectedIds.length > 1 ? 's' : ''}? This action cannot be undone.`,
                        async () => {
                            if (isBulkDeleteInProgress) return;
                            
                            isBulkDeleteInProgress = true;
                            setBulkDeleteButtonsState(true);
                            
                            try {
                                window.utils.showToast('Deleting selected trades...', 'info');
                                
                                // Perform bulk delete with error handling
                                const result = await dataStore.deleteMultipleTrades(selectedIds);
                                
                                if (result) {
                                    // Refresh data and UI
                                    appState.trades = await dataStore.getTrades();
                                    updateTradeDependentUI();
                                    window.utils.showToast(`Successfully deleted ${selectedIds.length} trade${selectedIds.length > 1 ? 's' : ''}`, 'success');
                                    clearSelection();
                                } else {
                                    throw new Error('Delete operation returned false');
                                }
                            } catch (err) {
                                console.error('Bulk delete failed:', err);
                                window.utils.showToast(`Failed to delete trades: ${err.message || 'Unknown error'}`, 'error');
                            } finally {
                                isBulkDeleteInProgress = false;
                                setBulkDeleteButtonsState(false);
                            }
                        },
                        'Confirm Bulk Delete',
                        'Delete Selected'
                    );
                });
            }

            // Delete All button
            const deleteAllBtn = document.getElementById('delete-all-btn');
            if (deleteAllBtn) {
                deleteAllBtn.addEventListener('click', async () => {
                    if (isBulkDeleteInProgress) {
                        window.utils.showToast('Delete operation already in progress', 'warning');
                        return;
                    }

                    const totalTrades = appState.trades ? appState.trades.length : 0;
                    if (totalTrades === 0) {
                        window.utils.showToast('No trades to delete', 'info');
                        return;
                    }

                    showConfirmationModal(
                        `Delete ALL ${totalTrades} trades? This action cannot be undone and will permanently remove all your trading data.`,
                        async () => {
                            if (isBulkDeleteInProgress) return;
                            
                            isBulkDeleteInProgress = true;
                            setBulkDeleteButtonsState(true);
                            
                            try {
                                window.utils.showToast('Deleting all trades...', 'info');
                                
                                // Perform delete all with error handling
                                const result = await dataStore.deleteAllTrades();
                                
                                if (result) {
                                    // Refresh data and UI
                                    appState.trades = await dataStore.getTrades();
                                    updateTradeDependentUI();
                                    window.utils.showToast(`Successfully deleted all ${totalTrades} trades`, 'success');
                                    clearSelection();
                                } else {
                                    throw new Error('Delete all operation returned false');
                                }
                            } catch (err) {
                                console.error('Delete all failed:', err);
                                window.utils.showToast(`Failed to delete all trades: ${err.message || 'Unknown error'}`, 'error');
                            } finally {
                                isBulkDeleteInProgress = false;
                                setBulkDeleteButtonsState(false);
                            }
                        },
                        'Confirm Delete All',
                        'Delete All Trades'
                    );
                });
            }

            // Clear Selection button
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            if (clearSelectionBtn) {
                clearSelectionBtn.addEventListener('click', () => {
                    clearSelection();
                });
            }
        };

        // Helper functions for bulk delete
        const getSelectedTradeIds = () => {
            const checkboxes = document.querySelectorAll('.trade-checkbox:checked');
            return Array.from(checkboxes).map(cb => cb.getAttribute('data-trade-id'));
        };

        const updateBulkActionsUI = () => {
            const selectedIds = getSelectedTradeIds();
            const toolbar = document.getElementById('bulk-actions-toolbar');
            const selectedCount = document.getElementById('selected-count');
            const selectAllCheckbox = document.getElementById('select-all-trades');

            if (selectedIds.length > 0) {
                toolbar.classList.remove('hidden');
                selectedCount.textContent = `${selectedIds.length} trade${selectedIds.length > 1 ? 's' : ''} selected`;
            } else {
                toolbar.classList.add('hidden');
            }

            // Update select all checkbox state
            if (selectAllCheckbox) {
                const totalCheckboxes = document.querySelectorAll('.trade-checkbox').length;
                if (selectedIds.length === 0) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = false;
                } else if (selectedIds.length === totalCheckboxes) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = true;
                } else {
                    selectAllCheckbox.indeterminate = true;
                    selectAllCheckbox.checked = false;
                }
            }
        };

        const clearSelection = () => {
            const checkboxes = document.querySelectorAll('.trade-checkbox');
            checkboxes.forEach(cb => cb.checked = false);
            const selectAllCheckbox = document.getElementById('select-all-trades');
            if (selectAllCheckbox) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            }
            updateBulkActionsUI();
        };

        // Helper function to set button states during operations
        const setBulkDeleteButtonsState = (isLoading) => {
            const deleteSelectedBtn = document.getElementById('delete-selected-btn');
            const deleteAllBtn = document.getElementById('delete-all-btn');
            const clearSelectionBtn = document.getElementById('clear-selection-btn');
            
            if (deleteSelectedBtn) {
                deleteSelectedBtn.disabled = isLoading;
                deleteSelectedBtn.textContent = isLoading ? 'Deleting...' : 'Delete Selected';
            }
            
            if (deleteAllBtn) {
                deleteAllBtn.disabled = isLoading;
                deleteAllBtn.textContent = isLoading ? 'Deleting...' : 'Delete All Trades';
            }
            
            if (clearSelectionBtn) {
                clearSelectionBtn.disabled = isLoading;
            }
        };

        // Global event listeners for overflow menu management (set up once)
        const setupGlobalEventListeners = () => {
            // Close overflow menus when clicking outside or pressing Escape
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.overflow-menu') && !e.target.closest('.overflow-menu-btn')) {
                    document.querySelectorAll('.overflow-menu').forEach(menu => {
                        menu.classList.add('hidden');
                    });
                }
            });
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.overflow-menu').forEach(menu => {
                        menu.classList.add('hidden');
                    });
                }
            });
        };

        // Helper function to update metric cards
        const updateMetricCard = (elementId, value, colorClass) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = window.utils.formatCurrency(value);
                if (colorClass === 'text-green-600') {
                    element.className = 'text-2xl font-bold text-green-600';
                } else if (colorClass === 'text-red-600') {
                    element.className = 'text-2xl font-bold text-red-600';
                } else {
                    element.className = 'text-2xl font-bold';
                    element.style.color = 'var(--text-primary)';
                }
            }
        };

        // Helper function to update risk percentage card
        const updateRiskCard = (percentageElementId, amountElementId, percentage, amount) => {
            const percentageElement = document.getElementById(percentageElementId);
            const amountElement = document.getElementById(amountElementId);
            
            if (percentageElement) {
                percentageElement.textContent = `(${percentage.toFixed(1)}%)`;
            }
            
            if (amountElement) {
                amountElement.textContent = window.utils.formatCurrency(amount);
                amountElement.className = 'text-2xl font-bold';
                // Color coding based on risk level
                if (percentage <= 10) {
                    amountElement.style.color = '#10b981'; // Green for low risk
                } else if (percentage <= 25) {
                    amountElement.style.color = '#f59e0b'; // Amber for medium risk
                } else {
                    amountElement.style.color = '#ef4444'; // Red for high risk
                }
            }
        };

        const renderFundManagement = async () => {
            try {
                // Load ledger
                appState.ledger = await dataStore.getLedger();
                console.log('renderFundManagement: ledger data:', appState.ledger);

                // Calculate all financial metrics with validation
                const deposits = appState.ledger
                    .filter(l => l.type === 'Deposit')
                    .reduce((s, l) => {
                        const amount = parseFloat(l.amount) || 0;
                        return s + (isFinite(amount) ? amount : 0);
                    }, 0);
                const withdrawals = appState.ledger
                    .filter(l => l.type === 'Withdrawal')
                    .reduce((s, l) => {
                        const amount = parseFloat(l.amount) || 0;
                        return s + (isFinite(amount) ? amount : 0);
                    }, 0);
                
                // Calculate realized P&L from closed trades with validation
                const realizedPnl = appState.trades
                    .filter(trade => trade.exit_date && trade.exit_price)
                    .reduce((total, trade) => {
                        try {
                            const netPnl = calculateNetPnl(trade);
                            return total + (isFinite(netPnl) ? netPnl : 0);
                        } catch (error) {
                            console.warn('Error calculating P&L for trade:', trade.id, error);
                            return total;
                        }
                    }, 0);
                
                // Calculate net account value first (needed for risk calculation)
                const netAccountValue = deposits - withdrawals + realizedPnl;
                
                // Calculate deployed capital (money currently in active trades) with validation
                const deployedCapital = appState.trades
                    .filter(trade => !trade.exit_date || !trade.exit_price)
                    .reduce((total, trade) => {
                        try {
                            const entryPrice = parseFloat(trade.entry_price) || 0;
                            const quantity = parseFloat(trade.quantity) || 0;
                            const tradeValue = entryPrice * quantity;
                            return total + (isFinite(tradeValue) ? tradeValue : 0);
                        } catch (error) {
                            console.warn('Error calculating deployed capital for trade:', trade.id, error);
                            return total;
                        }
                    }, 0);
                
                // Calculate available cash (same formula as dashboard)
                const availableCash = Math.max(0, netAccountValue - deployedCapital);
                
                // Calculate open risk percentage and amount from active trades
                const openRiskData = (() => {
                    const activeTrades = appState.trades.filter(trade => !trade.exit_date || !trade.exit_price);
                    if (activeTrades.length === 0) return { percentage: 0, amount: 0 };
                    
                    const totalRiskAmount = activeTrades.reduce((total, trade) => {
                        // Risk is the potential loss if trade goes against us
                        // For Long: risk = entry_price * quantity (if price goes to 0)
                        // For Short: risk = (current_price - entry_price) * quantity (if price goes to infinity)
                        const tradeValue = trade.entry_price * trade.quantity;
                        return total + tradeValue;
                    }, 0);
                    
                    const totalAccountValue = Math.max(netAccountValue, 1); // Ensure minimum value of 1
                    const percentage = totalAccountValue > 0 ? (totalRiskAmount / totalAccountValue) * 100 : 0;
                    
                    return { percentage, amount: totalRiskAmount };
                })();
                
                // Starting account balance (first deposit or 0)
                const startingBalance = appState.ledger.length > 0 ? 
                    appState.ledger.filter(l => l.type === 'Deposit')[0]?.amount || 0 : 0;

                // Update the metric cards
                updateMetricCard('net-account-value', netAccountValue, netAccountValue >= 0 ? 'text-green-600' : 'text-red-600');
                updateMetricCard('net-realized-pnl', realizedPnl, realizedPnl >= 0 ? 'text-green-600' : 'text-red-600');
                updateMetricCard('starting-account-balance', startingBalance, 'text-gray-900');
                updateMetricCard('total-deposits', deposits, 'text-gray-900');
                updateMetricCard('deployed-capital', deployedCapital, 'text-gray-900');
                updateMetricCard('available-cash', availableCash, availableCash >= 0 ? 'text-green-600' : 'text-red-600');
                updateMetricCard('total-withdrawn', withdrawals, 'text-gray-900');
                updateRiskCard('total-open-risk-percentage', 'total-open-risk-amount', openRiskData.percentage, openRiskData.amount);

                const tbody = document.getElementById('fund-ledger-body');
                console.log('renderFundManagement: tbody element:', tbody);
                console.log('renderFundManagement: ledger length:', appState.ledger.length);
                if (tbody) {
                    tbody.innerHTML = appState.ledger.map(item => `
                        <tr>
                            <td class="px-6 py-3">${window.utils.formatDateForDisplay(item.date) || '—'}</td>
                            <td class="px-6 py-3">${item.type}</td>
                            <td class="px-6 py-3">${window.utils.formatCurrency(item.amount || 0)}</td>
                            <td class="px-6 py-3">${item.notes || '—'}</td>
                            <td class="px-6 py-3 actions-cell">
                                <button class="action-icon" data-ledger-action="edit" data-id="${item.id}" title="Edit Entry">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                        <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                                    </svg>
                                </button>
                                <button class="action-icon" data-ledger-action="delete" data-id="${item.id}" title="Delete Entry">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <polyline points="3,6 5,6 21,6"></polyline>
                                        <path d="M19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"></path>
                                    </svg>
                                </button>
                            </td>
                        </tr>
                    `).join('');

                    // wire row actions
                    tbody.querySelectorAll('button[data-ledger-action="edit"]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const id = btn.getAttribute('data-id');
                            const entry = appState.ledger.find(x => String(x.id) === String(id));
                            if (!entry) return;
                            
                            // Set edit mode
                            isEditMode = true;
                            editingEntry = entry;
                            currentTxType = entry.type;
                            
                            // Fill form with existing data
                            document.getElementById('transaction-amount').value = entry.amount || 0;
                            document.getElementById('transaction-date').value = entry.date || '';
                            document.getElementById('transaction-notes').value = entry.notes || '';
                            
                            // Update modal title and button text
                            transactionTitle.textContent = entry.type === 'Deposit' ? 'Deposit Funds' : 'Withdraw Funds';
                            transactionSubmitBtn.querySelector('.btn-text').textContent = entry.type === 'Deposit' ? 'Update Deposit' : 'Update Withdrawal';
                            
                            // Show modal
                            transactionModal.classList.remove('hidden');
                        });
                    });
                    tbody.querySelectorAll('button[data-ledger-action="delete"]').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const id = btn.getAttribute('data-id');
                            showConfirmationModal('Delete this ledger entry?', async () => {
                                try {
                                    await dataStore.deleteLedger(id);
                                    appState.ledger = await dataStore.getLedger();
                                    renderFundManagement();
                                    window.main.loadDashboardData().then(data => {
                                      window.ui.renderDashboardUI(data);
                                    }).catch(err => {
                                      console.error('loadDashboardData error', err);
                                    });
                                    window.utils.showToast('Ledger entry deleted successfully', 'success');
                                } catch (err) { 
                                    console.error('delete ledger failed', err);
                                    window.utils.showToast(`Failed to delete ledger entry: ${err.message || 'Unknown error'}`, 'error');
                                }
                            }, 'Confirm Deletion', 'Delete');
                        });
                    });
                }
            } catch (e) {
                console.error('renderFundManagement error', e);
            }
        };
        // Debouncing for calendar rendering to prevent jitter
        let calendarRenderTimeout = null;
        
        const renderCalendar = () => {
            // Clear previous timeout to prevent multiple rapid renders
            if (calendarRenderTimeout) {
                clearTimeout(calendarRenderTimeout);
            }
            
            // Debounce rendering by 50ms to prevent jitter
            calendarRenderTimeout = setTimeout(() => {
                try {
                    console.log('renderCalendar called - trades count:', appState.trades?.length || 0);
                    const monthYearEl = document.getElementById('calendar-month-year');
                    const daysContainer = document.getElementById('calendar-grid-days');
                    const weeklySummaries = document.getElementById('calendar-grid-summaries');
                    const monthlyPnlDisplay = document.getElementById('monthly-pnl-display');
                    const statsGrid = document.getElementById('calendar-stats-grid');
                    if (!monthYearEl || !daysContainer || !weeklySummaries) {
                        console.log('Calendar elements not found');
                        return;
                    }

                const baseDate = appState.calendarDate instanceof Date ? new Date(appState.calendarDate) : new Date();
                const year = baseDate.getFullYear();
                const month = baseDate.getMonth();
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const firstWeekday = firstDay.getDay(); // 0 Sun - 6 Sat
                const daysInMonth = lastDay.getDate();

                monthYearEl.textContent = firstDay.toLocaleString('default', { month: 'long', year: 'numeric' });

                const trades = Array.isArray(appState.trades) ? appState.trades : [];
                const pnlByDate = {};
                const tradesCountByDate = {};
                const fmtCompact = (num) => {
                    const abs = Math.abs(num);
                    if (abs >= 1_000_000) return `${(num/1_000_000).toFixed(1)}M`;
                    if (abs >= 1_000) return `${(num/1_000).toFixed(1)}K`;
                    return `${Math.round(num)}`;
                };
                trades.forEach(t => {
                    // Use the same logic as trade history to determine if trade is closed
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    
                    // Include both fully closed trades and partial exits in calendar
                    if (!isClosed && !isPartialExit) return;
                    
                    // Validate exit_date before converting
                    // Use date parsing that avoids timezone conversion issues
                    let d;
                    if (t.exit_date.includes('T')) {
                        // ISO format: 2024-01-15T10:30:00 - extract date part only
                        d = t.exit_date.split('T')[0];
                    } else {
                        // Date only format: 2024-01-15 - use as is
                        d = t.exit_date;
                    }
                    
                    // Validate the date format
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(d)) {
                        console.warn('Invalid exit_date format in calendar PnL:', t.exit_date, 'for trade:', t);
                        return; // Skip this trade
                    }
                    // Use the same calculateNetPnl function used throughout the app for consistency
                    const pnl = calculateNetPnl(t);
                    pnlByDate[d] = (pnlByDate[d] || 0) + pnl;
                    tradesCountByDate[d] = (tradesCountByDate[d] || 0) + 1;
                    
                    // Debug logging to help identify date matching issues
                    console.log(`Calendar: Trade ${t.asset} with exit_date ${t.exit_date} mapped to date ${d}, PnL: ${pnl}`);
                    
                });

                // Calculate KPI metrics for the current month
                const currentMonthTrades = trades.filter(t => {
                    // Use the same logic as trade history to determine if trade is closed
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    
                    if (!isClosed && !isPartialExit) return false;
                    
                    // Use date parsing that avoids timezone conversion issues
                    let tradeDateStr;
                    if (t.exit_date.includes('T')) {
                        // ISO format: 2024-01-15T10:30:00 - extract date part only
                        tradeDateStr = t.exit_date.split('T')[0];
                    } else {
                        // Date only format: 2024-01-15 - use as is
                        tradeDateStr = t.exit_date;
                    }
                    
                    // Validate the date format
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(tradeDateStr)) {
                        console.warn('Invalid exit_date format in current month filter:', t.exit_date, 'for trade:', t);
                        return false;
                    }
                    
                    // Parse the date string to get year and month
                    const [tradeYear, tradeMonth] = tradeDateStr.split('-').map(Number);
                    return tradeYear === year && (tradeMonth - 1) === month; // month is 0-indexed in Date object
                });

                let totalPnl = 0, totalTrades = 0, wins = 0, losses = 0, totalRisk = 0, totalReward = 0;
                currentMonthTrades.forEach(trade => {
                    const pnl = calculateNetPnl(trade);
                    totalPnl += pnl;
                    totalTrades++;
                    
                    if (pnl > 0) wins++;
                    else if (pnl < 0) losses++;
                    
                    // Calculate Risk:Reward ratio only for trades with both stop loss and target
                    const entryPrice = trade.entry_price || 0;
                    const exitPrice = trade.exit_price || 0;
                    
                    // Only calculate R:R for trades that have both stop loss and target
                    if (trade.stop_loss && trade.target) {
                        const stopLoss = trade.stop_loss;
                        const target = trade.target;
                        
                        const risk = Math.abs(entryPrice - stopLoss);
                        const reward = Math.abs(target - entryPrice);
                        
                        if (risk > 0) totalRisk += risk;
                        if (reward > 0) totalReward += reward;
                    }
                });

                const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
                const avgRR = totalRisk > 0 ? (totalReward / totalRisk) : 0;

                // Render KPI metrics
                if (statsGrid) {
                    statsGrid.innerHTML = `
                        <div class="p-4 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">TOTAL P&L</p>
                                    <p class="text-2xl font-bold ${totalPnl >= 0 ? 'text-green-500' : 'text-red-500'}">${window.utils.formatCurrency(totalPnl)}</p>
                                </div>
                                <div class="p-3 rounded-full ${totalPnl >= 0 ? 'bg-green-100' : 'bg-red-100'}">
                                    <i data-feather="${totalPnl >= 0 ? 'trending-up' : 'trending-down'}" class="h-6 w-6 ${totalPnl >= 0 ? 'text-green-600' : 'text-red-600'}"></i>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">WIN RATE</p>
                                    <p class="text-2xl font-bold ${winRate >= 50 ? 'text-green-500' : 'text-red-500'}">${winRate.toFixed(1)}%</p>
                                </div>
                                <div class="p-3 rounded-full ${winRate >= 50 ? 'bg-green-100' : 'bg-red-100'}">
                                    <i data-feather="target" class="h-6 w-6 ${winRate >= 50 ? 'text-green-600' : 'text-red-600'}"></i>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">TOTAL TRADES</p>
                                    <p class="text-2xl font-bold" style="color: var(--text-primary);">${totalTrades}</p>
                                </div>
                                <div class="p-3 rounded-full" style="background-color: var(--bg-secondary);">
                                    <i data-feather="activity" class="h-6 w-6" style="color: var(--text-secondary);"></i>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 rounded-lg shadow-sm" style="background-color: var(--bg-primary); border: 1px solid var(--border-color);">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm font-medium" style="color: var(--text-secondary);">AVG. R:R</p>
                                    <p class="text-2xl font-bold ${totalRisk > 0 ? (avgRR >= 1 ? 'text-green-500' : 'text-red-500') : 'text-gray-500'}">${totalRisk > 0 ? `1:${avgRR.toFixed(1)}` : 'N/A'}</p>
                                </div>
                                <div class="p-3 rounded-full ${totalRisk > 0 ? (avgRR >= 1 ? 'bg-green-100' : 'bg-red-100') : 'bg-gray-100'}">
                                    <i data-feather="bar-chart-2" class="h-6 w-6 ${totalRisk > 0 ? (avgRR >= 1 ? 'text-green-600' : 'text-red-600') : 'text-gray-600'}"></i>
                                </div>
                            </div>
                        </div>
                    `;
                }

                const startPad = firstWeekday; // number of empty cells before day 1
                const totalCells = startPad + daysInMonth;
                const weeks = Math.ceil(totalCells / 7);

                daysContainer.innerHTML = '';
                weeklySummaries.innerHTML = '';

                let dayCounter = 1;
                let monthlyPnl = 0;
                for (let w = 0; w < weeks; w++) {
                    const row = document.createElement('div');
                    row.className = 'grid grid-cols-7 gap-2 mb-2';
                    for (let d = 0; d < 7; d++) {
                        const cellIndex = w * 7 + d;
                        const cell = document.createElement('div');
                        cell.className = 'rounded-md p-2 text-sm h-24 flex flex-col justify-between border';
                        cell.style.backgroundColor = 'var(--bg-primary)';
                        cell.style.borderColor = 'var(--border-color)';

                        if (cellIndex >= startPad && dayCounter <= daysInMonth) {
                            const dateObj = new Date(year, month, dayCounter);
                            // Create ISO date string directly to avoid timezone conversion issues
                            const iso = `${year}-${String(month + 1).padStart(2, '0')}-${String(dayCounter).padStart(2, '0')}`;
                            const pnl = pnlByDate[iso] || 0;
                            const tCount = tradesCountByDate[iso] || 0;
                            
                            // Debug logging for calendar cell creation
                            if (tCount > 0) {
                                console.log(`Calendar cell ${dayCounter}: Created date ${iso}, found ${tCount} trades with PnL ${pnl}`);
                            }
                            monthlyPnl += pnl;
                            const isUp = pnl > 0; const isDown = pnl < 0;
                            const borderColor = isUp ? '#c7f0d5' : isDown ? '#f5c7c7' : 'var(--border-color)';
                            const pillBg = isUp ? 'rgba(34,197,94,0.08)' : isDown ? 'rgba(239,68,68,0.08)' : 'transparent';
                            const amountColor = isUp ? 'text-green-600' : isDown ? 'text-red-600' : 'text-gray-500';
                            cell.style.borderColor = borderColor;
                            cell.style.backgroundColor = pillBg || cell.style.backgroundColor;
                            
                            // Add hover and click functionality
                            cell.className += ' calendar-date-cell';
                            if (tCount > 0) {
                                cell.className += ' has-trades';
                            }
                            cell.setAttribute('data-date', iso);
                            cell.setAttribute('data-pnl', pnl);
                            cell.setAttribute('data-trades', tCount);
                            
                            // Add click functionality
                            cell.addEventListener('click', () => {
                                if (tCount > 0) {
                                    showTradeDetailsModal(iso, dateObj);
                                }
                            });
                            
                            const amount = pnl ? window.utils.formatCurrency(pnl) : '';
                            const countLine = tCount ? `<div class="text-[11px] mt-1" style="color: var(--text-secondary);">${tCount} ${tCount===1?'trade':'trades'}</div>` : '';
                            
                            cell.innerHTML = `
                                <div class="flex items-center justify-between">
                                    <span class="text-xs" style="color: var(--text-secondary);">${String(dayCounter).padStart(2,'0')}</span>
                                    <i data-feather="calendar" class="h-3.5 w-3.5" style="color: var(--text-muted);"></i>
                                </div>
                                <div class="text-right">
                                    <div class="text-xs font-semibold ${amountColor}">${amount}</div>
                                    ${countLine}
                                </div>
                            `;
                            dayCounter++;
                        } else {
                            cell.innerHTML = `&nbsp;`;
                            cell.style.opacity = '0.4';
                        }
                        row.appendChild(cell);
                    }
                    daysContainer.appendChild(row);

                    // Weekly summary for this row
                    const startDateOfRow = new Date(year, month, Math.max(1, (w*7 - startPad + 1)));
                    const endDateOfRow = new Date(year, month, Math.min(daysInMonth, (w+1)*7 - startPad));
                    let weekPnl = 0; let activeDays = 0;
                    for (let cd = new Date(startDateOfRow); cd <= endDateOfRow; cd.setDate(cd.getDate()+1)) {
                        // Create ISO date string directly to avoid timezone conversion issues
                        const day = cd.getDate();
                        const iso = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                        if (iso.slice(0,7) === `${year}-${String(month+1).padStart(2,'0')}`) {
                            const v = pnlByDate[iso] || 0;
                            weekPnl += v;
                            if (tradesCountByDate[iso]) activeDays++;
                        }
                    }
                    // Create a row wrapper just like the calendar rows
                    const summaryRow = document.createElement('div');
                    summaryRow.className = 'mb-2';
                    summaryRow.style.marginTop = '0.25rem'; // 4px to push down more
                    
                    const weekBox = document.createElement('div');
                    weekBox.className = 'rounded-md p-2 text-sm text-center border h-24 flex flex-col justify-between';
                    weekBox.style.backgroundColor = 'var(--bg-primary)';
                    weekBox.style.borderColor = 'var(--border-color)';
                    const label = `Week ${w+1}`;
                    const amt = weekPnl ? window.utils.formatCurrency(weekPnl) : '—';
                    const amtColor = weekPnl>=0 ? 'text-green-600' : 'text-red-600';
                    weekBox.innerHTML = `
                        <div class="text-xs" style="color: var(--text-secondary);">${label}</div>
                        <div class="amount-text font-semibold ${weekPnl===0?'text-gray-500':amtColor}">${amt}</div>
                        <div class="mt-1 inline-block text-[11px] px-2 py-[2px] rounded-full" style="background-color: var(--bg-secondary); color: var(--text-secondary);">${activeDays || 0} ${activeDays===1?'day':'days'}</div>
                    `;
                    
                    summaryRow.appendChild(weekBox);
                    weeklySummaries.appendChild(summaryRow);
                }

                if (monthlyPnlDisplay) {
                    monthlyPnlDisplay.textContent = `Monthly P&L: ${window.utils.formatCurrency(monthlyPnl)}`;
                    // Set color based on profit/loss
                    if (monthlyPnl > 0) {
                        monthlyPnlDisplay.style.color = '#10b981'; // green-500
                    } else if (monthlyPnl < 0) {
                        monthlyPnlDisplay.style.color = '#ef4444'; // red-500
                    } else {
                        monthlyPnlDisplay.style.color = 'var(--text-primary)'; // default color
                    }
                }
                const prevBtn = document.getElementById('prev-month-btn');
                const nextBtn = document.getElementById('next-month-btn');
                
                // Remove existing event listeners to prevent duplicates
                if (prevBtn) {
                    prevBtn.replaceWith(prevBtn.cloneNode(true));
                }
                if (nextBtn) {
                    nextBtn.replaceWith(nextBtn.cloneNode(true));
                }
                
                // Get fresh references after cloning
                const newPrevBtn = document.getElementById('prev-month-btn');
                const newNextBtn = document.getElementById('next-month-btn');
                
                newPrevBtn?.addEventListener('click', () => {
                    appState.calendarDate = new Date(year, month - 1, 1);
                    renderCalendar();
                });
                newNextBtn?.addEventListener('click', () => {
                    appState.calendarDate = new Date(year, month + 1, 1);
                    renderCalendar();
                });
                
                // Replace feather icons for both calendar and KPI metrics
                feather.replace();
                
                } catch (e) {
                    console.error('renderCalendar error', e);
                }
            }, 50); // 50ms debounce delay
        };


        // Function to show trade details modal for a specific date
        const showTradeDetailsModal = async (dateISO, dateObj) => {
            try {
                const modal = document.getElementById('trade-details-modal');
                const modalDate = document.getElementById('modal-date');
                const modalTotalPnl = document.getElementById('modal-total-pnl');
                const modalAvgRR = document.getElementById('modal-avg-rr');
                const modalTotalTrades = document.getElementById('modal-total-trades');
                const modalWinRate = document.getElementById('modal-win-rate');
                const modalTradesTbody = document.getElementById('modal-trades-tbody');
                
                if (!modal) return;

                // Get trades for the specific date
                const trades = Array.isArray(appState.trades) ? appState.trades : [];
                const dayTrades = trades.filter(t => {
                    // Use the same logic as trade history to determine if trade is closed
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    
                    if (!isClosed && !isPartialExit) return false;
                    
                    // Validate exit_date before converting
                    // Use date parsing that avoids timezone conversion issues
                    let tradeDate;
                    if (t.exit_date.includes('T')) {
                        // ISO format: 2024-01-15T10:30:00 - extract date part only
                        tradeDate = t.exit_date.split('T')[0];
                    } else {
                        // Date only format: 2024-01-15 - use as is
                        tradeDate = t.exit_date;
                    }
                    
                    // Validate the date format
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(tradeDate)) {
                        console.warn('Invalid exit_date format in calendar filter:', t.exit_date, 'for trade:', t);
                        return false; // Skip this trade
                    }
                    
                    return tradeDate === dateISO;
                });

                // Calculate metrics for the day
                let totalPnl = 0, totalTrades = 0, wins = 0, totalRisk = 0, totalReward = 0;
                
                dayTrades.forEach(trade => {
                    const pnl = calculateNetPnl(trade);
                    totalPnl += pnl;
                    totalTrades++;
                    
                    if (pnl > 0) wins++;
                    
                    // Calculate Risk:Reward ratio only for trades with both stop loss and target
                    const entryPrice = trade.entry_price || 0;
                    
                    // Only calculate R:R for trades that have both stop loss and target
                    if (trade.stop_loss && trade.target) {
                        const stopLoss = trade.stop_loss;
                        const target = trade.target;
                        
                        const risk = Math.abs(entryPrice - stopLoss);
                        const reward = Math.abs(target - entryPrice);
                        
                        if (risk > 0) totalRisk += risk;
                        if (reward > 0) totalReward += reward;
                    }
                });

                const winRate = totalTrades > 0 ? (wins / totalTrades) * 100 : 0;
                const avgRR = totalRisk > 0 ? (totalReward / totalRisk) : 0;

                // Update modal content
                const displayDate = window.utils.formatDateForDisplay(dateISO);
                modalDate.textContent = `${dateObj.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                })} (${displayDate})`;
                
                modalTotalPnl.textContent = window.utils.formatCurrency(totalPnl);
                modalTotalPnl.style.color = totalPnl >= 0 ? '#22c55e' : '#ef4444';
                
                modalAvgRR.textContent = totalRisk > 0 ? `1:${avgRR.toFixed(1)}` : 'N/A';
                modalAvgRR.style.color = totalRisk > 0 ? (avgRR >= 1 ? '#22c55e' : '#ef4444') : '#6b7280';
                
                modalTotalTrades.textContent = totalTrades.toString();
                
                modalWinRate.textContent = `${winRate.toFixed(1)}%`;
                modalWinRate.style.color = winRate >= 50 ? '#22c55e' : '#ef4444';

                // Update trades table
                if (modalTradesTbody) {
                    const tradeRows = await Promise.all(dayTrades.map(async trade => {
                        const pnl = calculateNetPnl(trade);
                        const isLong = trade.direction === 'Long';
                        const sideColor = isLong ? '#22c55e' : '#f59e0b';
                        const pnlColor = pnl >= 0 ? '#22c55e' : '#ef4444';
                        
                        // Get average prices for partial trades
                        const prices = await getPartialTradePrices(trade);
                        const isPartialExit = trade.exit_quantity && trade.exit_quantity > 0 && trade.exit_quantity < trade.quantity;
                        
                        return `
                            <tr>
                                <td class="px-4 py-2 font-medium">${trade.asset || 'N/A'}</td>
                                <td class="px-4 py-2">
                                    <span style="color: ${sideColor}; font-weight: 500;">${trade.direction || 'N/A'}</span>
                                    ${isPartialExit ? '<span class="text-xs text-blue-500 ml-1">(Partial)</span>' : ''}
                                </td>
                                <td class="px-4 py-2">${trade.quantity || 0}</td>
                                <td class="px-4 py-2">
                                    ₹${prices.avgEntryPrice.toLocaleString('en-IN', {minimumFractionDigits: 0, maximumFractionDigits: 2})}
                                    ${isPartialExit ? '<span class="text-xs text-gray-500 block">(Avg Entry)</span>' : ''}
                                </td>
                                <td class="px-4 py-2">
                                    ₹${prices.avgExitPrice.toLocaleString('en-IN', {minimumFractionDigits: 0, maximumFractionDigits: 2})}
                                    ${isPartialExit ? '<span class="text-xs text-gray-500 block">(Avg Exit)</span>' : ''}
                                </td>
                                <td class="px-4 py-2" style="color: ${pnlColor}; font-weight: 500;">
                                    ${pnl >= 0 ? '+' : ''}₹${Math.abs(pnl).toLocaleString('en-IN', {minimumFractionDigits: 0, maximumFractionDigits: 0})}
                                </td>
                            </tr>
                        `;
                    }));
                    
                    modalTradesTbody.innerHTML = tradeRows.join('');
                }

                // Show modal
                modal.style.display = 'flex';
                
                // Add close functionality
                const closeBtn = modal.querySelector('.close-btn');
                if (closeBtn) {
                    closeBtn.onclick = () => {
                        modal.style.display = 'none';
                    };
                }
                
                // Close on outside click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.style.display = 'none';
                    }
                };
                
                // Replace feather icons
                feather.replace();
                
            } catch (e) {
                console.error('showTradeDetailsModal error', e);
            }
        };

        // Helper function to format date for input fields (preserves local date)
        const formatDateForInput = (dateString) => {
            if (!dateString) return '';
            const date = new Date(dateString);
            if (isNaN(date.getTime())) return '';
            
            // Use local date methods to avoid timezone issues
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };

        // Function to show edit trade modal
        const showEditTradeModal = (trade) => {
            try {
                const modal = document.getElementById('edit-trade-modal');
                if (!modal) {
                    console.error('Edit trade modal not found');
                    return;
                }

                // Set the trade ID
                document.getElementById('edit-trade-id').value = trade.id;

                // Populate form fields with trade data
                const setFieldValue = (fieldId, value) => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        field.value = value || '';
                    } else {
                        console.warn(`Edit modal field not found: ${fieldId}`);
                    }
                };

                // Populate basic trade details
                setFieldValue('edit-symbol', trade.asset || trade.symbol);
                setFieldValue('edit-quantity', trade.quantity);
                setFieldValue('edit-entry-price', trade.entry_price);
                
                // Handle entry date - use local date formatting to avoid timezone issues
                setFieldValue('edit-entry-date', window.utils.formatDateForInput(trade.entry_date));

                // Handle stop loss and target price
                setFieldValue('edit-stop-loss', trade.stop_loss);
                setFieldValue('edit-target-price', trade.target_price || trade.target);

                // Handle exit details
                setFieldValue('edit-exit-price', trade.exit_price);
                setFieldValue('edit-exit-date', window.utils.formatDateForInput(trade.exit_date));

                // Handle exit trade tab fields
                setFieldValue('edit-exit-quantity', trade.exit_quantity);
                setFieldValue('edit-exit-price-exit', trade.exit_price);
                setFieldValue('edit-exit-date-exit', window.utils.formatDateForInput(trade.exit_date));

                // Populate notes
                setFieldValue('edit-reasons', trade.reasons);

                // Reset button state before showing modal
                resetEditModalButtonState();

            // Show the modal
            modal.classList.remove('hidden');
            console.log('Partial exit modal shown with data:', trade);

                // Replace feather icons
                feather.replace();

            } catch (e) {
                console.error('showEditTradeModal error', e);
            }
        };

        // Function to hide edit trade modal
        const hideEditTradeModal = () => {
            const modal = document.getElementById('edit-trade-modal');
            if (modal) {
                modal.classList.add('hidden');
            }
        };

        // Function to reset edit modal button state
        const resetEditModalButtonState = () => {
            console.log('resetEditModalButtonState called');
            const submitBtn = document.getElementById('edit-trade-submit-btn');
            const btnText = submitBtn?.querySelector('.btn-text');
            
            console.log('Button elements found:', { submitBtn: !!submitBtn, btnText: !!btnText });
            
            if (submitBtn && btnText) {
                btnText.textContent = 'Save';
                submitBtn.disabled = false;
                console.log('Button state reset successfully');
            } else {
                console.error('Could not find button elements for reset');
            }
        };

        // Global function to force reset edit modal (can be called from console)
        window.forceResetEditModal = () => {
            console.log('Force resetting edit modal...');
            resetEditModalButtonState();
            hideEditTradeModal();
        };

        // Test function to simulate form submission without actual processing
        window.testEditForm = () => {
            console.log('Testing edit form submission...');
            const submitBtn = document.getElementById('edit-trade-submit-btn');
            const btnText = submitBtn?.querySelector('.btn-text');
            
            if (submitBtn && btnText) {
                // Show loading state
                btnText.textContent = 'Testing...';
                submitBtn.disabled = true;
                
                // Simulate processing
                setTimeout(() => {
                    btnText.textContent = 'Save';
                    submitBtn.disabled = false;
                    console.log('Test completed - button should be reset');
                }, 2000);
            } else {
                console.error('Could not find button elements for test');
            }
        };

        // Function to switch between edit modal tabs
        const switchEditModalTab = (tabName) => {
            const tradeTab = document.getElementById('edit-trade-tab');
            const exitTab = document.getElementById('edit-exit-tab');
            const tradeContent = document.getElementById('edit-trade-content');
            const exitContent = document.getElementById('edit-exit-content');

            if (tabName === 'trade') {
                tradeTab.style.backgroundColor = 'var(--bg-primary)';
                tradeTab.style.color = 'var(--text-primary)';
                exitTab.style.backgroundColor = 'transparent';
                exitTab.style.color = 'var(--text-secondary)';
                tradeContent.classList.remove('hidden');
                exitContent.classList.add('hidden');
            } else if (tabName === 'exit') {
                exitTab.style.backgroundColor = 'var(--bg-primary)';
                exitTab.style.color = 'var(--text-primary)';
                tradeTab.style.backgroundColor = 'transparent';
                tradeTab.style.color = 'var(--text-secondary)';
                exitContent.classList.remove('hidden');
                tradeContent.classList.add('hidden');
            }
        };

        // Debouncing for reports rendering to prevent jitter
        let reportsRenderTimeout = null;
        
        const renderReports = () => {
            // Clear previous timeout to prevent multiple rapid renders
            if (reportsRenderTimeout) {
                clearTimeout(reportsRenderTimeout);
            }
            
            // Debounce rendering by 50ms to prevent jitter
            reportsRenderTimeout = setTimeout(() => {
                try {
                    console.log('renderReports called - trades count:', appState.trades?.length || 0);
                    // Render original Performance Metrics
                    const container = document.getElementById('reports-metrics-grid');
                    if (!container) {
                        console.log('Reports container not found');
                        return;
                    }
                // Enhanced data validation and error handling
                const trades = Array.isArray(appState.trades) ? appState.trades : [];
                
                // Safely filter closed trades with data validation
                const closed = trades.filter(t => {
                    try {
                        return t && t.exit_price && t.exit_date && 
                               typeof t.exit_price === 'number' && 
                               typeof t.exit_date === 'string' &&
                               !isNaN(t.exit_price);
                    } catch (e) {
                        return false;
                    }
                });
                
                // Safely filter wins and losses with data validation (using NET P&L after charges)
                const wins = closed.filter(t => {
                    try {
                        if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                            return false;
                        }
                        const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                        const grossPnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                        const charges = (t.brokerage || 0) + (t.other_fees || 0);
                        const netPnl = grossPnl - charges;
                        return isFinite(netPnl) && netPnl > 0;
                    } catch (e) {
                        return false;
                    }
                });
                
                const losses = closed.filter(t => {
                    try {
                        if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                            return false;
                        }
                        const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                        const grossPnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                        const charges = (t.brokerage || 0) + (t.other_fees || 0);
                        const netPnl = grossPnl - charges;
                        return isFinite(netPnl) && netPnl < 0;
                    } catch (e) {
                        return false;
                    }
                });
                
                // Safely calculate win rate with division by zero protection
                const winRate = closed.length > 0 ? (wins.length / closed.length) * 100 : 0;
                
                // Safely calculate gross profit with data validation (GROSS P&L - before charges)
                let grossProfit = 0;
                if (wins.length > 0) {
                    try {
                        grossProfit = wins.reduce((s, t) => {
                            try {
                                if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return s;
                                }
                                const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                                const pnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                                return isFinite(pnl) ? s + pnl : s;
                            } catch (e) {
                                return s;
                            }
                        }, 0);
                        grossProfit = isFinite(grossProfit) ? grossProfit : 0;
                    } catch (e) {
                        grossProfit = 0;
                    }
                }
                
                // Safely calculate gross loss with data validation (GROSS P&L - before charges)
                let grossLoss = 0;
                if (losses.length > 0) {
                    try {
                        const lossSum = losses.reduce((s, t) => {
                            try {
                                if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return s;
                                }
                                const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                                const pnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                                return isFinite(pnl) ? s + pnl : s;
                            } catch (e) {
                                return s;
                            }
                        }, 0);
                        grossLoss = isFinite(lossSum) ? Math.abs(lossSum) : 0;
                    } catch (e) {
                        grossLoss = 0;
                    }
                }
                
                // Safely calculate profit factor with division by zero protection
                const profitFactor = grossLoss > 0 && isFinite(grossProfit) && isFinite(grossLoss) ? (grossProfit / grossLoss) : 0;
                // Day aggregates with enhanced data validation
                const byDay = {};
                // Performance optimization: Cache day aggregates calculation
                const dayAggregates = performanceCache.getCachedChartData('dayAggregates', closed, () => {
                    const result = {};
                    closed.forEach(t => {
                        try {
                            // Enhanced date validation
                            if (!t || !t.exit_date || typeof t.exit_date !== 'string') {
                                return;
                            }
                            
                            const exitDate = new Date(t.exit_date);
                            if (isNaN(exitDate.getTime())) {
                                return;
                            }
                            
                            const d = exitDate.toISOString().slice(0,10);
                            
                            // Use cached PnL calculation
                            const pnl = calculateNetPnl(t);
                            if (isFinite(pnl)) {
                                result[d] = (result[d] || 0) + pnl;
                            }
                        } catch (e) {
                            console.warn('Error processing trade for day aggregates:', e);
                        }
                    });
                    return result;
                });
                
                // Use cached result
                Object.assign(byDay, dayAggregates);
                const days = Object.entries(byDay);
                const bestDay = days.length ? days.reduce((a,b)=> a[1] >= b[1] ? a : b) : null;
                const worstDay = days.length ? days.reduce((a,b)=> a[1] <= b[1] ? a : b) : null;
                // Strategy breakdown with enhanced data validation
                const byStrategy = {};
                // Performance optimization: Cache strategy breakdown calculation
                const strategyBreakdown = performanceCache.getCachedChartData('strategyBreakdown', closed, () => {
                    const result = {};
                    closed.forEach(t => {
                        try {
                            const key = t.strategy || 'Other';
                            
                            // Use cached PnL calculation
                            const pnl = calculateNetPnl(t);
                            if (isFinite(pnl)) {
                                result[key] = (result[key] || 0) + pnl;
                            }
                        } catch (e) {
                            console.warn('Error processing trade for strategy breakdown:', e);
                        }
                    });
                    return result;
                });
                
                // Use cached result
                Object.assign(byStrategy, strategyBreakdown);
                
                // Safely sort strategies with validation
                const topStrategies = Object.entries(byStrategy)
                    .filter(([_, pnl]) => isFinite(pnl))
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 3);

                // Calculate new comprehensive metrics with enhanced data validation
                let totalNetProfit = 0;
                if (wins.length > 0) {
                    try {
                        totalNetProfit = wins.reduce((sum, t) => {
                            try {
                                if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return sum;
                                }
                                const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                                const grossPnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                                const charges = (t.brokerage || 0) + (t.other_fees || 0);
                                
                                if (isFinite(grossPnl) && isFinite(charges)) {
                                    const pnl = grossPnl - charges;
                                    return isFinite(pnl) && pnl > 0 ? sum + pnl : sum;
                                }
                                return sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        totalNetProfit = isFinite(totalNetProfit) ? totalNetProfit : 0;
                    } catch (e) {
                        totalNetProfit = 0;
                    }
                }

                let totalNetLoss = 0;
                if (losses.length > 0) {
                    try {
                        totalNetLoss = losses.reduce((sum, t) => {
                            try {
                                if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return sum;
                                }
                                const isShort = t.trade_type === 'Short' || t.direction === 'Short';
                                const grossPnl = (t.exit_price - t.entry_price) * t.quantity * (isShort ? -1 : 1);
                                const charges = (t.brokerage || 0) + (t.other_fees || 0);
                                
                                if (isFinite(grossPnl) && isFinite(charges)) {
                                    const pnl = grossPnl - charges;
                                    return isFinite(pnl) && pnl < 0 ? sum + Math.abs(pnl) : sum;
                                }
                                return sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        totalNetLoss = isFinite(totalNetLoss) ? totalNetLoss : 0;
                    } catch (e) {
                        totalNetLoss = 0;
                    }
                }

                let totalCharges = 0;
                if (closed.length > 0) {
                    try {
                        totalCharges = closed.reduce((sum, t) => {
                            try {
                                const brokerage = typeof t.brokerage === 'number' ? t.brokerage : 0;
                                const otherFees = typeof t.other_fees === 'number' ? t.other_fees : 0;
                                const charges = brokerage + otherFees;
                                return isFinite(charges) ? sum + charges : sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        totalCharges = isFinite(totalCharges) ? totalCharges : 0;
                    } catch (e) {
                        totalCharges = 0;
                    }
                }

                let totalTradeAmount = 0;
                if (closed.length > 0) {
                    try {
                        totalTradeAmount = closed.reduce((sum, t) => {
                            try {
                                const entryPrice = typeof t.entry_price === 'number' ? t.entry_price : 0;
                                const exitPrice = typeof t.exit_price === 'number' ? t.exit_price : 0;
                                const quantity = typeof t.quantity === 'number' ? t.quantity : 0;
                                
                                const entryAmount = entryPrice * quantity;
                                const exitAmount = exitPrice * quantity;
                                
                                if (isFinite(entryAmount) && isFinite(exitAmount)) {
                                    return sum + entryAmount + exitAmount;
                                }
                                return sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        totalTradeAmount = isFinite(totalTradeAmount) ? totalTradeAmount : 0;
                    } catch (e) {
                        totalTradeAmount = 0;
                    }
                }

                // Safely calculate stop loss metrics with data validation
                let avgStopLoss = 0;
                const stopLossTrades = closed.filter(t => {
                    try {
                        return t && typeof t.stop_loss === 'number' && isFinite(t.stop_loss);
                    } catch (e) {
                        return false;
                    }
                });
                
                if (stopLossTrades.length > 0) {
                    try {
                        const stopLossSum = stopLossTrades.reduce((sum, t) => {
                            try {
                                const stopLoss = typeof t.stop_loss === 'number' ? t.stop_loss : 0;
                                return isFinite(stopLoss) ? sum + stopLoss : sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        avgStopLoss = isFinite(stopLossSum) ? stopLossSum / stopLossTrades.length : 0;
                    } catch (e) {
                        avgStopLoss = 0;
                    }
                }

                // Safely calculate target price metrics with data validation
                let avgTargetPrice = 0;
                const targetTrades = closed.filter(t => {
                    try {
                        return t && (typeof t.target_price === 'number' || typeof t.target === 'number') && 
                               (isFinite(t.target_price) || isFinite(t.target));
                    } catch (e) {
                        return false;
                    }
                });
                
                if (targetTrades.length > 0) {
                    try {
                        const targetSum = targetTrades.reduce((sum, t) => {
                            try {
                                const targetPrice = typeof t.target_price === 'number' ? t.target_price : 0;
                                const target = typeof t.target === 'number' ? t.target : 0;
                                const targetValue = targetPrice || target;
                                return isFinite(targetValue) ? sum + targetValue : sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        avgTargetPrice = isFinite(targetSum) ? targetSum / targetTrades.length : 0;
                    } catch (e) {
                        avgTargetPrice = 0;
                    }
                }

                // Safely calculate risk/reward metrics with data validation
                let avgRiskReward = 0;
                const riskRewardTrades = closed.filter(t => {
                    try {
                        return t && typeof t.stop_loss === 'number' && isFinite(t.stop_loss) && 
                               (typeof t.target_price === 'number' || typeof t.target === 'number') &&
                               (isFinite(t.target_price) || isFinite(t.target));
                    } catch (e) {
                        return false;
                    }
                });
                
                if (riskRewardTrades.length > 0) {
                    try {
                        const riskRewardSum = riskRewardTrades.reduce((sum, t) => {
                            try {
                                const entryPrice = typeof t.entry_price === 'number' ? t.entry_price : 0;
                                const stopLoss = typeof t.stop_loss === 'number' ? t.stop_loss : 0;
                                const targetPrice = typeof t.target_price === 'number' ? t.target_price : 0;
                                const target = typeof t.target === 'number' ? t.target : 0;
                                const targetValue = targetPrice || target;
                                
                                if (isFinite(entryPrice) && isFinite(stopLoss) && isFinite(targetValue)) {
                                    const risk = Math.abs(entryPrice - stopLoss);
                                    const reward = Math.abs(targetValue - entryPrice);
                                    
                                    if (risk > 0 && isFinite(reward)) {
                                        const ratio = reward / risk;
                                        return isFinite(ratio) ? sum + ratio : sum;
                                    }
                                }
                                return sum;
                            } catch (e) {
                                return sum;
                            }
                        }, 0);
                        avgRiskReward = isFinite(riskRewardSum) ? riskRewardSum / riskRewardTrades.length : 0;
                    } catch (e) {
                        avgRiskReward = 0;
                    }
                }

                const metric = (label, value, accent='') => `
                    <div class="flex items-center justify-between py-1 px-2 rounded-md" style="background-color: var(--bg-secondary);">
                        <span class="text-sm" style="color: var(--text-secondary);">${label}</span>
                        <span class="font-semibold ${accent}">${value}</span>
                    </div>`;

                // Override the parent grid layout
                container.className = 'space-y-4';
                container.innerHTML = `
                        <!-- Row 1: Gross Profit and Gross Loss -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Gross Profit', `${window.utils.formatCurrency(grossProfit)}`, 'text-green-500')}
                            ${metric('Gross Loss', `${window.utils.formatCurrency(-grossLoss)}`, 'text-red-500')}
                        </div>
                        
                        <!-- Row 2: Total Net Profit and Total Net Loss -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Total Net Profit', `${window.utils.formatCurrency(totalNetProfit)}`, 'text-green-500')}
                            ${metric('Total Net Loss', `${window.utils.formatCurrency(totalNetLoss)}`, 'text-red-500')}
                        </div>
                        
                        <!-- Row 3: Avg. Stop Loss and Avg. Target Price -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Avg. Stop Loss', `${window.utils.formatCurrency(avgStopLoss)}`)}
                            ${metric('Avg. Target Price', `${window.utils.formatCurrency(avgTargetPrice)}`)}
                        </div>
                        
                        <!-- Row 4: Total Trade Amount and Total Charges -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Total Trade Amount', `${window.utils.formatCurrency(totalTradeAmount)}`)}
                            ${metric('Total Charges', `${window.utils.formatCurrency(totalCharges)}`, 'text-orange-500')}
                        </div>
                        
                        <!-- Row 5: Best Day and Worst Day -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Best Day', bestDay ? `${bestDay[0]} • ${window.utils.formatCurrency(bestDay[1])}` : '—', 'text-green-500')}
                            ${metric('Worst Day', worstDay ? `${worstDay[0]} • ${window.utils.formatCurrency(worstDay[1])}` : '—', 'text-red-500')}
                        </div>
                        
                        <!-- Row 6: Risk:Reward Ratio and Closed Trades -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Risk:Reward Ratio', `${avgRiskReward.toFixed(2)}R`)}
                            ${metric('Closed Trades', closed.length)}
                        </div>
                `;

                // Render Advanced Trading Metrics
                renderAdvancedMetrics(trades, closed, wins, losses, byDay, byStrategy);
                } catch (e) {
                    console.error('renderReports error', e);
                }
            }, 50); // 50ms debounce delay
        };

        const renderAdvancedMetrics = (trades, closed, wins, losses, byDay, byStrategy) => {
            try {
                // Helper function to create metric row
                const createMetricRow = (label, value, color = '') => `
                    <div class="flex justify-between items-center">
                        <span class="text-sm" style="color: var(--text-secondary);">${label}</span>
                        <span class="text-sm font-semibold ${color}">${value}</span>
                    </div>`;

                // Define weekdaysOrder for use across all weekday-related metrics
                const weekdaysOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];

                // 1. Trade Performance Card
                // Enhanced data validation and error handling
                let breakEven = 0, avgWin = 0, avgLoss = 0, expectancy = 0;
                let winRate = 0;
                
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    try {
                        // Safely calculate break-even trades with data validation
                        breakEven = closed.filter(t => {
                            try {
                                // Validate trade data before calculation
                                if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return false;
                                }
                                
                                const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                return isFinite(pnl) && pnl === 0;
                            } catch (e) {
                                return false;
                            }
                        }).length;
                        
                        // Safely calculate average win with data validation
                        if (wins && Array.isArray(wins) && wins.length > 0) {
                            const validWins = wins.filter(t => {
                                try {
                                    if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                        return false;
                                    }
                                    const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                    return isFinite(pnl) && pnl > 0;
                                } catch (e) {
                                    return false;
                                }
                            });
                            
                            if (validWins.length > 0) {
                                const winSum = validWins.reduce((s, t) => {
                                    try {
                                        const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                        return isFinite(pnl) ? s + pnl : s;
                                    } catch (e) {
                                        return s;
                                    }
                                }, 0);
                                
                                avgWin = isFinite(winSum) ? winSum / validWins.length : 0;
                            }
                        }
                        
                        // Safely calculate average loss with data validation
                        if (losses && Array.isArray(losses) && losses.length > 0) {
                            const validLosses = losses.filter(t => {
                                try {
                                    if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                        return false;
                                    }
                                    const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                    return isFinite(pnl) && pnl < 0;
                                } catch (e) {
                                    return false;
                                }
                            });
                            
                            if (validLosses.length > 0) {
                                const lossSum = Math.abs(validLosses.reduce((s, t) => {
                                    try {
                                        const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                        return isFinite(pnl) ? s + pnl : s;
                                    } catch (e) {
                                        return s;
                                    }
                                }, 0));
                                
                                avgLoss = isFinite(lossSum) ? lossSum / validLosses.length : 0;
                            }
                        }
                        
                        // Safely calculate expectancy with division by zero protection
                        if (closed.length > 0) {
                            const winsCount = wins && Array.isArray(wins) ? wins.length : 0;
                            const lossesCount = losses && Array.isArray(losses) ? losses.length : 0;
                            
                            if (isFinite(avgWin) && isFinite(avgLoss)) {
                                expectancy = (winsCount * avgWin - lossesCount * avgLoss) / closed.length;
                                expectancy = isFinite(expectancy) ? expectancy : 0;
                            }
                        }
                        
                        // Safely calculate win rate with division by zero protection
                        if (closed.length > 0) {
                            const winsCount = wins && Array.isArray(wins) ? wins.length : 0;
                            winRate = (winsCount / closed.length) * 100;
                            winRate = isFinite(winRate) ? winRate : 0;
                        }
                        
                    } catch (e) {
                        console.warn('Error calculating trade performance metrics:', e);
                        // Reset to safe defaults
                        breakEven = 0; avgWin = 0; avgLoss = 0; expectancy = 0; winRate = 0;
                    }
                }

                // Safe DOM element access with fallback
                const tradePerformanceElement = document.getElementById('trade-performance-metrics');
                if (tradePerformanceElement) {
                    const winsCount = wins && Array.isArray(wins) ? wins.length : 0;
                    const lossesCount = losses && Array.isArray(losses) ? losses.length : 0;
                    
                    tradePerformanceElement.innerHTML = `
                        <div class="text-left mb-2">
                            <div class="text-2xl font-bold mb-1">
                                <span class="text-green-500">${winsCount}</span> / 
                                <span class="text-red-500">${lossesCount}</span> / 
                                <span style="color: var(--text-primary);">${breakEven}</span>
                            </div>
                            <div class="text-sm" style="color: var(--text-muted);">Win / Loss / Break Even</div>
                        </div>
                        <div class="grid grid-cols-2 gap-1.5">
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Avg Win</div>
                                <div class="text-sm font-semibold text-green-500">${window.utils.formatCurrency(avgWin)}</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Avg Loss</div>
                                <div class="text-sm font-semibold text-red-500">${window.utils.formatCurrency(-avgLoss)}</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Win Rate</div>
                                <div class="text-sm font-semibold" style="color: var(--text-primary);">${winRate.toFixed(1)}%</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Expectancy</div>
                                <div class="text-sm font-semibold" style="color: var(--text-primary);">${window.utils.formatCurrency(expectancy)}</div>
                            </div>
                        </div>
                    `;
                } else {
                    console.warn('Trade Performance metrics container not found');
                }

                // 2. Daily Performance Card
                // Enhanced data validation and error handling
                let winDays = 0, lossDays = 0, breakEvenDays = 0;
                let bestDayPnl = 0, worstDayPnl = 0;
                let avgWinDay = 0, avgLossDay = 0;
                
                if (byDay && typeof byDay === 'object' && Object.keys(byDay).length > 0) {
                    try {
                        // Safely filter days with data validation
                        const dayEntries = Object.entries(byDay).filter(([_, pnl]) => {
                            return typeof pnl === 'number' && isFinite(pnl);
                        });
                        
                        if (dayEntries.length > 0) {
                            // Safely calculate day counts
                            winDays = dayEntries.filter(([_, pnl]) => pnl > 0).length;
                            lossDays = dayEntries.filter(([_, pnl]) => pnl < 0).length;
                            breakEvenDays = dayEntries.filter(([_, pnl]) => pnl === 0).length;
                            
                            // Safely calculate best/worst day PnL with validation
                            const pnlValues = dayEntries.map(([_, pnl]) => pnl);
                            if (pnlValues.length > 0) {
                                bestDayPnl = Math.max(...pnlValues);
                                worstDayPnl = Math.min(...pnlValues);
                                
                                // Validate results
                                bestDayPnl = isFinite(bestDayPnl) ? bestDayPnl : 0;
                                worstDayPnl = isFinite(worstDayPnl) ? worstDayPnl : 0;
                            }
                            
                            // Safely calculate average win/loss days with division by zero protection
                            if (winDays > 0) {
                                const winPnls = pnlValues.filter(pnl => pnl > 0);
                                if (winPnls.length > 0) {
                                    const winSum = winPnls.reduce((a, b) => isFinite(a) && isFinite(b) ? a + b : a, 0);
                                    avgWinDay = isFinite(winSum) ? winSum / winDays : 0;
                                }
                            }
                            
                            if (lossDays > 0) {
                                const lossPnls = pnlValues.filter(pnl => pnl < 0);
                                if (lossPnls.length > 0) {
                                    const lossSum = Math.abs(lossPnls.reduce((a, b) => isFinite(a) && isFinite(b) ? a + b : a, 0));
                                    avgLossDay = isFinite(lossSum) ? lossSum / lossDays : 0;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Error calculating daily performance metrics:', e);
                        // Reset to safe defaults
                        winDays = 0; lossDays = 0; breakEvenDays = 0;
                        bestDayPnl = 0; worstDayPnl = 0;
                        avgWinDay = 0; avgLossDay = 0;
                    }
                }

                // Safe DOM element access with fallback
                const dailyPerformanceElement = document.getElementById('daily-performance-metrics');
                if (dailyPerformanceElement) {
                    dailyPerformanceElement.innerHTML = `
                        <div class="text-left mb-2">
                            <div class="text-2xl font-bold mb-1">
                                <span class="text-green-500">${winDays}</span> / 
                                <span class="text-red-500">${lossDays}</span> / 
                                <span style="color: var(--text-primary);">${breakEvenDays}</span>
                            </div>
                            <div class="text-sm" style="color: var(--text-muted);">Win / Loss / Break Even Days</div>
                        </div>
                        <div class="grid grid-cols-2 gap-1.5">
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Best Day</div>
                                <div class="text-sm font-semibold text-green-500">${window.utils.formatCurrency(bestDayPnl)}</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Worst Day</div>
                                <div class="text-sm font-semibold text-red-500">${window.utils.formatCurrency(worstDayPnl)}</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Avg Win Day</div>
                                <div class="text-sm font-semibold text-green-500">${window.utils.formatCurrency(avgWinDay)}</div>
                            </div>
                            <div class="p-1.5 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="text-xs mb-0.5" style="color: var(--text-secondary);">Avg Loss Day</div>
                                <div class="text-sm font-semibold text-red-500">${window.utils.formatCurrency(-avgLossDay)}</div>
                            </div>
                        </div>
                    `;
                } else {
                    console.warn('Daily Performance metrics container not found');
                }

                // 3. Trade Execution Card
                // Enhanced data validation and error handling
                let totalCapital = 0;
                let avgCapital = 0;
                
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    try {
                        totalCapital = closed.reduce((s, t) => {
                            try {
                                // Validate trade data before calculation
                                if (!t || typeof t.entry_price !== 'number' || typeof t.quantity !== 'number') {
                                    return s;
                                }
                                
                                const capital = t.entry_price * t.quantity;
                                return isFinite(capital) ? s + capital : s;
                            } catch (e) {
                                return s;
                            }
                        }, 0);
                        
                        avgCapital = isFinite(totalCapital) ? totalCapital / closed.length : 0;
                    } catch (e) {
                        console.warn('Error calculating total capital:', e);
                        totalCapital = 0;
                        avgCapital = 0;
                    }
                }

                // Safe array access with validation for most profitable strategy
                let mostProfitableStrategy = null;
                if (byStrategy && typeof byStrategy === 'object') {
                    try {
                        const strategyEntries = Object.entries(byStrategy);
                        if (strategyEntries.length > 0) {
                            mostProfitableStrategy = [...strategyEntries].sort((a, b) => b[1] - a[1])[0];
                        }
                    } catch (e) {
                        console.warn('Error calculating most profitable strategy:', e);
                    }
                }
                
                // Calculate consecutive wins/losses with safe data handling
                let maxConsecutiveWins = 0, maxConsecutiveLosses = 0;
                let currentWins = 0, currentLosses = 0;
                
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    try {
                        // Safely sort trades with date validation
                        const sortedTrades = closed
                            .filter(t => {
                                // Validate trade and exit_date before sorting
                                if (!t || !t.exit_date || typeof t.exit_date !== 'string') {
                                    return false;
                                }
                                const dateObj = new Date(t.exit_date);
                                return !isNaN(dateObj.getTime());
                            })
                            .sort((a, b) => {
                                try {
                                    const dateA = new Date(a.exit_date);
                                    const dateB = new Date(b.exit_date);
                                    return dateA - dateB;
                                } catch (e) {
                                    return 0;
                                }
                            });
                        
                        sortedTrades.forEach(t => {
                            try {
                                // Safely calculate PnL with data validation
                                if (typeof t.exit_price === 'number' && 
                                    typeof t.entry_price === 'number' && 
                                    typeof t.quantity === 'number' && 
                                    t.quantity > 0) {
                                    
                                    const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                    
                                    if (isFinite(pnl)) {
                                        if (pnl > 0) {
                                            currentWins++;
                                            currentLosses = 0;
                                            maxConsecutiveWins = Math.max(maxConsecutiveWins, currentWins);
                                        } else if (pnl < 0) {
                                            currentLosses++;
                                            currentWins = 0;
                                            maxConsecutiveLosses = Math.max(maxConsecutiveLosses, currentLosses);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('Error processing trade for consecutive calculation:', e);
                            }
                        });
                    } catch (e) {
                        console.warn('Error calculating consecutive wins/losses:', e);
                    }
                }

                // Calculate average time in trade with safe data handling
                let totalTimeInTrade = 0;
                let validTrades = 0;
                
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    closed.forEach(t => {
                        try {
                            // Validate trade and dates before calculation
                            if (!t || !t.entry_date || !t.exit_date || 
                                typeof t.entry_date !== 'string' || typeof t.exit_date !== 'string') {
                                return;
                            }
                            
                            const entryTime = new Date(t.entry_date);
                            const exitTime = new Date(t.exit_date);
                            
                            // Validate dates
                            if (isNaN(entryTime.getTime()) || isNaN(exitTime.getTime())) {
                                return;
                            }
                            
                            const timeDiff = exitTime - entryTime; // in milliseconds
                            
                            // Validate time difference
                            if (isFinite(timeDiff) && timeDiff >= 0) {
                                const minutesDiff = timeDiff / (1000 * 60); // convert to minutes
                                if (isFinite(minutesDiff) && minutesDiff >= 0) {
                                    totalTimeInTrade += minutesDiff;
                                    validTrades++;
                                }
                            }
                        } catch (e) {
                            console.warn('Error calculating time in trade for trade:', e);
                        }
                    });
                }
                
                const avgTimeInTrade = validTrades > 0 ? totalTimeInTrade / validTrades : 0;

                // Safe DOM element access with fallback
                const tradeExecutionElement = document.getElementById('trade-execution-metrics');
                if (tradeExecutionElement) {
                    tradeExecutionElement.innerHTML = `
                        ${createMetricRow('Total Trades', closed ? closed.length : 0)}
                        ${createMetricRow('Avg Capital Used', window.utils.formatCurrency(avgCapital))}
                        ${createMetricRow('Most Profitable Strategy', mostProfitableStrategy ? mostProfitableStrategy[0] : '—')}
                        ${createMetricRow('Consecutive Wins', maxConsecutiveWins, 'text-green-500')}
                        ${createMetricRow('Consecutive Losses', maxConsecutiveLosses, 'text-red-500')}
                        ${createMetricRow('Avg. Time in Trade', avgTimeInTrade > 0 ? `${avgTimeInTrade.toFixed(1)} mins` : '—')}
                    `;
                } else {
                    console.warn('Trade Execution metrics container not found');
                }

                // 4. Time Metrics Card
                const tradingDays = byDay && typeof byDay === 'object' ? Object.keys(byDay).length : 0;
                const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const byWeekday = {};
                
                // Enhanced data validation and error handling
                if (byDay && typeof byDay === 'object' && Object.keys(byDay).length > 0) {
                    Object.entries(byDay).forEach(([date, pnl]) => {
                        try {
                            // Validate date and pnl
                            if (!date || typeof date !== 'string' || typeof pnl !== 'number') {
                                return;
                            }
                            
                            const dateObj = new Date(date);
                            if (isNaN(dateObj.getTime())) {
                                return;
                            }
                            
                            const dayName = weekdays[dateObj.getDay()];
                            if (dayName && isFinite(pnl)) {
                                byWeekday[dayName] = (byWeekday[dayName] || 0) + pnl;
                            }
                        } catch (e) {
                            console.warn('Error processing date for time metrics:', date, e);
                        }
                    });
                }

                // Safe array access with validation
                const weekdayEntries = Object.entries(byWeekday);
                const mostProfitableDay = weekdayEntries.length > 0 ? 
                    [...weekdayEntries].sort((a, b) => b[1] - a[1])[0] : null;
                const leastProfitableDay = weekdayEntries.length > 0 ? 
                    [...weekdayEntries].sort((a, b) => a[1] - b[1])[0] : null;

                // Calculate consecutive win/loss days with safe data handling
                let maxConsecutiveWinDays = 0, maxConsecutiveLossDays = 0;
                let currentWinDays = 0, currentLossDays = 0;
                
                if (byDay && typeof byDay === 'object' && Object.keys(byDay).length > 0) {
                    try {
                        const sortedEntries = Object.entries(byDay)
                            .filter(([date, pnl]) => {
                                // Validate date and pnl before sorting
                                if (!date || typeof date !== 'string' || typeof pnl !== 'number') {
                                    return false;
                                }
                                const dateObj = new Date(date);
                                return !isNaN(dateObj.getTime()) && isFinite(pnl);
                            })
                            .sort((a, b) => {
                                try {
                                    const dateA = new Date(a[0]);
                                    const dateB = new Date(b[0]);
                                    return dateA - dateB;
                                } catch (e) {
                                    return 0;
                                }
                            });
                        
                        sortedEntries.forEach(([_, pnl]) => {
                            if (isFinite(pnl)) {
                                if (pnl > 0) {
                                    currentWinDays++;
                                    currentLossDays = 0;
                                    maxConsecutiveWinDays = Math.max(maxConsecutiveWinDays, currentWinDays);
                                } else if (pnl < 0) {
                                    currentLossDays++;
                                    currentWinDays = 0;
                                    maxConsecutiveLossDays = Math.max(maxConsecutiveLossDays, currentLossDays);
                                }
                            }
                        });
                    } catch (e) {
                        console.warn('Error calculating consecutive days:', e);
                    }
                }

                // Safe DOM element access with fallback
                const timeMetricsElement = document.getElementById('time-metrics');
                if (timeMetricsElement) {
                    timeMetricsElement.innerHTML = `
                        ${createMetricRow('Trading Days', tradingDays)}
                        ${createMetricRow('Consecutive Win Days', maxConsecutiveWinDays, 'text-green-500')}
                        ${createMetricRow('Consecutive Loss Days', maxConsecutiveLossDays, 'text-red-500')}
                        ${createMetricRow('Most Profitable Day', mostProfitableDay ? mostProfitableDay[0] : '—', 'text-green-500')}
                        ${createMetricRow('Least Profitable Day', leastProfitableDay ? leastProfitableDay[0] : '—', 'text-red-500')}
                    `;
                } else {
                    console.warn('Time Metrics container not found');
                }

                // 5. Setup Effectiveness Card - Top 5 Strategies by Win Rate
                const strategyStats = {};
                
                // Enhanced data validation and error handling
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    closed.forEach(t => {
                        try {
                            // Validate trade object
                            if (!t || typeof t !== 'object') {
                                return;
                            }
                            
                            const strategy = t.strategy || 'Other';
                            if (!strategyStats[strategy]) {
                                strategyStats[strategy] = { total: 0, wins: 0, totalPnl: 0 };
                            }
                            strategyStats[strategy].total++;
                            
                            // Safely calculate P&L with comprehensive validation
                            let pnl = 0;
                            const isPartialExit = t.exit_quantity && t.exit_quantity > 0 && t.exit_quantity < t.quantity;
                            
                            if (isPartialExit) {
                                // For partial trades, safely use the calculated net P&L
                                try {
                                    if (typeof calculateNetPnl === 'function') {
                                        const calculatedPnl = calculateNetPnl(t);
                                        pnl = isFinite(calculatedPnl) ? calculatedPnl : 0;
                                    } else {
                                        // Fallback calculation if function doesn't exist
                                        pnl = 0;
                                    }
                                } catch (e) {
                                    pnl = 0;
                                }
                            } else {
                                // For full trades, calculate with validation
                                if (typeof t.exit_price === 'number' && 
                                    typeof t.entry_price === 'number' && 
                                    typeof t.quantity === 'number' && 
                                    t.quantity > 0) {
                                    
                                    const grossPnl = (t.exit_price - t.entry_price) * t.quantity;
                                    const charges = (t.brokerage || 0) + (t.other_fees || 0);
                                    
                                    // Validate calculations
                                    if (isFinite(grossPnl) && isFinite(charges)) {
                                        pnl = grossPnl - charges;
                                        pnl = isFinite(pnl) ? pnl : 0;
                                    } else {
                                        pnl = 0;
                                    }
                                } else {
                                    pnl = 0;
                                }
                            }
                            
                            // Safe PnL accumulation
                            if (isFinite(pnl)) {
                                strategyStats[strategy].totalPnl += pnl;
                                if (pnl > 0) strategyStats[strategy].wins++;
                            }
                        } catch (e) {
                            console.warn('Error processing trade for setup effectiveness:', e);
                        }
                    });
                }

                // Safe calculation of strategy effectiveness with division by zero protection
                const strategyEffectiveness = Object.keys(strategyStats).map(strategy => {
                    try {
                        const stats = strategyStats[strategy];
                        const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                        
                        return {
                            strategy: strategy,
                            winRate: isFinite(winRate) ? winRate : 0,
                            total: stats.total,
                            wins: stats.wins,
                            totalPnl: isFinite(stats.totalPnl) ? stats.totalPnl : 0
                        };
                    } catch (e) {
                        return {
                            strategy: strategy,
                            winRate: 0,
                            total: 0,
                            wins: 0,
                            totalPnl: 0
                        };
                    }
                }).sort((a, b) => b.winRate - a.winRate).slice(0, 5); // Top 5 strategies

                // Safe DOM element access with fallback
                const setupEffectivenessElement = document.getElementById('setup-effectiveness-metrics');
                if (setupEffectivenessElement) {
                    setupEffectivenessElement.innerHTML = strategyEffectiveness.length > 0 
                        ? strategyEffectiveness
                            .map(({ strategy, winRate, total, wins, totalPnl }) => {
                                const pnlColor = totalPnl >= 0 ? 'text-green-500' : 'text-red-500';
                                const winRateColor = winRate >= 50 ? 'text-green-500' : 'text-red-500';
                                return `
                                    <div class="flex justify-between items-center">
                                        <div>
                                            <div class="text-sm font-medium" style="color: var(--text-primary);">${strategy}</div>
                                            <div class="text-xs" style="color: var(--text-secondary);">${wins}/${total} trades</div>
                                        </div>
                                        <div class="text-right">
                                            <div class="text-sm font-semibold ${winRateColor}">${winRate.toFixed(1)}%</div>
                                            <div class="text-xs ${pnlColor}">${window.utils.formatCurrency(totalPnl)}</div>
                                        </div>
                                    </div>
                                `;
                            })
                            .join('')
                        : '<div class="text-sm text-center py-4" style="color: var(--text-muted);">No strategy data available</div>';
                } else {
                    console.warn('Setup Effectiveness metrics container not found');
                }

                // 6. Symbol Frequency Card
                const symbolStats = {};
                
                // Enhanced data validation and error handling
                if (closed && Array.isArray(closed) && closed.length > 0) {
                    closed.forEach(t => {
                        try {
                            // Validate trade object
                            if (!t || typeof t !== 'object') {
                                return;
                            }
                            
                            const symbol = t.asset || 'Unknown';
                            if (!symbolStats[symbol]) {
                                symbolStats[symbol] = { total: 0, wins: 0, pnl: 0 };
                            }
                            symbolStats[symbol].total++;
                            
                            // Safely calculate PnL with data validation
                            if (typeof t.exit_price === 'number' && 
                                typeof t.entry_price === 'number' && 
                                typeof t.quantity === 'number' && 
                                t.quantity > 0) {
                                
                                const pnl = (t.exit_price - t.entry_price) * t.quantity;
                                
                                // Validate PnL calculation result
                                if (isFinite(pnl)) {
                                    symbolStats[symbol].pnl += pnl;
                                    if (pnl > 0) symbolStats[symbol].wins++;
                                }
                            }
                        } catch (e) {
                            console.warn('Error processing trade for symbol frequency:', e);
                        }
                    });
                }

                // Safe calculation of symbol frequency with division by zero protection
                const symbolFrequency = Object.entries(symbolStats)
                    .map(([symbol, stats]) => {
                        try {
                            const percentage = closed.length > 0 ? (stats.total / closed.length) * 100 : 0;
                            const winRate = stats.total > 0 ? (stats.wins / stats.total) * 100 : 0;
                            
                            return {
                                symbol,
                                percentage: isFinite(percentage) ? percentage : 0,
                                pnl: isFinite(stats.pnl) ? stats.pnl : 0,
                                winRate: isFinite(winRate) ? winRate : 0
                            };
                        } catch (e) {
                            return {
                                symbol,
                                percentage: 0,
                                pnl: 0,
                                winRate: 0
                            };
                        }
                    })
                    .sort((a, b) => b.percentage - a.percentage);

                // Safe array access with validation
                const mostTraded = symbolFrequency.length > 0 ? symbolFrequency[0] : null;
                
                // Create copies for sorting to avoid modifying original array
                const mostProfitable = symbolFrequency.length > 0 ? 
                    [...symbolFrequency].sort((a, b) => b.pnl - a.pnl)[0] : null;
                const leastProfitable = symbolFrequency.length > 0 ? 
                    [...symbolFrequency].sort((a, b) => a.pnl - b.pnl)[0] : null;
                const highestWinRate = symbolFrequency.length > 0 ? 
                    [...symbolFrequency].sort((a, b) => b.winRate - a.winRate)[0] : null;
                const lowestWinRate = symbolFrequency.length > 0 ? 
                    [...symbolFrequency].sort((a, b) => a.winRate - b.winRate)[0] : null;

                // Safe DOM element access with fallback
                const symbolFrequencyElement = document.getElementById('symbol-frequency-metrics');
                if (symbolFrequencyElement) {
                    symbolFrequencyElement.innerHTML = `
                        ${createMetricRow('Most Traded', mostTraded ? `${mostTraded.symbol} (${mostTraded.percentage.toFixed(0)}%)` : '—')}
                        ${createMetricRow('Most Profitable', mostProfitable ? `${mostProfitable.symbol} (${window.utils.formatCurrency(mostProfitable.pnl)})` : '—', 'text-green-500')}
                        ${createMetricRow('Least Profitable', leastProfitable ? `${leastProfitable.symbol} (${window.utils.formatCurrency(leastProfitable.pnl)})` : '—', 'text-red-500')}
                        ${createMetricRow('Highest Win Rate', highestWinRate ? `${highestWinRate.symbol} (${highestWinRate.winRate.toFixed(1)}%)` : '—', 'text-green-500')}
                        ${createMetricRow('Lowest Win Rate', lowestWinRate ? `${lowestWinRate.symbol} (${lowestWinRate.winRate.toFixed(1)}%)` : '—', 'text-red-500')}
                    `;
                } else {
                    console.warn('Symbol Frequency metrics container not found');
                }

                // 7. Capital Usage Card - Flawless Implementation
                const capitalUsageElement = document.getElementById('capital-usage-metrics');
                if (capitalUsageElement) {
                    if (closed.length === 0) {
                        // Handle empty trades case
                        capitalUsageElement.innerHTML = `
                            ${createMetricRow('Maximum', '—')}
                            ${createMetricRow('Minimum', '—')}
                            ${createMetricRow('Average', '—')}
                            ${createMetricRow('P&L at Max Capital', '—')}
                            ${createMetricRow('P&L at Min Capital', '—')}
                        `;
                    } else {
                    // Filter valid trades with proper data validation
                    const validTrades = closed.filter(t => 
                        t.entry_price && 
                        t.quantity && 
                        !isNaN(t.entry_price) && 
                        !isNaN(t.quantity) && 
                        t.entry_price > 0 && 
                        t.quantity > 0
                    );
                    
                        if (validTrades.length === 0) {
                            // Handle case where no trades have valid data
                            capitalUsageElement.innerHTML = `
                                ${createMetricRow('Maximum', '—')}
                                ${createMetricRow('Minimum', '—')}
                                ${createMetricRow('Average', '—')}
                                ${createMetricRow('P&L at Max Capital', '—')}
                                ${createMetricRow('P&L at Min Capital', '—')}
                            `;
                        } else {
                        // Calculate capital usage with validated data
                        const capitalUsed = validTrades.map(t => t.entry_price * t.quantity);
                        const maxCapital = Math.max(...capitalUsed);
                        const minCapital = Math.min(...capitalUsed);
                        const avgCapitalUsed = capitalUsed.reduce((a, b) => a + b, 0) / capitalUsed.length;
                        
                        // Find trades with max and min capital (handle multiple trades with same capital)
                        const maxCapitalTrades = validTrades.filter(t => (t.entry_price * t.quantity) === maxCapital);
                        const minCapitalTrades = validTrades.filter(t => (t.entry_price * t.quantity) === minCapital);
                        
                        // Find the most profitable trade at max capital (best performance)
                        const maxCapitalTrade = maxCapitalTrades.reduce((best, current) => {
                            const bestPnl = calculateNetPnl(best);
                            const currentPnl = calculateNetPnl(current);
                            return currentPnl > bestPnl ? current : best;
                        }, maxCapitalTrades[0]);
                        
                        // Find the most profitable trade at min capital (best performance)
                        const minCapitalTrade = minCapitalTrades.reduce((best, current) => {
                            const bestPnl = calculateNetPnl(best);
                            const currentPnl = calculateNetPnl(current);
                            return currentPnl > bestPnl ? current : best;
                        }, minCapitalTrades[0]);
                        
                        // Calculate P&L using consistent calculateNetPnl function
                        const pnlAtMaxCapital = calculateNetPnl(maxCapitalTrade);
                        const pnlAtMinCapital = calculateNetPnl(minCapitalTrade);

                            capitalUsageElement.innerHTML = `
                                ${createMetricRow('Maximum', window.utils.formatCurrency(maxCapital))}
                                ${createMetricRow('Minimum', window.utils.formatCurrency(minCapital))}
                                ${createMetricRow('Average', window.utils.formatCurrency(avgCapitalUsed))}
                                ${createMetricRow('P&L at Max Capital', window.utils.formatCurrency(pnlAtMaxCapital), pnlAtMaxCapital >= 0 ? 'text-green-500' : 'text-red-500')}
                                ${createMetricRow('P&L at Min Capital', window.utils.formatCurrency(pnlAtMinCapital), pnlAtMinCapital >= 0 ? 'text-green-500' : 'text-red-500')}
                            `;
                        }
                    }
                } else {
                    console.warn('Capital Usage metrics container not found');
                }

                // 8. Quantity Analysis Card - Flawless Implementation
                const quantityAnalysisElement = document.getElementById('quantity-analysis-metrics');
                if (quantityAnalysisElement) {
                    if (closed.length === 0) {
                        // Handle empty trades case
                        quantityAnalysisElement.innerHTML = `
                            ${createMetricRow('Maximum', '—')}
                            ${createMetricRow('Minimum', '—')}
                            ${createMetricRow('Average', '—')}
                            ${createMetricRow('P&L at Max Qty', '—')}
                            ${createMetricRow('P&L at Min Qty', '—')}
                        `;
                    } else {
                    // Filter valid trades with proper data validation
                    const validTrades = closed.filter(t => 
                        t.quantity && 
                        !isNaN(t.quantity) && 
                        t.quantity > 0
                    );
                    
                        if (validTrades.length === 0) {
                            // Handle case where no trades have valid quantity data
                            quantityAnalysisElement.innerHTML = `
                                ${createMetricRow('Maximum', '—')}
                                ${createMetricRow('Minimum', '—')}
                                ${createMetricRow('Average', '—')}
                                ${createMetricRow('P&L at Max Qty', '—')}
                                ${createMetricRow('P&L at Min Qty', '—')}
                            `;
                        } else {
                        // Calculate quantity analysis with validated data
                        const quantities = validTrades.map(t => t.quantity);
                        const maxQty = Math.max(...quantities);
                        const minQty = Math.min(...quantities);
                        const avgQty = quantities.reduce((a, b) => a + b, 0) / quantities.length;
                        
                        // Find trades with max and min quantity (handle multiple trades with same quantity)
                        const maxQtyTrades = validTrades.filter(t => t.quantity === maxQty);
                        const minQtyTrades = validTrades.filter(t => t.quantity === minQty);
                        
                        // Find the most profitable trade at max quantity (best performance)
                        const maxQtyTrade = maxQtyTrades.reduce((best, current) => {
                            const bestPnl = calculateNetPnl(best);
                            const currentPnl = calculateNetPnl(current);
                            return currentPnl > bestPnl ? current : best;
                        }, maxQtyTrades[0]);
                        
                        // Find the most profitable trade at min quantity (best performance)
                        const minQtyTrade = minQtyTrades.reduce((best, current) => {
                            const bestPnl = calculateNetPnl(best);
                            const currentPnl = calculateNetPnl(current);
                            return currentPnl > bestPnl ? current : best;
                        }, minQtyTrades[0]);
                        
                        // Calculate P&L using consistent calculateNetPnl function
                        const pnlAtMaxQty = calculateNetPnl(maxQtyTrade);
                        const pnlAtMinQty = calculateNetPnl(minQtyTrade);

                            quantityAnalysisElement.innerHTML = `
                                ${createMetricRow('Maximum', maxQty.toLocaleString())}
                                ${createMetricRow('Minimum', minQty.toLocaleString())}
                                ${createMetricRow('Average', Math.round(avgQty).toLocaleString())}
                                ${createMetricRow('P&L at Max Qty', window.utils.formatCurrency(pnlAtMaxQty), pnlAtMaxQty >= 0 ? 'text-green-500' : 'text-red-500')}
                                ${createMetricRow('P&L at Min Qty', window.utils.formatCurrency(pnlAtMinQty), pnlAtMinQty >= 0 ? 'text-green-500' : 'text-red-500')}
                            `;
                        }
                    }
                } else {
                    console.warn('Quantity Analysis metrics container not found');
                }

                // 9. Weekday Avg R:R Card
                const weekdayRR = {};
                
                // Enhanced data validation and error handling
                if (byWeekday && typeof byWeekday === 'object' && closed && Array.isArray(closed)) {
                    Object.entries(byWeekday).forEach(([day, pnl]) => {
                        try {
                            // Safely filter trades for this weekday with comprehensive validation
                            const dayTrades = closed.filter(t => {
                                // Validate trade object and exit_date
                                if (!t || !t.exit_date || typeof t.exit_date !== 'string') {
                                    return false;
                                }
                                
                                try {
                                    const exitDate = new Date(t.exit_date);
                                    if (isNaN(exitDate.getTime())) {
                                        return false;
                                    }
                                    
                                    const dayOfWeek = weekdays[exitDate.getDay()];
                                    return dayOfWeek === day;
                                } catch (e) {
                                    return false;
                                }
                            });
                            
                            if (dayTrades.length > 0) {
                                // Safely calculate individual R:R ratios with comprehensive validation
                                const individualRRs = dayTrades.map(trade => {
                                    try {
                                        // Validate trade data before calculation
                                        if (!trade || 
                                            typeof trade.exit_price !== 'number' || 
                                            typeof trade.entry_price !== 'number' || 
                                            !trade.quantity || 
                                            typeof trade.quantity !== 'number') {
                                            return 0; // Return 0 for invalid trades
                                        }
                                        
                                        const tradePnL = (trade.exit_price - trade.entry_price) * trade.quantity;
                                        
                                        // Validate PnL calculation result
                                        if (!isFinite(tradePnL)) {
                                            return 0;
                                        }
                                        
                                        // Robust R:R calculation using actual trade data
                                        // This follows the same pattern as other R:R calculations in the codebase
                                        
                                        const entryPrice = trade.entry_price || 0;
                                        const stopLoss = trade.stop_loss || (entryPrice * 0.98); // Default 2% stop loss
                                        const target = trade.target || trade.target_price || (entryPrice * 1.02); // Default 2% target
                                        
                                        const risk = Math.abs(entryPrice - stopLoss);
                                        
                                        // Calculate actual R:R based on actual performance vs intended risk
                                        if (risk > 0) {
                                            if (tradePnL > 0) {
                                                // Winning trade: R:R = actual_profit / intended_risk
                                                const actualRR = tradePnL / risk;
                                                // Cap extreme values to prevent unrealistic R:R ratios
                                                return isFinite(actualRR) ? Math.min(actualRR, 50) : 0;
                                            } else if (tradePnL < 0) {
                                                // Losing trade: R:R = -actual_loss / intended_risk
                                                const actualLoss = Math.abs(tradePnL);
                                                const actualRR = -(actualLoss / risk);
                                                // Cap extreme values to prevent unrealistic R:R ratios
                                                return isFinite(actualRR) ? Math.max(actualRR, -50) : 0;
                                            }
                                        }
                                        
                                        return 0;
                                    } catch (e) {
                                        return 0; // Return 0 for any calculation errors
                                    }
                                }).filter(rr => isFinite(rr)); // Filter out invalid R:R ratios (allow negative values for losses)
                                
                                // Safe average calculation with validation
                                if (individualRRs.length > 0) {
                                    const avgRR = individualRRs.reduce((sum, rr) => sum + rr, 0) / individualRRs.length;
                                    weekdayRR[day] = isFinite(avgRR) ? avgRR : 0;
                                } else {
                                    weekdayRR[day] = 0;
                                }
                            } else {
                                weekdayRR[day] = 0;
                            }
                        } catch (e) {
                            console.warn('Error processing weekday R:R for', day, ':', e);
                            weekdayRR[day] = 0;
                        }
                    });
                }

                // Safe DOM element access with fallback
                const weekdayRRElement = document.getElementById('weekday-rr-metrics');
                if (weekdayRRElement) {
                    weekdayRRElement.innerHTML = weekdaysOrder
                        .filter(day => weekdayRR[day] !== undefined)
                        .map(day => {
                            const rr = weekdayRR[day];
                            let colorClass = '';
                            let value = '';
                            if (rr > 1) {
                                colorClass = 'text-green-500';
                                value = `${rr.toFixed(2)}R`;
                            } else if (rr < 0) {
                                colorClass = 'text-red-500';
                                value = `${rr.toFixed(2)}R`;
                            } else {
                                value = `<span style="color: var(--text-primary);">${rr.toFixed(2)}R</span>`;
                            }
                            return createMetricRow(day, value, colorClass);
                        })
                        .join('') || '<div class="text-sm" style="color: var(--text-muted);">No R:R data available</div>';
                } else {
                    console.warn('Weekday R:R metrics container not found');
                }

                // 10. Weekday Win Rate Card
                const weekdayWinRates = {};
                
                // Enhanced data validation and error handling
                if (byWeekday && typeof byWeekday === 'object' && closed && Array.isArray(closed)) {
                    Object.entries(byWeekday).forEach(([day, pnl]) => {
                        try {
                            // Safely filter trades for this weekday with comprehensive validation
                            const dayTrades = closed.filter(t => {
                                // Validate trade object and exit_date
                                if (!t || !t.exit_date || typeof t.exit_date !== 'string') {
                                    return false;
                                }
                                
                                try {
                                    const exitDate = new Date(t.exit_date);
                                    if (isNaN(exitDate.getTime())) {
                                        return false;
                                    }
                                    
                                    const dayOfWeek = weekdays[exitDate.getDay()];
                                    return dayOfWeek === day;
                                } catch (e) {
                                    return false;
                                }
                            });
                            
                            // Safely calculate wins with data validation using consistent P&L calculation
                            const dayWins = dayTrades.filter(t => {
                                try {
                                    // Validate trade data before calculation
                                    if (!t || typeof t.exit_price !== 'number' || typeof t.entry_price !== 'number' || !t.quantity) {
                                        return false;
                                    }
                                    // Use the same calculateNetPnl function used throughout the app for consistency
                                    const pnl = calculateNetPnl(t);
                                    return isFinite(pnl) && pnl > 0;
                                } catch (e) {
                                    return false;
                                }
                            }).length;
                            
                            // Safe calculation with division by zero protection
                            weekdayWinRates[day] = dayTrades.length > 0 ? (dayWins / dayTrades.length) * 100 : 0;
                        } catch (e) {
                            console.warn('Error processing weekday win rate for', day, ':', e);
                            weekdayWinRates[day] = 0;
                        }
                    });
                }

                // Safe DOM element access with fallback
                const weekdayWinRateElement = document.getElementById('weekday-win-rate-metrics');
                if (weekdayWinRateElement) {
                    weekdayWinRateElement.innerHTML = weekdaysOrder
                        .filter(day => weekdayWinRates[day] !== undefined)
                        .map(day => {
                            const winRate = weekdayWinRates[day];
                            const colorClass = winRate >= 50 ? 'text-green-500' : '';
                            const value = winRate >= 50 ? `${winRate.toFixed(0)}%` : `<span style="color: var(--text-primary);">${winRate.toFixed(0)}%</span>`;
                            return createMetricRow(day, value, colorClass);
                        })
                        .join('') || '<div class="text-sm" style="color: var(--text-muted);">No win rate data available</div>';
                } else {
                    console.warn('Weekday Win Rate metrics container not found');
                }

                // 11. Daily Trade Activity Card
                const tradesPerDay = {};
                
                // Enhanced data validation and error handling
                if (closed && Array.isArray(closed)) {
                    closed.forEach(t => {
                        // Validate trade object and exit_date
                        if (t && t.exit_date && typeof t.exit_date === 'string') {
                            try {
                                const date = t.exit_date.split('T')[0];
                                // Additional validation for date format
                                if (date && date.length >= 10) {
                                    tradesPerDay[date] = (tradesPerDay[date] || 0) + 1;
                                }
                            } catch (e) {
                                // Silently skip invalid dates to prevent crashes
                                console.warn('Invalid exit_date format:', t.exit_date);
                            }
                        }
                    });
                }
                
                const dailyTradeCounts = Object.values(tradesPerDay);
                const avgTradesPerDay = dailyTradeCounts.length ? dailyTradeCounts.reduce((a, b) => a + b, 0) / dailyTradeCounts.length : 0;
                // Fixed Math.max edge case for empty arrays
                const maxTradesInDay = dailyTradeCounts.length > 0 ? Math.max(...dailyTradeCounts) : 0;
                const daysWithOneTrade = dailyTradeCounts.filter(count => count === 1).length;
                const overtradingDays = dailyTradeCounts.filter(count => count > 7).length;

                // Safe DOM element access with fallback
                const dailyActivityElement = document.getElementById('daily-trade-activity-metrics');
                if (dailyActivityElement) {
                    dailyActivityElement.innerHTML = `
                        ${createMetricRow('Avg Trades Per Day', avgTradesPerDay.toFixed(1))}
                        ${createMetricRow('Max Trades in a Day', maxTradesInDay)}
                        ${createMetricRow('Days With Only 1 Trade', daysWithOneTrade)}
                        ${createMetricRow('Overtrading Days (>7 trades)', overtradingDays, overtradingDays > 0 ? 'text-red-500' : 'text-green-500')}
                    `;
                } else {
                    console.warn('Daily Trade Activity metrics container not found');
                }

                // 12. Emotional State Card
                const emotionalStateStats = {};
                
                // Enhanced data validation and error handling
                if (closed && Array.isArray(closed)) {
                    closed.forEach(t => {
                        try {
                            // Validate trade object and emotionalState property
                            if (t && t.emotionalState && typeof t.emotionalState === 'string') {
                                const state = t.emotionalState.trim();
                                if (state && state.length > 0) {
                                    emotionalStateStats[state] = (emotionalStateStats[state] || 0) + 1;
                                }
                            }
                        } catch (e) {
                            console.warn('Error processing emotional state for trade:', e);
                        }
                    });
                }
                
                // Calculate total trades with emotional state data
                const totalTradesWithEmotionalState = Object.values(emotionalStateStats).reduce((sum, count) => {
                    try {
                        return isFinite(count) ? sum + count : sum;
                    } catch (e) {
                        return sum;
                    }
                }, 0);
                
                // Get top 5 emotional states with safe sorting
                const topEmotionalStates = Object.entries(emotionalStateStats)
                    .filter(([state, count]) => {
                        try {
                            return state && typeof state === 'string' && isFinite(count) && count > 0;
                        } catch (e) {
                            return false;
                        }
                    })
                    .sort(([,a], [,b]) => {
                        try {
                            return isFinite(a) && isFinite(b) ? b - a : 0;
                        } catch (e) {
                            return 0;
                        }
                    })
                    .slice(0, 5);
                
                // Safe DOM element access with fallback
                const emotionalStateElement = document.getElementById('emotional-state-metrics');
                if (emotionalStateElement) {
                    if (topEmotionalStates.length === 0) {
                        emotionalStateElement.innerHTML = `
                            <div class="text-center text-sm" style="color: var(--text-secondary);">
                                No emotional state data available
                            </div>
                        `;
                    } else {
                        emotionalStateElement.innerHTML = topEmotionalStates.map(([state, count]) => {
                            try {
                                const percentage = totalTradesWithEmotionalState > 0 ? 
                                    ((count / totalTradesWithEmotionalState) * 100).toFixed(0) : 0;
                                return createMetricRow(state, `${percentage}%`);
                            } catch (e) {
                                console.warn('Error calculating percentage for emotional state:', state, e);
                                return createMetricRow(state, '0%');
                            }
                        }).join('');
                    }
                } else {
                    console.warn('Emotional State metrics container not found');
                }

                // Render Risk-Adjusted Performance Metrics
                const riskAdjustedElement = document.getElementById('risk-adjusted-performance-metrics');
                if (riskAdjustedElement) {
                    const sharpeData = calculateSharpeRatio(closed);
                    const sortinoData = calculateSortinoRatio(closed);
                    
                    const sharpeValue = sharpeData.value.toFixed(2);
                    const sortinoValue = sortinoData.value.toFixed(2);
                    
                    const sharpeColor = sharpeData.status === 'good' ? 'text-green-500' : 
                                      sharpeData.status === 'moderate' ? 'text-yellow-500' : 'text-red-500';
                    const sortinoColor = sortinoData.status === 'good' ? 'text-green-500' : 
                                       sortinoData.status === 'moderate' ? 'text-yellow-500' : 'text-red-500';
                    
                    riskAdjustedElement.innerHTML = `
                        ${createMetricRow('Sharpe Ratio (Annualized)', sharpeValue, sharpeColor)}
                        ${createMetricRow('Sortino Ratio (Annualized)', sortinoValue, sortinoColor)}
                    `;
                } else {
                    console.warn('Risk-Adjusted Performance metrics container not found');
                }

                // Render Winning Trade Analysis (MAE) Metrics
                const winningTradeElement = document.getElementById('winning-trade-analysis-metrics');
                if (winningTradeElement) {
                    const maeData = calculateAverageMAE(closed);
                    
                    // Debug logging
                    console.log('MAE Calculation Debug:', {
                        totalTrades: closed.length,
                        maeData: maeData,
                        winningTrades: closed.filter(t => {
                            const pnl = calculateNetPnl(t);
                            return isFinite(pnl) && pnl > 0;
                        }).length
                    });
                    
                    const maeValue = window.utils.formatCurrency(Math.abs(maeData.value));
                    const maeColor = maeData.status === 'good' ? 'text-green-500' : 
                                   maeData.status === 'moderate' ? 'text-yellow-500' : 'text-red-500';
                    
                    winningTradeElement.innerHTML = `
                        ${createMetricRow('Average MAE', `-${maeValue}`, maeColor)}
                        <div class="text-xs mt-2" style="color: var(--text-muted);">
                            This is the average 'pain' your winning trades went through before becoming profitable.
                        </div>
                    `;
                } else {
                    console.warn('Winning Trade Analysis metrics container not found');
                }

                // Render Losing Trade Analysis (MFE) Metrics
                const losingTradeElement = document.getElementById('losing-trade-analysis-metrics');
                if (losingTradeElement) {
                    const mfeData = calculateAverageMFE(closed);
                    
                    // Debug logging
                    console.log('MFE Calculation Debug:', {
                        totalTrades: closed.length,
                        mfeData: mfeData,
                        losingTrades: closed.filter(t => {
                            const pnl = calculateNetPnl(t);
                            return isFinite(pnl) && pnl < 0;
                        }).length
                    });
                    
                    const mfeValue = window.utils.formatCurrency(mfeData.value);
                    const mfeColor = mfeData.status === 'high-mfe' ? 'text-red-500' : 
                                   mfeData.status === 'moderate-mfe' ? 'text-yellow-500' : 'text-green-500';
                    
                    losingTradeElement.innerHTML = `
                        ${createMetricRow('Average MFE', `+${mfeValue}`, mfeColor)}
                        <div class="text-xs mt-2" style="color: var(--text-muted);">
                            This is the average unrealized profit your losing trades had before turning negative.
                        </div>
                    `;
                } else {
                    console.warn('Losing Trade Analysis metrics container not found');
                }

                // Render Cost Analysis Metrics
                renderCostAnalysis(closed);

                // Render Financial Impact of Mistakes
                renderMistakeImpact(closed);

                // Render Detailed Performance by Day of the Week
                renderDayPerformance(closed);

                // Render Trade Duration Analysis
                renderTradeDuration(closed);

                // Render Maximum Drawdown
                renderMaxDrawdown(closed);

                // Render R-Value Analysis
                renderRValue(closed);

                // Render P&L by Quantity Traded Tier
                renderQuantityTier(closed);

            } catch (e) {
                console.error('renderAdvancedMetrics error', e);
            }
        };

        // Render Maximum Drawdown
        const renderMaxDrawdown = (trades) => {
            try {
                const maxDrawdownAmount = calculateMaxDrawdown(trades);
                const drawdownElement = document.getElementById('max-drawdown-metrics');
                
                if (drawdownElement) {
                    const formatCurrency = (value) => {
                        const sign = value >= 0 ? '' : '-';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    // Calculate percentage based on starting balance (assuming 100,000 as default)
                    const startingBalance = 100000;
                    const maxDrawdownPercentage = startingBalance > 0 ? (maxDrawdownAmount / startingBalance) * 100 : 0;
                    
                    drawdownElement.innerHTML = `
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Max Drawdown (₹)</span>
                            <span class="text-sm font-medium text-red-500">${window.utils.formatCurrency(maxDrawdownAmount)}</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Max Drawdown (%)</span>
                            <span class="text-sm font-medium text-red-500">${maxDrawdownPercentage.toFixed(2)}%</span>
                        </div>
                        <div class="border-t pt-3 mt-3" style="border-color: var(--border-color);">
                            <p class="text-xs" style="color: var(--text-muted);">This is the largest drop your account experienced from a peak to a subsequent low.</p>
                        </div>
                    `;
                } else {
                    console.warn('Maximum Drawdown metrics container not found');
                }
            } catch (error) {
                console.error('renderMaxDrawdown error', error);
            }
        };

        // Render R-Value Analysis
        const renderRValue = (trades) => {
            try {
                const rValueData = calculateRValue(trades);
                const rValueElement = document.getElementById('r-value-metrics');
                
                if (rValueElement) {
                    const formatRValue = (value) => {
                        const sign = value >= 0 ? '+' : '';
                        return `${sign}${value.toFixed(2)}R`;
                    };
                    
                    rValueElement.innerHTML = `
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Average R-Value</span>
                            <span class="text-sm font-medium" style="color: ${rValueData.avgRValue >= 0 ? '#10b981' : '#ef4444'};">
                                ${formatRValue(rValueData.avgRValue)}
                            </span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Best R-Value</span>
                            <span class="text-sm font-medium text-green-500">${formatRValue(rValueData.bestRValue)}</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Worst R-Value</span>
                            <span class="text-sm font-medium text-red-500">${formatRValue(rValueData.worstRValue)}</span>
                        </div>
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">Total R-Value</span>
                            <span class="text-sm font-medium" style="color: ${rValueData.totalRValue >= 0 ? '#10b981' : '#ef4444'};">
                                ${formatRValue(rValueData.totalRValue)}
                            </span>
                        </div>
                        <div class="border-t pt-3 mt-3" style="border-color: var(--border-color);">
                            <p class="text-xs" style="color: var(--text-muted);">
                                R-Value standardizes trade outcomes as multiples of your initial risk. +2R = made twice your risk, -1R = lost your full risk.
                            </p>
                        </div>
                    `;
                } else {
                    console.warn('R-Value metrics container not found');
                }
            } catch (error) {
                console.error('renderRValue error', error);
            }
        };

        // Render P&L by Quantity Traded Tier
        const renderQuantityTier = (trades) => {
            try {
                const tierData = calculateQuantityTier(trades);
                const tableElement = document.getElementById('quantity-tier-table');
                
                if (tableElement) {
                    const formatCurrency = (value) => {
                        if (value === 0) return '-';
                        const sign = value >= 0 ? '+' : '';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    const formatPercentage = (value) => {
                        return value > 0 ? `${value.toFixed(0)}%` : '-';
                    };
                    
                    tableElement.innerHTML = `
                        <table class="w-full text-xs">
                            <thead>
                                <tr class="border-b" style="border-color: var(--border-color);">
                                    <th class="text-left py-1 px-2 text-xs" style="color: var(--text-secondary);">Quantity Traded</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Trade Count</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total P&L</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Win Rate (%)</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Avg. P&L per Trade</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tierData.map(item => `
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <td class="py-1 px-2 text-xs" style="color: var(--text-primary);">${item.tier}</td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${item.totalTrades > 0 ? item.totalTrades : '-'}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: ${item.totalPnl >= 0 ? '#10b981' : '#ef4444'};">
                                            ${window.utils.formatCurrency(item.totalPnl)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${formatPercentage(item.winRate)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: ${item.avgPnl >= 0 ? '#10b981' : '#ef4444'};">
                                            ${window.utils.formatCurrency(item.avgPnl)}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                } else {
                    console.warn('Quantity Tier table container not found');
                }
            } catch (error) {
                console.error('renderQuantityTier error', error);
            }
        };

        // Render Cost Analysis Metrics
        const renderCostAnalysis = (trades) => {
            try {
                const costData = calculateCostAnalysis(trades);
                const costElement = document.getElementById('cost-analysis-metrics');
                
                if (costElement) {
                    // Helper function to create metric row
                    const createMetricRow = (label, value, color = '') => `
                        <div class="flex justify-between items-center">
                            <span class="text-sm" style="color: var(--text-secondary);">${label}</span>
                            <span class="text-sm font-medium ${color}">${value}</span>
                        </div>
                    `;
                    
                    // Format currency values (preserve sign)
                    const formatCurrency = (value) => {
                        const sign = value >= 0 ? '' : '-';
                        return `₹${sign}${Math.abs(value).toFixed(2)}`;
                    };
                    
                    // Determine colors based on values
                    const grossPnlColor = costData.grossPnl >= 0 ? 'text-green-500' : 'text-red-500';
                    const netPnlColor = costData.netPnl >= 0 ? 'text-green-500' : 'text-red-500';
                    const chargesColor = 'text-red-500';
                    const percentageColor = 'text-gray-500';
                    
                    costElement.innerHTML = `
                        ${createMetricRow('Gross P&L', window.utils.formatCurrency(costData.grossPnl), grossPnlColor)}
                        ${createMetricRow('Total Charges', window.utils.formatCurrency(costData.totalCharges), chargesColor)}
                        ${createMetricRow('Net P&L', window.utils.formatCurrency(costData.netPnl), netPnlColor)}
                        <div class="border-t pt-3 mt-3" style="border-color: var(--border-color);">
                            ${createMetricRow('Charges as % of Gross Profit', `${costData.chargesPercentage.toFixed(1)}%`, percentageColor)}
                        </div>
                    `;
                } else {
                    console.warn('Cost Analysis metrics container not found');
                }
            } catch (error) {
                console.error('renderCostAnalysis error', error);
            }
        };

        // Render Financial Impact of Mistakes
        const renderMistakeImpact = (trades) => {
            try {
                const mistakeData = calculateMistakeImpact(trades);
                const tableElement = document.getElementById('mistake-impact-table');
                
                if (tableElement) {
                    if (mistakeData.length > 0) {
                        const formatCurrency = (value) => {
                            const sign = value >= 0 ? '' : '-';
                            return `${sign}₹${Math.abs(value).toFixed(0)}`;
                        };
                        
                        tableElement.innerHTML = `
                            <table class="w-full text-xs">
                                <thead>
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <th class="text-left py-1 px-2 text-xs" style="color: var(--text-secondary);">Mistake</th>
                                        <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total P&L Impact</th>
                                        <th class="text-right py-1 px-2 text-xs" style="color: var(--text-secondary);">Number of Times<br>Made</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${mistakeData.map(item => `
                                        <tr class="border-b" style="border-color: var(--border-color);">
                                            <td class="py-1 px-2 text-xs" style="color: var(--text-primary);">${item.mistake}</td>
                                            <td class="py-1 px-2 text-center text-xs" style="color: #f97316;">${window.utils.formatCurrency(item.totalImpact)}</td>
                                            <td class="py-1 px-2 text-right text-xs" style="color: var(--text-primary);">${item.count}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        `;
                    } else {
                        tableElement.innerHTML = '<p class="text-center py-4" style="color: var(--text-secondary);">No mistake data available</p>';
                    }
                } else {
                    console.warn('Mistake Impact table container not found');
                }
            } catch (error) {
                console.error('renderMistakeImpact error', error);
            }
        };

        // Render Detailed Performance by Day of the Week
        const renderDayPerformance = (trades) => {
            try {
                const dayData = calculateDayPerformance(trades);
                const tableElement = document.getElementById('day-performance-table');
                
                if (tableElement) {
                    const formatCurrency = (value) => {
                        if (value === 0) return '-';
                        const sign = value >= 0 ? '+' : '';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    const formatPercentage = (value) => {
                        return value > 0 ? `${value.toFixed(0)}%` : '-';
                    };
                    
                    const formatAvgPnl = (value) => {
                        if (value === 0) return '-';
                        const sign = value >= 0 ? '' : '-';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    tableElement.innerHTML = `
                        <table class="w-full text-xs">
                            <thead>
                                <tr class="border-b" style="border-color: var(--border-color);">
                                    <th class="text-left py-1 px-2 text-xs" style="color: var(--text-secondary);">Day</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total P&L</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Win Rate (%)</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Avg. P&L per</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total Trades</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${dayData.map(item => `
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <td class="py-1 px-2 text-xs" style="color: var(--text-primary);">${item.day}</td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: ${item.totalPnl >= 0 ? '#10b981' : '#ef4444'};">
                                            ${window.utils.formatCurrency(item.totalPnl)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${formatPercentage(item.winRate)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${formatAvgPnl(item.avgPnl)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${item.totalTrades > 0 ? item.totalTrades : '-'}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                } else {
                    console.warn('Day Performance table container not found');
                }
            } catch (error) {
                console.error('renderDayPerformance error', error);
            }
        };

        // Render Trade Duration Analysis
        const renderTradeDuration = (trades) => {
            try {
                const durationData = calculateTradeDuration(trades);
                const tableElement = document.getElementById('trade-duration-table');
                
                if (tableElement) {
                    const formatCurrency = (value) => {
                        if (value === 0) return '-';
                        const sign = value >= 0 ? '+' : '';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    const formatPercentage = (value) => {
                        return value > 0 ? `${value.toFixed(0)}%` : '-';
                    };
                    
                    const formatAvgPnl = (value) => {
                        if (value === 0) return '-';
                        const sign = value >= 0 ? '' : '-';
                        return `${sign}₹${Math.abs(value).toFixed(0)}`;
                    };
                    
                    tableElement.innerHTML = `
                        <table class="w-full text-xs">
                            <thead>
                                <tr class="border-b" style="border-color: var(--border-color);">
                                    <th class="text-left py-1 px-2 text-xs" style="color: var(--text-secondary);">Duration Range</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total P&L</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Win Rate (%)</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Total Trades</th>
                                    <th class="text-center py-1 px-2 text-xs" style="color: var(--text-secondary);">Avg. P&L per Trade</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${durationData.map(item => `
                                    <tr class="border-b" style="border-color: var(--border-color);">
                                        <td class="py-1 px-2 text-xs" style="color: var(--text-primary);">${item.duration}</td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: ${item.totalPnl >= 0 ? '#10b981' : '#ef4444'};">
                                            ${window.utils.formatCurrency(item.totalPnl)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${formatPercentage(item.winRate)}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${item.totalTrades > 0 ? item.totalTrades : '-'}
                                        </td>
                                        <td class="py-1 px-2 text-center text-xs" style="color: var(--text-primary);">
                                            ${formatAvgPnl(item.avgPnl)}
                                        </td>
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    `;
                } else {
                    console.warn('Trade Duration table container not found');
                }
            } catch (error) {
                console.error('renderTradeDuration error', error);
            }
        };

        // Optimized statement rendering with caching and performance improvements
        let statementRenderTimeout = null;
        let statementCache = null;
        let statementLastHash = null;
        let statementRendering = false; // Prevent race conditions
        
        const renderStatement = (filters = {}, skipDelay = false) => {
            // Clear previous timeout to prevent multiple rapid renders
            if (statementRenderTimeout) {
                clearTimeout(statementRenderTimeout);
            }
            
            // Skip debounce for theme changes to prevent flicker
            if (skipDelay) {
                try {
                    console.log('renderStatement called (skipDelay) - trades count:', appState.trades?.length || 0, 'ledger count:', appState.ledger?.length || 0);
                    const statementBody = document.getElementById('statement-tbody');
                    if (!statementBody) {
                        console.log('Statement body not found');
                        return;
                    }
                    
                    // Load latest data
                    const trades = Array.isArray(appState.trades) ? appState.trades : [];
                    const ledger = Array.isArray(appState.ledger) ? appState.ledger : [];
                    
                    // Check cache validity
                    const currentHash = performanceCache.getTradesHash(trades) + '_' + performanceCache.getTradesHash(ledger);
                    if (statementCache && statementLastHash === currentHash && Object.keys(filters).length === 0) {
                        statementBody.innerHTML = statementCache;
                        return;
                    }
                    
                    // Render immediately for theme changes
                    window.main.loadStatementData(trades, ledger).then(data => {
                        window.ui.renderStatementContentWithExits(data.trades, data.ledger, statementBody, filters, data.partialExitsMap);
                    }).catch(err => { console.error('loadStatementData error', err); });
                } catch (e) {
                    console.error('renderStatement error', e);
                }
                return;
            }
            
            // Debounce rendering by 1ms to prevent jitter (optimized for faster response)
            statementRenderTimeout = setTimeout(() => {
                try {
                    // Prevent multiple simultaneous renders
                    if (statementRendering) return;
                    statementRendering = true;
                    
                    console.log('renderStatement called - trades count:', appState.trades?.length || 0, 'ledger count:', appState.ledger?.length || 0);
                    const statementBody = document.getElementById('statement-tbody');
                    if (!statementBody) {
                        console.log('Statement body not found');
                        statementRendering = false;
                        return;
                    }
                    
                    // Load latest data
                    const trades = Array.isArray(appState.trades) ? appState.trades : [];
                    const ledger = Array.isArray(appState.ledger) ? appState.ledger : [];
                    console.log('Statement rendering with trades:', trades.length, 'ledger:', ledger.length);
                    
                    // Check cache validity
                    const currentHash = performanceCache.getTradesHash(trades) + '_' + performanceCache.getTradesHash(ledger);
                    if (statementCache && statementLastHash === currentHash && Object.keys(filters).length === 0) {
                        statementBody.innerHTML = statementCache;
                        statementRendering = false;
                        return;
                    }
                    
                    // Show loading for large datasets
                    if (trades.length > 1000) {
                        statementBody.innerHTML = '<tr><td colspan="22" class="text-center py-4">Loading statement...</td></tr>';
                        
                        // Use requestAnimationFrame for smoother rendering
                        requestAnimationFrame(() => {
                            window.main.loadStatementData(trades, ledger).then(data => {
                                window.ui.renderStatementContentWithExits(data.trades, data.ledger, statementBody, filters, data.partialExitsMap);
                                statementRendering = false;
                            }).catch(err => { 
                                console.error('loadStatementData error', err); 
                                statementRendering = false; 
                            });
                        });
                    } else {
                        window.main.loadStatementData(trades, ledger).then(data => {
                            window.ui.renderStatementContentWithExits(data.trades, data.ledger, statementBody, filters, data.partialExitsMap);
                            statementRendering = false;
                        }).catch(err => { 
                            console.error('loadStatementData error', err); 
                            statementRendering = false; 
                        });
                    }
                    
                } catch (e) {
                    console.error('renderStatement error', e);
                    statementRendering = false;
                }
            }, 5); // Reduced debounce delay from 10ms to 5ms
        };
        
        const renderStatementContent = async (trades, ledger, statementBody, filters) => {
            try {

                const tradeRows = await Promise.all(trades.map(async t => {
                    const closed = t.exit_date && t.exit_price;
                    
                    // For partial trades, calculate charges from stored partial exit data
                    let charges = 0;
                    if (closed) {
                        const isPartialExit = t.exit_quantity && t.exit_quantity > 0 && t.exit_quantity < t.quantity;
                        
                        if (isPartialExit) {
                            // Get charges from partial exit data
                            try {
                                const partialExits = await dataStore.getPartialExits(t.id);
                                if (partialExits.length > 0) {
                                    charges = partialExits.reduce((sum, exit) => sum + (exit.brokerage || 0) + (exit.charges || 0), 0);
                                } else {
                                    // Fallback to main trade data
                                    charges = (t.brokerage || 0) + (t.other_fees || 0);
                                }
                            } catch (error) {
                                console.error('Error calculating partial exit charges:', error);
                                charges = (t.brokerage || 0) + (t.other_fees || 0);
                            }
                        } else {
                            // For full trades, use main trade data
                            charges = (t.brokerage || 0) + (t.other_fees || 0);
                        }
                    }
                    
                    const net = closed ? calculateNetPnl(t) : 0;
                    const gross = net + charges; // Calculate gross from net + charges
                    
                    // Calculate net profit/loss percentage
                    const netProfitPercentage = closed && t.entry_price ? ((net / (t.entry_price * (t.quantity || 0))) * 100) : 0;
                    
                    // Determine trade status
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    
                    // Always use entry_date for chronological ordering to maintain the sequence of when entries were made
                    // This ensures deposits/withdrawals appear in correct chronological position relative to when trades were entered
                    const chronologicalDate = t.entry_date;
                    const displayDate = (isClosed && !isPartialExit) ? t.exit_date : t.entry_date;
                    
                    return {
                        date: window.utils.formatDateForDisplay(displayDate) || '—',
                        chronologicalDate: window.utils.formatDateForDisplay(chronologicalDate) || '—', // For sorting
                        status: isClosed ? 'Closed' : (isPartialExit ? 'Partial' : 'Open'),
                        entryPrice: t.entry_price || '—',
                        entryQty: t.quantity || '—',
                        entryDate: window.utils.formatDateForDisplay(t.entry_date) || '—',
                        stopLoss: t.stop_loss || '—',
                        targetPrice: t.target || '—',
                        exitPrice: t.exit_price || '—',
                        exitQty: t.exit_quantity || '—',
                        exitDate: window.utils.formatDateForDisplay(t.exit_date) || '—',
                        type: 'Trade',
                        symbol: t.asset || '—',
                        strategy: t.strategy || '—',
                        segment: t.segment || '—',
                        direction: t.direction || '—',
                        gross,
                        charges,
                        net,
                        netProfitPercentage,
                        winLoss: closed ? (net > 0 ? 'Win' : (net < 0 ? 'Loss' : '—')) : '—',
                        amount: '',
                        outcomeSummary: t.outcomeSummary || '',
                        emotionalState: t.emotionalState || '',
                        notes: t.reasons || ''
                    };
                }));
                const ledgerRows = ledger.map(l => ({
                    date: window.utils.formatDateForDisplay(l.date) || '—',
                    chronologicalDate: window.utils.formatDateForDisplay(l.date) || '—', // Add chronologicalDate for consistent sorting
                    status: '—',
                    entryPrice: '—',
                    entryQty: '—',
                    entryDate: '—',
                    stopLoss: '—',
                    targetPrice: '—',
                    exitPrice: '—',
                    exitQty: '—',
                    exitDate: '—',
                    type: l.type,
                    symbol: l.type,
                    strategy: '—',
                    direction: '—',
                    gross: 0,
                    charges: 0,
                    net: 0,
                    netProfitPercentage: 0,
                    winLoss: '—',
                    amount: l.amount || 0,
                    outcomeSummary: '—',
                    emotionalState: '—',
                    notes: l.notes || '—'
                }));

                // Sort by date in strict chronological order (no grouping by type)
                let allRows = [...tradeRows, ...ledgerRows].sort((a, b) => {
                    // Parse dates for proper chronological sorting
                    const parseDate = (dateStr) => {
                        if (!dateStr || dateStr === '—') return new Date(0); // Put invalid dates at the beginning
                        
                        // Handle DD-MM-YYYY format (from window.utils.formatDateForDisplay)
                        if (dateStr.includes('-') && dateStr.split('-').length === 3) {
                            const parts = dateStr.split('-');
                            if (parts.length === 3) {
                                const [day, month, year] = parts;
                                return new Date(year, month - 1, day);
                            }
                        }
                        // Handle DD/MM/YYYY format
                        else if (dateStr.includes('/')) {
                            const parts = dateStr.split('/');
                            if (parts.length === 3) {
                                return new Date(parts[2], parts[1] - 1, parts[0]);
                            }
                        }
                        // Handle YYYY-MM-DD format
                        else if (dateStr.match(/^\d{4}-\d{2}-\d{2}$/)) {
                            return new Date(dateStr);
                        }
                        
                        // Fallback to direct date parsing
                        return new Date(dateStr);
                    };
                    
                    // Use chronologicalDate for consistent sorting (both trades and ledger entries now have this field)
                    const sortDateA = a.chronologicalDate;
                    const sortDateB = b.chronologicalDate;
                    
                    const dateA = parseDate(sortDateA);
                    const dateB = parseDate(sortDateB);
                    
                    // Sort purely by chronological date (no secondary sorting)
                    return dateA.getTime() - dateB.getTime();
                });
                
                // Apply filters if provided
                if (filters.transactionType && filters.transactionType !== 'All Types') {
                    allRows = allRows.filter(row => row.type === filters.transactionType);
                }
                
                if (filters.strategy && filters.strategy !== 'All Strategies') {
                    allRows = allRows.filter(row => row.strategy === filters.strategy);
                }
                
                if (filters.startDate || filters.endDate) {
                    allRows = allRows.filter(row => {
                        if (!row.date || row.date === '—') return false;
                        
                        // Parse date from various formats (dd/mm/yyyy, dd-mm-yyyy, yyyy-mm-dd, etc.)
                        let rowDate;
                        try {
                            if (row.date.includes('/')) {
                                // Handle dd/mm/yyyy format
                                const parts = row.date.split('/');
                                if (parts.length === 3) {
                                    rowDate = new Date(parts[2], parts[1] - 1, parts[0]);
                                }
                            } else if (row.date.includes('-')) {
                                const parts = row.date.split('-');
                                if (parts.length === 3) {
                                    if (parts[0].length === 2) {
                                        // Handle dd-mm-yyyy format (from window.utils.formatDateForDisplay)
                                        const [day, month, year] = parts;
                                        rowDate = new Date(year, month - 1, day);
                                    } else {
                                        // Handle yyyy-mm-dd format
                                        const [year, month, day] = parts;
                                        rowDate = new Date(year, month - 1, day);
                                    }
                                }
                            } else {
                                // Handle other formats
                                rowDate = new Date(row.date);
                            }
                        } catch (e) {
                            console.warn('Invalid date format:', row.date);
                            return false;
                        }
                        
                        if (isNaN(rowDate.getTime())) return false;
                        
                        // Normalize filter dates to ensure proper comparison
                        const startDate = filters.startDate ? new Date(filters.startDate + 'T00:00:00') : null;
                        const endDate = filters.endDate ? new Date(filters.endDate + 'T23:59:59') : null;
                        
                        // Normalize row date to date-only for accurate comparison
                        const rowDateOnly = new Date(rowDate.getFullYear(), rowDate.getMonth(), rowDate.getDate());
                        const startDateOnly = startDate ? new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate()) : null;
                        const endDateOnly = endDate ? new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate()) : null;
                        
                        // Inclusive date range comparison
                        if (startDateOnly && rowDateOnly < startDateOnly) return false;
                        if (endDateOnly && rowDateOnly > endDateOnly) return false;
                        
                        // Debug logging for date filtering
                        console.log('Date filtering debug:', {
                            originalDate: row.date,
                            parsedDate: rowDate,
                            rowDateOnly: rowDateOnly,
                            startFilter: filters.startDate,
                            endFilter: filters.endDate,
                            startDateOnly: startDateOnly,
                            endDateOnly: endDateOnly,
                            isValid: !isNaN(rowDate.getTime()),
                            isInRange: (!startDateOnly || rowDateOnly >= startDateOnly) && (!endDateOnly || rowDateOnly <= endDateOnly)
                        });
                        
                        return true;
                    });
                }
                
                // Apply new filters
                if (filters.status) {
                    allRows = allRows.filter(row => row.status === filters.status);
                }
                
                if (filters.winloss) {
                    allRows = allRows.filter(row => row.winLoss === filters.winloss);
                }
                
                if (filters.segment) {
                    allRows = allRows.filter(row => row.segment === filters.segment);
                }
                
                if (filters.direction) {
                    allRows = allRows.filter(row => row.direction === filters.direction);
                }
                
                // Show no results message if no rows match filters
                if (allRows.length === 0) {
                    statementBody.innerHTML = `
                        <tr>
                            <td colspan="22" class="px-6 py-8 text-center" style="color: var(--text-muted);">
                                <div class="flex flex-col items-center">
                                    <svg class="w-12 h-12 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.172 16.172a4 4 0 015.656 0M9 12h6m-6-4h6m2 5.291A7.962 7.962 0 0112 15c-2.34 0-4.29-1.009-5.824-2.709M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    </svg>
                                    <p class="text-lg font-medium">No results found</p>
                                    <p class="text-sm">Try adjusting your filter criteria</p>
                                </div>
                            </td>
                        </tr>
                    `;
                    return;
                }
                
                statementBody.innerHTML = allRows.map(r => `
                    <tr class="border-b" style="border-color: var(--border-color);">
                        <td class="px-2 py-2 border-r text-center" style="border-color: var(--border-color); width: 100px; min-width: 100px;">${r.date}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.symbol}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.direction}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.segment || '—'}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.type!=='Trade' ? window.utils.formatCurrency(r.amount) : '—'}</td>
                        <td class="px-3 py-2 border-r ${r.gross >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.gross) : '—'}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.charges) : '—'}</td>
                        <td class="px-3 py-2 border-r ${r.net >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.net) : '—'}</td>
                        <td class="px-3 py-2 border-r ${r.netProfitPercentage >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? (r.netProfitPercentage ? r.netProfitPercentage.toFixed(2) + '%' : '—') : '—'}</td>
                        <td class="px-3 py-2 border-r ${r.winLoss === 'Win' ? 'text-green-500' : (r.winLoss === 'Loss' ? 'text-red-500' : '')}" style="border-color: var(--border-color);">${r.winLoss}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.status}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryPrice}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryQty}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryDate}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.stopLoss}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.targetPrice}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitPrice}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitQty}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitDate}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.strategy}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.outcomeSummary}</td>
                        <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.emotionalState}</td>
                        <td class="px-3 py-2" style="border-color: var(--border-color);">${r.notes}</td>
                    </tr>
                `).join('');
                
                // Cache the generated HTML if no filters applied
                if (Object.keys(filters).length === 0) {
                    statementCache = allRows.map(r => `
                        <tr class="border-b" style="border-color: var(--border-color);">
                            <td class="px-2 py-2 border-r text-center" style="border-color: var(--border-color); width: 100px; min-width: 100px;">${r.date}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.symbol}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.direction}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.segment || '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.type!=='Trade' ? window.utils.formatCurrency(r.amount) : '—'}</td>
                            <td class="px-3 py-2 border-r ${r.gross >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.gross) : '—'}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.charges) : '—'}</td>
                            <td class="px-3 py-2 border-r ${r.net >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? window.utils.formatCurrency(r.net) : '—'}</td>
                            <td class="px-3 py-2 border-r ${r.netProfitPercentage >= 0 ? 'text-green-500' : 'text-red-500'}" style="border-color: var(--border-color);">${r.type==='Trade' ? (r.netProfitPercentage ? r.netProfitPercentage.toFixed(2) + '%' : '—') : '—'}</td>
                            <td class="px-3 py-2 border-r ${r.winLoss === 'Win' ? 'text-green-500' : (r.winLoss === 'Loss' ? 'text-red-500' : '')}" style="border-color: var(--border-color);">${r.winLoss}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.status}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryPrice}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryQty}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.entryDate}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.stopLoss}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.targetPrice}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitPrice}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitQty}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.exitDate}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.strategy}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.outcomeSummary}</td>
                            <td class="px-3 py-2 border-r" style="border-color: var(--border-color);">${r.emotionalState}</td>
                            <td class="px-3 py-2" style="border-color: var(--border-color);">${r.notes}</td>
                        </tr>
                    `).join('');
                    statementLastHash = performanceCache.getTradesHash(trades) + '_' + performanceCache.getTradesHash(ledger);
                }
            } catch (e) {
                console.error('renderStatementContent error', e);
            }
        };
        const renderProfilePage = (profileData) => {
            try {
                console.log('Rendering profile page with data:', profileData);
                
                if (!profileData) {
                    console.log('No profile data provided');
                    return;
                }
                
                // Update profile form fields
                const nameField = document.getElementById('profile-name');
                const emailField = document.getElementById('profile-email');
                const phoneField = document.getElementById('profile-phone');
                const cityField = document.getElementById('profile-city');
                
                if (nameField) nameField.value = profileData.name || '';
                if (emailField) emailField.value = profileData.email || '';
                if (phoneField) phoneField.value = profileData.phone || '';
                if (cityField) cityField.value = profileData.city || '';
                
                console.log('Form fields updated');
                
                // Update account information
                const memberSinceField = document.getElementById('profile-member-since');
                if (memberSinceField && profileData.created_at) {
                    const signupDate = new Date(profileData.created_at);
                    memberSinceField.textContent = signupDate.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    console.log('Member since date set:', signupDate.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    }));
                } else {
                    console.log('Member since field not found or no created_at data');
                }
                
                // Update subscription information
                const subscriptionStartField = document.getElementById('profile-subscription-start');
                const subscriptionEndField = document.getElementById('profile-subscription-end');
                const planTypeField = document.getElementById('profile-plan-type');
                
                if (subscriptionStartField && profileData.subscription_start_date) {
                    const startDate = new Date(profileData.subscription_start_date);
                    subscriptionStartField.textContent = startDate.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    console.log('Subscription start date set');
                } else {
                    console.log('Subscription start field not found or no subscription_start_date data');
                }
                
                if (subscriptionEndField && profileData.subscription_ends_at) {
                    const endDate = new Date(profileData.subscription_ends_at);
                    subscriptionEndField.textContent = endDate.toLocaleDateString('en-US', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                    console.log('Subscription end date set');
                } else {
                    console.log('Subscription end field not found or no subscription_ends_at data');
                }
                
                if (planTypeField && profileData.plan_type) {
                    planTypeField.textContent = profileData.plan_type.charAt(0).toUpperCase() + profileData.plan_type.slice(1);
                    console.log('Plan type set:', profileData.plan_type);
                } else {
                    console.log('Plan type field not found or no plan_type data');
                }
                
            } catch (e) {
                console.error('renderProfilePage error', e);
            }
        };

        // Profile form submission handler
        const handleProfileFormSubmit = async (e) => {
            e.preventDefault();
            
            const submitButton = e.target.querySelector('button[type="submit"]');
            const btnText = submitButton.querySelector('.btn-text');
            const spinner = submitButton.querySelector('.spinner');
            
            try {
                // Validate user authentication
                if (!appState.user || !appState.user.id) {
                    throw new Error('User not authenticated');
                }
                
                console.log('Profile form submission started for user:', appState.user.id);
                
                // Show loading state
                btnText.textContent = 'Saving...';
                spinner.classList.remove('hidden');
                submitButton.disabled = true;
                
                // Get form data
                const formData = new FormData(e.target);
                const profileData = {
                    name: formData.get('name'),
                    phone: formData.get('phone'),
                    city: formData.get('city')
                };
                
                console.log('Profile data to save:', profileData);
                
                // Update profile in Supabase
                const { data, error } = await supabase
                    .from('profiles')
                    .update(profileData)
                    .eq('id', appState.user.id)
                    .select();
                
                if (error) {
                    console.error('Supabase profile update error:', error);
                    
                    // If profile doesn't exist, create one
                    if (error.code === 'PGRST116') {
                        console.log('Profile not found during update, creating new profile');
                        await createUserProfile();
                        
                        // Try updating again
                        const { data: updateData, error: updateError } = await supabase
                            .from('profiles')
                            .update(profileData)
                            .eq('id', appState.user.id)
                            .select();
                        
                        if (updateError) {
                            throw updateError;
                        }
                        
                        console.log('Profile updated successfully after creation:', updateData);
                    } else {
                        throw error;
                    }
                }
                
                console.log('Profile updated successfully:', data);
                
                // Show success message
                btnText.textContent = 'Saved!';
                setTimeout(() => {
                    btnText.textContent = 'Save Changes';
                    spinner.classList.add('hidden');
                    submitButton.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('Profile update error:', error);
                btnText.textContent = 'Error - Try Again';
                spinner.classList.add('hidden');
                submitButton.disabled = false;
                
                setTimeout(() => {
                    btnText.textContent = 'Save Changes';
                }, 3000);
            }
        };

        // Password change form submission handler
        const handlePasswordFormSubmit = async (e) => {
            e.preventDefault();
            
            const submitButton = e.target.querySelector('button[type="submit"]');
            const btnText = submitButton.querySelector('.btn-text');
            const spinner = submitButton.querySelector('.spinner');
            
            try {
                // Show loading state
                btnText.textContent = 'Updating...';
                spinner.classList.remove('hidden');
                submitButton.disabled = true;
                
                // Get form data
                const currentPassword = document.getElementById('current-password').value;
                const newPassword = document.getElementById('new-password').value;
                const confirmPassword = document.getElementById('confirm-new-password').value;
                
                // Validate passwords
                if (newPassword !== confirmPassword) {
                    throw new Error('New passwords do not match');
                }
                
                if (newPassword.length < 6) {
                    throw new Error('Password must be at least 6 characters');
                }
                
                // Update password in Supabase Auth
                const { error } = await supabase.auth.updateUser({
                    password: newPassword
                });
                
                if (error) {
                    throw error;
                }
                
                // Clear form
                e.target.reset();
                
                // Show success message
                btnText.textContent = 'Password Updated!';
                setTimeout(() => {
                    btnText.textContent = 'Update Password';
                    spinner.classList.add('hidden');
                    submitButton.disabled = false;
                }, 2000);
                
            } catch (error) {
                console.error('Password update error:', error);
                btnText.textContent = 'Error - Try Again';
                spinner.classList.add('hidden');
                submitButton.disabled = false;
                
                setTimeout(() => {
                    btnText.textContent = 'Update Password';
                }, 3000);
            }
        };

        // Load profile data from Supabase
        const loadProfileData = async () => {
            try {
                // Validate user authentication
                if (!appState.user || !appState.user.id) {
                    console.error('User not authenticated, cannot load profile data');
                    return;
                }
                
                console.log('Loading profile data for user:', appState.user.id);
                
                const { data: profileData, error } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('id', appState.user.id)
                    .single();
                
                if (error) {
                    console.error('Error loading profile data:', error);
                    
                    // If profile doesn't exist, create one
                    if (error.code === 'PGRST116') {
                        console.log('Profile not found, creating new profile for user');
                        await createUserProfile();
                        return;
                    }
                    return;
                }
                
                console.log('Profile data loaded:', profileData);
                
                if (profileData) {
                    // Store profile data in appState for global access
                    appState.profileData = profileData;
                    
                    renderProfilePage(profileData);
                    
                    // Single update pattern - update header display name with profile data (no jitter)
                    const updateHeaderDisplayName = () => {
                        // Priority: Profile name > Auth metadata name > Email prefix > Guest
                        const displayName = profileData.name || 
                                           appState.user?.user_metadata?.name ||
                                           appState.user?.email?.split('@')[0] ||
                                           'Guest';
                        const headerElement = document.getElementById('user-display-name');
                        if (headerElement) {
                            headerElement.textContent = displayName;
                        }
                    };
                    
                    // Single smooth update - no jitter
                    updateHeaderDisplayName();
                } else {
                    console.log('No profile data found for user');
                }
            } catch (error) {
                console.error('Error loading profile data:', error);
            }
        };

        // Create user profile if it doesn't exist
        const createUserProfile = async () => {
            try {
                console.log('Creating new profile for user:', appState.user.id);
                
                const newProfile = {
                    id: appState.user.id,
                    name: appState.user.displayName || appState.user.email || '',
                    email: appState.user.email || '',
                    phone: '',
                    city: '',
                    created_at: new Date().toISOString(),
                    subscription_status: 'active',
                    plan_type: 'basic',
                    subscription_ends_at: null,
                    subscription_start_date: new Date().toISOString()
                };
                
                console.log('Creating profile with data:', newProfile);
                
                const { data, error } = await supabase
                    .from('profiles')
                    .insert(newProfile)
                    .select()
                    .single();
                
                if (error) {
                    console.error('Error creating profile:', error);
                    return;
                }
                
                console.log('Profile created successfully:', data);
                
                // Render the newly created profile
                renderProfilePage(data);
                
            } catch (error) {
                console.error('Error creating profile:', error);
            }
        };
        // Helper function to calculate weekdays between two dates (excluding weekends)
        const getWeekdaysBetween = (startDate, endDate) => {
            let count = 0;
            const current = new Date(startDate);
            const end = new Date(endDate);
            
            while (current <= end) {
                const dayOfWeek = current.getDay();
                // Skip weekends (Saturday = 6, Sunday = 0)
                if (dayOfWeek !== 0 && dayOfWeek !== 6) {
                    count++;
                }
                current.setDate(current.getDate() + 1);
            }
            return count;
        };

        // Helper function to add weekdays to a date (excluding weekends)
        const addWeekdays = (startDate, weekdays) => {
            let current = new Date(startDate);
            let added = 0;
            
            while (added < weekdays) {
                current.setDate(current.getDate() + 1);
                const dayOfWeek = current.getDay();
                // Only count weekdays (Monday-Friday)
                if (dayOfWeek !== 0 && dayOfWeek !== 6) {
                    added++;
                }
            }
            return current;
        };

        // Render debouncing and guards to prevent jitter
        let renderTimeout;
        let isRendering = false;
        
        const renderChallenge = async () => {
            // Prevent multiple simultaneous renders
            if (isRendering) return;
            
            // Clear any pending render
            clearTimeout(renderTimeout);
            
            // Debounce renders to prevent rapid re-renders
            renderTimeout = setTimeout(async () => {
                try {
                    isRendering = true;
                    const challenge = appState.challenge;
                    const activeContainer = document.getElementById('challenge-active-container');
                    const inactiveContainer = document.getElementById('challenge-inactive-container');
                    const loadingContainer = document.getElementById('challenge-loading-container');
                
                // Get theme colors for chart rendering
                const themeColors = getThemeColors();
                
                console.log('renderChallenge called - Challenge:', challenge, 'Trades count:', appState.trades?.length || 0);
                
                if (challenge && challenge.id) {
                    // Show active challenge - hide loading and inactive, show active
                    activeContainer.classList.remove('hidden');
                    inactiveContainer.classList.add('hidden');
                    loadingContainer.classList.add('hidden');
                    
                    const now = new Date();
                    const startDate = new Date(challenge.startDate);
                    const endDate = new Date(challenge.endDate);
                    const daysRemaining = Math.max(0, getWeekdaysBetween(now, endDate));
                    
                    // Calculate current capital from trades (use real-time data)
                    const trades = appState.trades || [];
                    const challengeStartDate = new Date(challenge.startDate);
                    
                    // Perfect isolation: only trades within challenge period (manual + CSV)
                    const closedTrades = trades.filter(t => {
                        if (!t.exit_date || !t.exit_price) return false;
                        const tradeDate = new Date(t.exit_date);
                        
                        // Include all trades within challenge period, regardless of entry method
                        return tradeDate >= challengeStartDate && tradeDate <= endDate;
                    });
                    const totalPnl = closedTrades.reduce((sum, t) => sum + calculateNetPnl(t), 0);
                    const currentCapital = challenge.startingCapital + totalPnl;
                    
                    // Ensure no previous trades influence new challenges
                    if (closedTrades.length === 0) {
                        console.log('No trades found for challenge - using starting capital only');
                    }
                    
                    // Calculate progress
                    const targetGain = challenge.targetCapital - challenge.startingCapital;
                    const currentGain = currentCapital - challenge.startingCapital;
                    const progressPercent = Math.min(100, Math.max(0, (currentGain / targetGain) * 100));
                    
                    // Calculate dynamic daily target based on current progress and days remaining
                    const remainingGain = challenge.targetCapital - currentCapital;
                    const dynamicDailyTarget = daysRemaining > 0 ? remainingGain / daysRemaining : 0;
                    
                    // Calculate win rate for challenge period
                    const challengeTrades = closedTrades.filter(t => {
                        const tradeDate = new Date(t.exit_date);
                        return tradeDate >= startDate && tradeDate <= endDate;
                    });
                    const wins = challengeTrades.filter(t => calculateNetPnl(t) > 0).length;
                    const winRate = challengeTrades.length > 0 ? (wins / challengeTrades.length) * 100 : 0;
                    
                    // Update UI
                    document.getElementById('challenge-days-remaining').textContent = daysRemaining;
                    document.getElementById('challenge-end-date').textContent = endDate.toLocaleDateString();
                    document.getElementById('challenge-current-capital').textContent = window.utils.formatCurrency(currentCapital);
                    document.getElementById('challenge-target-capital').textContent = `Target: ${window.utils.formatCurrency(challenge.targetCapital)}`;
                    document.getElementById('challenge-daily-target').textContent = window.utils.formatCurrency(dynamicDailyTarget);
                    document.getElementById('challenge-win-rate').textContent = `${winRate.toFixed(1)}%`;
                    document.getElementById('challenge-progress-percent').textContent = `${progressPercent.toFixed(0)}%`;
                    
                    // Update progress chart - only recreate if data changed significantly
                    const progressCtx = document.getElementById('challengeProgressChart');
                    if (progressCtx && typeof Chart !== 'undefined') {
                        // Check if chart needs recreation (only if progress changed by more than 5%)
                        const needsRecreation = !chartInstances['challengeProgressChart'] || 
                            Math.abs((chartInstances['challengeProgressChart'].data.datasets[0].data[0] || 0) - progressPercent) > 5;
                        
                        if (needsRecreation) {
                            if (chartInstances['challengeProgressChart']) {
                                chartInstances['challengeProgressChart'].destroy();
                            }
                        
                        const progressChart = new Chart(progressCtx, {
                            type: 'doughnut',
                            data: {
                                datasets: [{
                                    data: [progressPercent, 100 - progressPercent],
                                    backgroundColor: ['#22c55e', '#e5e7eb'],
                                    borderWidth: 0
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                cutout: '70%',
                                plugins: {
                                    legend: { 
                                        display: false 
                                    },
                                    tooltip: getContinuousTooltipConfig(themeColors, {
                                        borderColor: 'rgba(255, 255, 255, 0.2)'
                                    })
                                }
                            }
                        });
                            chartInstances['challengeProgressChart'] = progressChart;
                        } else {
                            // Just update the data without recreating the chart
                            chartInstances['challengeProgressChart'].data.datasets[0].data = [progressPercent, 100 - progressPercent];
                            chartInstances['challengeProgressChart'].update('none'); // No animation for smoother updates
                        }
                    }
                    
                    // Calculate additional metrics - only for trades with both stop loss and target
                    const avgRR = challengeTrades.length > 0 ? 
                        challengeTrades.reduce((sum, t) => {
                            const entryPrice = t.entry_price || 0;
                            
                            // Only calculate R:R for trades that have both stop loss and target
                            if (t.stop_loss && (t.target || t.target_price)) {
                                const stopLoss = t.stop_loss;
                                const target = t.target_price || t.target;
                                
                                const risk = Math.abs(entryPrice - stopLoss);
                                const reward = Math.abs(target - entryPrice);
                                
                                return risk > 0 && reward > 0 ? sum + (risk / reward) : sum;
                            }
                            return sum;
                        }, 0) / challengeTrades.filter(t => t.stop_loss && (t.target || t.target_price)).length : 0;
                    
                    const highestProfit = challengeTrades.length > 0 ? 
                        Math.max(...challengeTrades.map(t => calculateNetPnl(t))) : 0;
                    
                    const maxDrawdown = challengeTrades.length > 0 ? 
                        Math.min(...challengeTrades.map(t => calculateNetPnl(t))) : 0;
                    
                    // Calculate max drawdown as percentage of starting capital
                    const maxDrawdownPercent = challenge.startingCapital > 0 ? 
                        (Math.abs(maxDrawdown) / challenge.startingCapital) * 100 : 0;
                    
                    const validRRTrades = challengeTrades.filter(t => t.stop_loss && (t.target || t.target_price));
                    document.getElementById('challenge-avg-rr').textContent = validRRTrades.length > 0 ? `${avgRR.toFixed(1)}:1` : 'N/A';
                    document.getElementById('challenge-highest-profit').textContent = window.utils.formatCurrency(highestProfit);
                    document.getElementById('challenge-max-drawdown').textContent = `${maxDrawdownPercent.toFixed(2)}%`;
                    
                    // Debug logging for challenge completion
                    console.log('Challenge completion check:', {
                        startingCapital: challenge.startingCapital,
                        targetCapital: challenge.targetCapital,
                        currentCapital,
                        closedTradesCount: closedTrades.length,
                        totalPnl,
                        challengeStartDate: challenge.startDate,
                        challengeEndDate: challenge.endDate,
                        challengeCreatedAt: challenge.createdAt,
                        canComplete: currentCapital > challenge.startingCapital && 
                                   currentCapital >= challenge.targetCapital && 
                                   !challenge.completed
                    });
                    
                    // Check if challenge is completed
                    // Only complete if current capital exceeds starting capital and reaches target
                    // AND has at least one trade made after challenge creation
                    if (currentCapital > challenge.startingCapital && 
                        currentCapital >= challenge.targetCapital && 
                        closedTrades.length > 0 &&
                        !challenge.completed) {
                        challenge.completed = true;
                        challenge.success = true;
                        challenge.completedAt = new Date().toISOString();
                        
                        // Sync completed challenge to Supabase
                        try {
                            await dataStore.upsertChallenge(challenge);
                        } catch (err) {
                            console.warn('Failed to sync completed challenge to Supabase:', err);
                        }
                        
                        // Add to history if not already there
                        const history = [...appState.challengeHistory.filter(c => c.id !== challenge.id), challenge];
                        
                        // Update appState immediately
                        appState.challenge = null;
                        appState.challengeHistory = history;
                        
                        window.utils.showToast('🎉 Challenge completed successfully!', 'success');
                        
                        // Force immediate render (bypass debounce)
                        clearTimeout(renderTimeout);
                        isRendering = false;
                        renderChallenge();
                        renderChallengeHistory();
                    } else if (daysRemaining <= 0 && !challenge.completed) {
                        challenge.completed = true;
                        challenge.success = false;
                        challenge.completedAt = new Date().toISOString();
                        
                        // Sync expired challenge to Supabase
                        try {
                            await dataStore.upsertChallenge(challenge);
                        } catch (err) {
                            console.warn('Failed to sync expired challenge to Supabase:', err);
                        }
                        
                        // Add to history if not already there
                        const history = [...appState.challengeHistory.filter(c => c.id !== challenge.id), challenge];
                        
                        // Update appState immediately
                        appState.challenge = null;
                        appState.challengeHistory = history;
                        
                        window.utils.showToast('Challenge time expired. Better luck next time!', 'info');
                        
                        // Force immediate render (bypass debounce)
                        clearTimeout(renderTimeout);
                        isRendering = false;
                        renderChallenge();
                        renderChallengeHistory();
                    }
                    
                } else {
                    // Show inactive state - hide loading and active, show inactive
                    activeContainer.classList.add('hidden');
                    inactiveContainer.classList.remove('hidden');
                    loadingContainer.classList.add('hidden');
                }
                } catch (e) {
                    console.error('renderChallenge error', e);
                } finally {
                    isRendering = false;
                }
                
                // Render challenge statistics
                renderChallengeStats();
            }, 10); // 10ms debounce delay (reduced for faster updates)
        };
        
        // Render challenge statistics (wins/losses)
        const renderChallengeStats = () => {
            try {
                const history = appState.challengeHistory || [];
                
                // Calculate wins and losses
                const wins = history.filter(challenge => challenge.completed && challenge.success).length;
                const losses = history.filter(challenge => challenge.completed && !challenge.success).length;
                
                // Update UI
                document.getElementById('challenge-wins-count').textContent = wins;
                document.getElementById('challenge-losses-count').textContent = losses;
                
                // Re-render feather icons
                if (typeof feather !== 'undefined') {
                    feather.replace();
                }
            } catch (e) {
                console.error('renderChallengeStats error', e);
            }
        };

        const clearChallengeHistory = async () => {
            try {
                // Get all completed challenges (only delete completed ones, preserve active)
                const completedChallenges = appState.challengeHistory || [];
                
                if (completedChallenges.length === 0) {
                    window.utils.showToast('No challenge history to clear', 'info');
                    return;
                }
                
                // Delete each completed challenge from Supabase
                let deletedCount = 0;
                for (const challenge of completedChallenges) {
                    try {
                        await dataStore.deleteChallenge(challenge.id);
                        deletedCount++;
                    } catch (error) {
                        console.warn(`Failed to delete challenge ${challenge.id}:`, error);
                        // Continue with other challenges even if one fails
                    }
                }
                
                // Clear local state
                appState.challengeHistory = [];
                
                // Refresh UI
                renderChallengeHistory();
                renderChallengeStats();
                renderChallenge();
                
                // Show success message
                if (deletedCount === completedChallenges.length) {
                    window.utils.showToast(`Challenge history cleared successfully! Deleted ${deletedCount} challenges.`, 'success');
                } else {
                    window.utils.showToast(`Partially cleared: ${deletedCount}/${completedChallenges.length} challenges deleted.`, 'warning');
                }
                
                console.log(`Challenge history cleared: ${deletedCount}/${completedChallenges.length} challenges deleted`);
            } catch (error) {
                console.error('Error clearing challenge history:', error);
                window.utils.showToast('Error clearing challenge history', 'error');
            }
        };

        const renderChallengeHistory = () => {
            try {
                const history = appState.challengeHistory || [];
                const container = document.getElementById('challenge-history-container');
                
                if (history.length === 0) {
                    container.innerHTML = '<p class="text-center text-gray-500">No challenge history yet.</p>';
                    return;
                }
                
                container.innerHTML = history.map(challenge => {
                    const startDate = new Date(challenge.startDate);
                    const endDate = new Date(challenge.endDate);
                    const completed = challenge.completed;
                    const success = challenge.success;
                    
                    return `
                        <div class="p-4 rounded-lg border" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h4 class="font-semibold" style="color: var(--text-primary);">
                                        ${window.utils.formatCurrency(challenge.startingCapital)} → ${window.utils.formatCurrency(challenge.targetCapital)}
                                    </h4>
                                    <p class="text-sm" style="color: var(--text-secondary);">
                                        ${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}
                                    </p>
                                    <p class="text-sm" style="color: var(--text-secondary);">
                                        ${challenge.timeframe} days • Max Risk: ${challenge.maxRisk}%
                                    </p>
                                </div>
                                <div class="text-right">
                                    <span class="px-2 py-1 rounded text-xs font-medium ${
                                        completed ? (success ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800') : 'bg-yellow-100 text-yellow-800'
                                    }">
                                        ${completed ? (success ? 'Success' : 'Failed') : 'Incomplete'}
                                    </span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Render challenge statistics
                renderChallengeStats();
            } catch (e) {
                console.error('renderChallengeHistory error', e);
            }
        };
        // Cache for Open Positions to prevent redundant calculations
        let openPositionsCache = null;
        let openPositionsLastHash = null;

        const renderOpenPositionsOverview = () => {
            try {
                const trades = window.appState?.trades || [];
                
                // Check cache validity using trades hash
                const currentHash = performanceCache.getTradesHash(trades);
                if (openPositionsCache && openPositionsLastHash === currentHash) {
                    // Use cached data for instant rendering
                    updateOpenPositionsUI(openPositionsCache);
                    return;
                }
                
                // A position is open if remaining quantity > 0 (handles partial exits)
                const allOpenTrades = trades.filter(trade => {
                    const totalQty = Number(trade.quantity) || 0;
                    const exitedQty = Number(trade.exit_quantity) || 0;
                    return totalQty > exitedQty; // remaining > 0
                });
                const openTradesCount = allOpenTrades.length;
                
                // Optimize date calculations - calculate current date once
                const currentDate = new Date();
                const currentTime = currentDate.getTime();
                
                // Sort by days open (highest first) and take top 5
                const openTrades = allOpenTrades
                    .map(trade => {
                        const entryTime = new Date(trade.entry_date).getTime();
                        // Add validation for invalid dates
                        if (isNaN(entryTime) || !trade.entry_date) {
                            return { ...trade, daysOpen: 0 };
                        }
                        const daysOpen = Math.ceil((currentTime - entryTime) / (1000 * 60 * 60 * 24));
                        return { ...trade, daysOpen };
                    })
                    .sort((a, b) => b.daysOpen - a.daysOpen)
                    .slice(0, 5);
                
                // Calculate all metrics in one pass for better performance
                let capitalDeployed = 0;
                let totalRiskAmount = 0;
                let totalDaysOpen = 0;
                let longCount = 0;
                let shortCount = 0;
                
                // Single loop to calculate all metrics
                allOpenTrades.forEach(trade => {
                    const tradeValue = (trade.entry_price || 0) * (trade.quantity || 0);
                    capitalDeployed += tradeValue;
                    totalRiskAmount += tradeValue;
                    
                    // Count direction for strategy mix
                    if (trade.direction === 'Long') longCount++;
                    else if (trade.direction === 'Short') shortCount++;
                });
                
                // Calculate average time open from the top 5 trades only
                if (openTrades.length > 0) {
                    totalDaysOpen = openTrades.reduce((total, trade) => total + trade.daysOpen, 0);
                }
                const avgTimeOpen = openTrades.length > 0 ? totalDaysOpen / openTrades.length : 0;
                
                // Calculate strategy percentages
                const longPercentage = openTradesCount > 0 ? (longCount / openTradesCount) * 100 : 0;
                const shortPercentage = openTradesCount > 0 ? (shortCount / openTradesCount) * 100 : 0;
                
                // Pre-generate positions list HTML
                const positionsListHTML = openTradesCount === 0 
                    ? '<p class="text-sm text-center py-8" style="color: var(--text-muted);">No open positions</p>'
                    : openTrades.map(trade => {
                        const totalValue = (trade.entry_price || 0) * (trade.quantity || 0);
                        const typeBg = trade.direction === 'Long' ? '#10b981' : '#ef4444';
                        
                        return `
                            <div class="flex items-center justify-between p-2 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="flex items-center space-x-3">
                                    <span class="px-2 py-0.5 rounded-full text-xs font-medium text-white" style="background-color: ${typeBg};">${trade.direction || 'Long'}</span>
                                    <div>
                                        <p class="font-medium text-sm" style="color: var(--text-primary);">${trade.asset || 'N/A'}</p>
                                        <p class="text-xs" style="color: var(--text-secondary);">${trade.daysOpen}d open</p>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <p class="font-medium text-sm" style="color: var(--text-primary);">${window.utils.formatCurrency(totalValue)}</p>
                                    <p class="text-xs" style="color: var(--text-secondary);">${trade.quantity || 0} @ ${window.utils.formatCurrency(trade.entry_price || 0)}</p>
                                </div>
                            </div>
                        `;
                    }).join('');
                
                // Cache the calculated data
                openPositionsCache = {
                    openTradesCount,
                    capitalDeployed,
                    totalRiskAmount,
                    avgTimeOpen,
                    longPercentage,
                    shortPercentage,
                    longCount,
                    shortCount,
                    positionsListHTML
                };
                openPositionsLastHash = currentHash;
                
                // Update UI with calculated data
                updateOpenPositionsUI(openPositionsCache);
                
                // Update top trades (moved outside to avoid duplication)
                renderTopTrades(5);
                renderDashboardTopWinners();
                renderDashboardTopLosers();
                
            } catch (e) {
                console.error('renderOpenPositionsOverview error', e);
            }
        };

        // Make renderOpenPositionsOverview globally accessible
        window.renderOpenPositionsOverview = renderOpenPositionsOverview;

        // Separate UI update function for instant rendering with cached data
        const updateOpenPositionsUI = (data) => {
            try {
                const {
                    openTradesCount,
                    capitalDeployed,
                    totalRiskAmount,
                    avgTimeOpen,
                    longPercentage,
                    shortPercentage,
                    longCount,
                    shortCount,
                    positionsListHTML
                } = data;

                // Batch DOM updates for better performance
                const updates = [
                    { id: 'open-positions-count', value: openTradesCount },
                    { id: 'open-positions-plural', value: openTradesCount === 1 ? '' : 's' },
                    { id: 'capital-deployed-plural', value: openTradesCount === 1 ? '' : 's' },
                    { id: 'capital-deployed-amount', value: window.utils.formatCurrency(capitalDeployed) },
                    { id: 'capital-deployed-description', value: `${openTradesCount} open trade${openTradesCount === 1 ? '' : 's'}` },
                    { id: 'avg-time-open', value: avgTimeOpen.toFixed(1) },
                    { id: 'long-percentage', value: `${longPercentage.toFixed(0)}% (${longCount} position${longCount === 1 ? '' : 's'})` },
                    { id: 'short-percentage', value: `${shortPercentage.toFixed(0)}% (${shortCount} position${shortCount === 1 ? '' : 's'})` }
                ];

                // Apply all text updates in one batch
                updates.forEach(update => {
                    const element = document.getElementById(update.id);
                    if (element) element.textContent = update.value;
                });

                // Update Total Open Risk with styling
                const riskAmountEl = document.getElementById('total-open-risk-amount-overview');
                if (riskAmountEl) {
                    riskAmountEl.textContent = window.utils.formatCurrency(totalRiskAmount);
                    riskAmountEl.className = 'text-2xl font-bold mt-2';
                    riskAmountEl.style.color = totalRiskAmount > 0 ? '#ef4444' : 'var(--text-primary)';
                }

                // Update strategy mix bars
                const longBarEl = document.getElementById('long-bar');
                const shortBarEl = document.getElementById('short-bar');
                if (longBarEl) longBarEl.style.width = `${longPercentage}%`;
                if (shortBarEl) shortBarEl.style.width = `${shortPercentage}%`;

                // Update positions list
                const positionsListEl = document.getElementById('open-positions-list');
                if (positionsListEl) positionsListEl.innerHTML = positionsListHTML;

            } catch (e) {
                console.error('updateOpenPositionsUI error', e);
            }
        };

        const renderTopTrades = (count = 5) => {
            try {
                const trades = window.appState?.trades || [];
                const closedTrades = trades.filter(t => t.exit_price && t.exit_date);
                
                // Sort by P&L (best first) and limit to top 5 trades only
                const sortedTrades = closedTrades
                    .map(trade => ({ ...trade, pnl: calculateNetPnl(trade) }))
                    .sort((a, b) => b.pnl - a.pnl)
                    .slice(0, 5); // Always show only top 5 trades
                
                const container = document.getElementById('top-trades-widget');
                if (container) {
                    if (sortedTrades.length === 0) {
                        container.innerHTML = '<div class="flex-1 flex items-center justify-center"><p class="text-center text-sm" style="color: var(--text-secondary);">No completed trades yet.</p></div>';
                        return;
                    }
                    
                    container.innerHTML = sortedTrades.map((trade, index) => {
                        const pnl = trade.pnl;
                        const isProfit = pnl > 0;
                        const pnlClass = isProfit ? 'text-green-500' : 'text-red-500';
                        const pnlSign = isProfit ? '+' : '';
                        
                        return `
                            <div class="p-2 rounded-lg border" style="background-color: var(--bg-secondary); border-color: var(--border-color);">
                                <div class="flex justify-between items-center">
                                    <div class="flex items-center">
                                        <div class="w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${isProfit ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                            ${index + 1}
                                        </div>
                                        <div class="ml-2">
                                            <h4 class="font-semibold text-sm" style="color: var(--text-primary);">${trade.asset || 'N/A'}</h4>
                                            <p class="text-xs" style="color: var(--text-secondary);">${trade.direction || 'N/A'} • ${window.utils.formatDate(trade.exit_date)}</p>
                                        </div>
                                    </div>
                                    <div class="text-right">
                                        <p class="font-bold text-sm ${pnlClass}">${pnlSign}${window.utils.formatCurrency(pnl)}</p>
                                        <p class="text-xs" style="color: var(--text-muted);">${trade.quantity || 0} qty</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (e) {
                console.error('renderTopTrades error', e);
            }
        };

        // Render Top 5 Winners for Dashboard
        const renderDashboardTopWinners = () => {
            try {
                const trades = window.appState?.trades || [];
                const closedTrades = trades.filter(t => t.exit_price && t.exit_date);
                
                // Filter winners (positive P&L) and sort by P&L (best first)
                const winners = closedTrades
                    .map(trade => ({ ...trade, pnl: calculateNetPnl(trade) }))
                    .filter(trade => trade.pnl > 0)
                    .sort((a, b) => b.pnl - a.pnl)
                    .slice(0, 5);
                
                const container = document.getElementById('dashboard-top-winners');
                if (container) {
                    if (winners.length === 0) {
                        container.innerHTML = '<div class="flex-1 flex items-center justify-center"><p class="text-center text-sm" style="color: var(--text-secondary);">No profitable trades yet.</p></div>';
                        return;
                    }
                    
                    container.innerHTML = winners.map((trade, index) => {
                        const pnl = trade.pnl;
                        const pnlClass = 'text-green-500';
                        const pnlSign = '+';
                        
                        return `
                            <div class="flex justify-between items-center p-3 rounded-md" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="flex-1">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <p class="font-semibold text-sm" style="color: var(--text-primary);">${trade.asset || 'Unknown'}</p>
                                            <p class="text-xs" style="color: var(--text-secondary);">${trade.exit_date ? new Date(trade.exit_date).toLocaleDateString() : ''}</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="font-bold text-sm ${pnlClass}">${pnlSign}${window.utils.formatCurrency(pnl)}</p>
                                            <p class="text-xs" style="color: var(--text-muted);">${trade.quantity || 0} qty</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (e) {
                console.error('renderDashboardTopWinners error', e);
            }
        };

        // Render Top 5 Losers for Dashboard
        const renderDashboardTopLosers = () => {
            try {
                const trades = window.appState?.trades || [];
                const closedTrades = trades.filter(t => t.exit_price && t.exit_date);
                
                // Filter losers (negative P&L) and sort by P&L (worst first)
                const losers = closedTrades
                    .map(trade => ({ ...trade, pnl: calculateNetPnl(trade) }))
                    .filter(trade => trade.pnl < 0)
                    .sort((a, b) => a.pnl - b.pnl)
                    .slice(0, 5);
                
                const container = document.getElementById('dashboard-top-losers');
                if (container) {
                    if (losers.length === 0) {
                        container.innerHTML = '<div class="flex-1 flex items-center justify-center"><p class="text-center text-sm" style="color: var(--text-secondary);">No losing trades yet.</p></div>';
                        return;
                    }
                    
                    container.innerHTML = losers.map((trade, index) => {
                        const pnl = trade.pnl;
                        const pnlClass = 'text-red-500';
                        const pnlSign = '';
                        
                        return `
                            <div class="flex justify-between items-center p-3 rounded-md" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                                <div class="flex-1">
                                    <div class="flex items-center justify-between">
                                        <div>
                                            <p class="font-semibold text-sm" style="color: var(--text-primary);">${trade.asset || 'Unknown'}</p>
                                            <p class="text-xs" style="color: var(--text-secondary);">${trade.exit_date ? new Date(trade.exit_date).toLocaleDateString() : ''}</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="font-bold text-sm ${pnlClass}">${pnlSign}${window.utils.formatCurrency(pnl)}</p>
                                            <p class="text-xs" style="color: var(--text-muted);">${trade.quantity || 0} qty</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                }
            } catch (e) {
                console.error('renderDashboardTopLosers error', e);
            }
        };

        // Store chart instances to avoid duplicates
        const chartInstances = {};
        
        // Performance optimization: Cache system for expensive calculations
        const performanceCache = {
            tradeCalculations: new Map(),
            chartData: new Map(),
            lastTradesHash: null,
            
            // Generate hash for trades array to detect changes
            getTradesHash: (trades) => {
                if (!trades || !Array.isArray(trades)) return 'empty';
                return trades.length + '_' + (trades[0]?.id || '') + '_' + (trades[trades.length - 1]?.id || '');
            },
            
            // Cache trade calculations (PnL, etc.)
            getCachedTradeCalc: (tradeId, calcType, calculator) => {
                const key = `${tradeId}_${calcType}`;
                if (performanceCache.tradeCalculations.has(key)) {
                    return performanceCache.tradeCalculations.get(key);
                }
                const result = calculator();
                performanceCache.tradeCalculations.set(key, result);
                return result;
            },
            
            // Cache chart data
            getCachedChartData: (chartType, trades, calculator) => {
                const tradesHash = performanceCache.getTradesHash(trades);
                const key = `${chartType}_${tradesHash}`;
                if (performanceCache.chartData.has(key)) {
                    return performanceCache.chartData.get(key);
                }
                const result = calculator();
                performanceCache.chartData.set(key, result);
                return result;
            },
            
            // Clear cache when trades change
            clearCache: () => {
                performanceCache.tradeCalculations.clear();
                performanceCache.chartData.clear();
            },
            
            // Clear only chart cache
            clearChartCache: () => {
                performanceCache.chartData.clear();
            }
        };
        
        // Debounced chart rendering for better performance
        let chartRenderTimeout = null;
        const renderAllCharts = (forceRender = false) => {
            // Clear existing timeout
            if (chartRenderTimeout && !forceRender) {
                clearTimeout(chartRenderTimeout);
            }
            
            // Debounce chart rendering by 50ms to prevent excessive re-renders
            chartRenderTimeout = setTimeout(() => {
                try {
                    console.log('renderAllCharts called - Starting chart rendering');
                if (typeof Chart === 'undefined') {
                    console.warn('Chart.js not loaded');
                    return;
                }
                console.log('Chart.js is loaded, proceeding with chart rendering');
                
                // Check if we have data to render charts
                if (!Array.isArray(appState.trades) || appState.trades.length === 0) {
                    console.log('No trades data available for chart rendering');
                    return;
                }
                
                // Register zoom plugin if available
                if (typeof Chart !== 'undefined' && Chart.register) {
                    try {
                        if (typeof ChartZoom !== 'undefined') {
                            Chart.register(ChartZoom);
                            console.log('Chart.js zoom plugin registered successfully');
                        } else {
                            console.warn('ChartZoom plugin not found - keyboard navigation may not work');
                        }
                    } catch (e) {
                        console.warn('Failed to register zoom plugin:', e);
                    }
                } else {
                    console.warn('Chart.register not available - using older Chart.js version?');
                }

                // Get theme colors once for all charts
                const themeColors = getThemeColors();
                console.log('Theme colors for charts:', themeColors);

                const trades = Array.isArray(appState.trades) ? appState.trades : [];
                const ledger = Array.isArray(appState.ledger) ? appState.ledger : [];
                
                // Performance optimization: Cache filtered trades
                const closedTrades = performanceCache.getCachedChartData('closedTrades', trades, () => {
                    return trades.filter(t => t.exit_date && t.exit_price);
                });
                
                console.log('Data available:', {
                    trades: trades.length,
                    closedTrades: closedTrades.length,
                    ledger: ledger.length
                });
                
                // Calculate daily P&L from closed trades (with performance caching)
                const byDay = performanceCache.getCachedChartData('dailyPnL', closedTrades, () => {
                    const result = {};
                    closedTrades.forEach(t => {
                        if (!(t.exit_date && t.exit_price)) return;
                        
                        // Validate the exit_date before converting
                        const exitDate = new Date(t.exit_date);
                        if (isNaN(exitDate.getTime())) {
                            return; // Skip this trade
                        }
                        
                        const d = exitDate.toISOString().slice(0,10);
                        const pnl = calculateNetPnl(t);
                        if (isFinite(pnl)) {
                            result[d] = (result[d] || 0) + pnl;
                        }
                    });
                    return result;
                });
                
                // Calculate cumulative equity curve
                const sortedDays = Object.keys(byDay).sort();
                let cumulativePnl = 0;
                const equityData = sortedDays.map(day => {
                    cumulativePnl += byDay[day];
                    return cumulativePnl;
                });
                
                // Calculate account balance including deposits/withdrawals
                const deposits = ledger.filter(l => l.type === 'Deposit').reduce((s, l) => s + (l.amount || 0), 0);
                const withdrawals = ledger.filter(l => l.type === 'Withdrawal').reduce((s, l) => s + (l.amount || 0), 0);
                const baseBalance = deposits - withdrawals;
                
                const balanceData = sortedDays.map(day => {
                    const dayPnl = byDay[day];
                    const dayIndex = sortedDays.indexOf(day);
                    const cumulativeToDay = equityData[dayIndex];
                    return baseBalance + cumulativeToDay;
                });
                
                // Use real data only
                const labels = sortedDays.length > 0 ? sortedDays : [];
                let data = sortedDays.length > 0 ? sortedDays.map(d => byDay[d]) : [];

                const colorUp = 'rgba(34,197,94,0.7)';
                const colorDown = 'rgba(239,68,68,0.7)';

                const getCtx = (id) => {
                    const el = document.getElementById(id);
                    return el ? el.getContext('2d') : null;
                };

                const makeOrUpdate = (ctx, type, datasetLabel) => {
                    if (!ctx) return null;
                    
                    // Destroy existing chart if it exists
                    if (chartInstances[ctx.canvas.id]) {
                        chartInstances[ctx.canvas.id].destroy();
                    }
                    
                    const chart = new Chart(ctx, {
                        type,
                        data: {
                            labels,
                            datasets: [{
                                label: datasetLabel,
                                data,
                                backgroundColor: data.map(v => v >= 0 ? colorUp : colorDown),
                                borderColor: data.map(v => v >= 0 ? 'rgba(34,197,94,1)' : 'rgba(239,68,68,1)'),
                                borderWidth: 1,
                                fill: type === 'line' ? false : undefined,
                                tension: type === 'line' ? 0.4 : undefined
                            }]
                        },
                        options: { 
                            responsive: true, 
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: { 
                                legend: { display: false } 
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)'
                                    },
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor
                                    }
                                },
                                x: {
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)'
                                    },
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor
                                    }
                                }
                            }
                        }
                    });
                    
                    chartInstances[ctx.canvas.id] = chart;
                    return chart;
                };

                // Daily P&L Chart
                const dailyPnlCtx = getCtx('dailyPnlChart');
                if (dailyPnlCtx) {
                    if (chartInstances['dailyPnlChart']) {
                        // Clean up keyboard navigation before destroying chart
                        const oldChart = chartInstances['dailyPnlChart'];
                        if (oldChart._keyboardNavHandler) {
                            document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                        }
                        if (oldChart._mouseEnterHandler) {
                            oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                        }
                        if (oldChart._mouseLeaveHandler) {
                            oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                        }
                        if (oldChart._doubleClickHandler) {
                            oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                        }
                        // Clear performance flag
                        if (oldChart.canvas) {
                            oldChart.canvas._hasKeyboardNav = false;
                        }
                        oldChart.destroy();
                    }
                    
                    // Calculate daily P&L from trades with date normalization - use filtered trades
                    const dailyPnlData = {};
                    const filteredClosedTrades = filterTradesByTimePeriod(closedTrades, dailyPnlChartFilter);
                    filteredClosedTrades.forEach(trade => {
                        if (trade.exit_date) {
                            try {
                                // Normalize date to YYYY-MM-DD format for consistent grouping
                                const exitDate = new Date(trade.exit_date);
                                if (!isNaN(exitDate.getTime())) {
                                    const normalizedDate = exitDate.toISOString().split('T')[0];
                                    const pnl = calculateNetPnl(trade);
                                    if (isFinite(pnl)) {
                                        dailyPnlData[normalizedDate] = (dailyPnlData[normalizedDate] || 0) + pnl;
                                    }
                                }
                            } catch (e) {
                                console.warn('Daily P&L: Invalid exit_date for trade:', trade.id, trade.exit_date);
                            }
                        }
                    });
                    
                    const sortedDates = Object.keys(dailyPnlData).sort();
                    const labels = sortedDates.length > 0 ? sortedDates.map(date => window.utils.formatDateDDMMYYYY(date)) : [];
                    const data = sortedDates.length > 0 ? sortedDates.map(date => dailyPnlData[date]) : [];
                    
                    // Use real data only - no sample data
                    
                    const dailyPnlChart = new Chart(dailyPnlCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Daily P&L',
                                data: data,
                                backgroundColor: data.map(value => value >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
                                borderColor: data.map(value => value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'),
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            return `P&L: ₹${value.toLocaleString()}`;
                                        }
                                    }
                                }),
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                },
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: 'rgba(128, 128, 128, 0.1)' },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: { size: 11 }
                                    }
                                },
                                x: {
                                    grid: { color: 'rgba(128, 128, 128, 0.1)' },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: { size: 11 }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['dailyPnlChart'] = dailyPnlChart;
                    console.log('Daily P&L Chart created successfully');
                    
                    // Add robust keyboard navigation and zoom functionality for Daily P&L chart
                    const addDailyPnlKeyboardNav = () => {
                        // Skip if keyboard navigation already exists for this canvas
                        if (dailyPnlChart.canvas && dailyPnlChart.canvas._hasKeyboardNav) {
                            console.log('Daily P&L Chart: Keyboard navigation already exists, skipping');
                            return;
                        }
                        
                        // Validate chart and canvas exist
                        if (!dailyPnlChart || !dailyPnlChart.canvas) {
                            console.warn('Daily P&L Chart: Canvas not available for keyboard navigation');
                            return;
                        }
                        
                        // Validate zoom plugin is available
                        if (!dailyPnlChart.options?.plugins?.zoom?.pan?.enabled) {
                            console.warn('Daily P&L Chart: Zoom plugin pan not enabled in chart options');
                            return;
                        }
                        
                        let isChartFocused = false;
                        
                        // Create event handlers with proper error handling
                        const handleMouseEnter = () => {
                            try {
                                isChartFocused = true;
                                if (dailyPnlChart && dailyPnlChart.canvas) {
                                    dailyPnlChart.canvas.style.cursor = 'grab';
                                }
                            } catch (error) {
                                console.error('Daily P&L Chart: Mouse enter error', error);
                            }
                        };
                        
                        const handleMouseLeave = () => {
                            try {
                                isChartFocused = false;
                                if (dailyPnlChart && dailyPnlChart.canvas) {
                                    dailyPnlChart.canvas.style.cursor = 'default';
                                }
                            } catch (error) {
                                console.error('Daily P&L Chart: Mouse leave error', error);
                            }
                        };
                        
                        const handleKeyDown = (e) => {
                            try {
                                // Robust validation
                                if (!isChartFocused || !dailyPnlChart || !dailyPnlChart.canvas) {
                                    return;
                                }
                                
                                // Check if zoom plugin pan method is available
                                if (typeof dailyPnlChart.pan !== 'function') {
                                    console.warn('Daily P&L Chart: Pan method not available on chart instance');
                                    return;
                                }
                                
                                // Check for arrow keys (with fallback for older browsers)
                                const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;
                                
                                if (isLeftArrow || isRightArrow) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    // Calculate pan amount with safety checks
                                    const chartWidth = dailyPnlChart.width || 400; // fallback width
                                    const panAmount = chartWidth * 0.1;
                                    const direction = isLeftArrow ? -panAmount : panAmount;
                                    
                                    console.log('Daily P&L Chart: Attempting to pan', { 
                                        direction: isLeftArrow ? 'left' : 'right', 
                                        panAmount, 
                                        chartWidth 
                                    });
                                    
                                    // Perform pan with error handling - try multiple methods
                                    let panSuccess = false;
                                    
                                    // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                    try {
                                        if (typeof dailyPnlChart.pan === 'function') {
                                            dailyPnlChart.pan({x: direction});
                                            console.log('Daily P&L Chart: Direct pan method succeeded');
                                            panSuccess = true;
                                        }
                                    } catch (panError) {
                                        console.warn('Daily P&L Chart: Direct pan method failed', panError);
                                    }
                                    
                                    // Method 2: Zoom plugin instance method
                                    if (!panSuccess) {
                                        try {
                                            if (dailyPnlChart.$zoom && typeof dailyPnlChart.$zoom.pan === 'function') {
                                                dailyPnlChart.$zoom.pan({x: direction});
                                                console.log('Daily P&L Chart: $zoom.pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (zoomError) {
                                            console.warn('Daily P&L Chart: $zoom.pan method failed', zoomError);
                                        }
                                    }
                                    
                                    // Method 3: Manual scale adjustment (fallback)
                                    if (!panSuccess) {
                                        try {
                                            const xScale = dailyPnlChart.scales.x;
                                            if (xScale) {
                                                const range = xScale.max - xScale.min;
                                                const panPercent = direction / chartWidth;
                                                const panAmount = range * panPercent;
                                                
                                                dailyPnlChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                dailyPnlChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                dailyPnlChart.update('none'); // Update without animation
                                                console.log('Daily P&L Chart: Manual scale adjustment succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (scaleError) {
                                            console.warn('Daily P&L Chart: Manual scale adjustment failed', scaleError);
                                        }
                                    }
                                    
                                    if (!panSuccess) {
                                        console.error('Daily P&L Chart: All pan methods failed');
                                    }
                                }
                            } catch (error) {
                                console.error('Daily P&L Chart: Keyboard navigation error', error);
                            }
                        };
                        
                        // Add zoom reset on double-click
                        const handleDoubleClick = () => {
                            try {
                                if (dailyPnlChart && typeof dailyPnlChart.resetZoom === 'function') {
                                    dailyPnlChart.resetZoom();
                                    console.log('Daily P&L Chart: Zoom reset');
                                }
                            } catch (error) {
                                console.error('Daily P&L Chart: Zoom reset error', error);
                            }
                        };
                        
                        // Add event listeners with error handling
                        try {
                            dailyPnlChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                            dailyPnlChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                            dailyPnlChart.canvas.addEventListener('dblclick', handleDoubleClick);
                            document.addEventListener('keydown', handleKeyDown);
                            
                            // Store references for proper cleanup
                            dailyPnlChart._keyboardNavHandler = handleKeyDown;
                            dailyPnlChart._mouseEnterHandler = handleMouseEnter;
                            dailyPnlChart._mouseLeaveHandler = handleMouseLeave;
                            dailyPnlChart._doubleClickHandler = handleDoubleClick;
                            
                            // Mark canvas as having keyboard navigation to prevent duplicates
                            dailyPnlChart.canvas._hasKeyboardNav = true;
                            
                            // Debug: Log chart capabilities
                            console.log('Daily P&L Chart: Keyboard navigation initialized successfully');
                            console.log('Daily P&L Chart: Pan method available?', typeof dailyPnlChart.pan === 'function');
                            console.log('Daily P&L Chart: Zoom plugin config:', dailyPnlChart.options?.plugins?.zoom);
                        } catch (error) {
                            console.error('Daily P&L Chart: Failed to initialize keyboard navigation', error);
                        }
                    };
                    
                    // Initialize keyboard navigation with error handling
                    try {
                        addDailyPnlKeyboardNav();
                    } catch (error) {
                        console.error('Daily P&L Chart: Failed to add keyboard navigation', error);
                    }
                }
                
                // Equity Curve Chart - Trading Performance Only
                    const equityCtx = getCtx('equityCurveChart');
                    console.log('Equity Curve Chart - Canvas found:', !!equityCtx);
                    if (equityCtx) {
                        // Always destroy existing chart first to prevent canvas reuse errors
                        if (chartInstances['equityCurveChart']) {
                            try {
                                // Clean up keyboard navigation before destroying chart
                                const oldChart = chartInstances['equityCurveChart'];
                                if (oldChart._keyboardNavHandler) {
                                    document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                                }
                                if (oldChart._mouseEnterHandler) {
                                    oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                                }
                                if (oldChart._mouseLeaveHandler) {
                                    oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                                }
                                if (oldChart._doubleClickHandler) {
                                    oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                                }
                                // Clear performance flag
                                if (oldChart.canvas) {
                                    oldChart.canvas._hasKeyboardNav = false;
                                }
                                oldChart.destroy();
                                console.log('Equity Curve Chart - Previous chart destroyed successfully');
                            } catch (destroyError) {
                                console.warn('Equity Curve Chart - Error destroying previous chart:', destroyError);
                            }
                        }
                        
                        // Clear the chart instance reference
                        chartInstances['equityCurveChart'] = null;
                        
                        // Get all unique dates from trades only (not ledger)
                        const allDates = new Set();
                        
                        // Add trade dates - use filtered trades based on current filter
                        const allTrades = filterTradesByTimePeriod(appState.trades || [], equityChartFilter);
                        allTrades.forEach(trade => {
                            if (trade.entry_date) {
                                // Normalize date to YYYY-MM-DD format for proper sorting
                                try {
                                    const date = new Date(trade.entry_date);
                                    if (!isNaN(date.getTime())) {
                                        const normalizedDate = date.toISOString().split('T')[0];
                                        allDates.add(normalizedDate);
                                    } else {
                                        console.warn('Invalid entry_date:', trade.entry_date);
                                    }
                                } catch (e) {
                                    console.warn('Error parsing entry_date:', trade.entry_date, e);
                                }
                            }
                            if (trade.exit_date) {
                                // Normalize date to YYYY-MM-DD format for proper sorting
                                try {
                                    const date = new Date(trade.exit_date);
                                    if (!isNaN(date.getTime())) {
                                        const normalizedDate = date.toISOString().split('T')[0];
                                        allDates.add(normalizedDate);
                                    } else {
                                        console.warn('Invalid exit_date:', trade.exit_date);
                                    }
                                } catch (e) {
                                    console.warn('Error parsing exit_date:', trade.exit_date, e);
                                }
                            }
                        });
                        
                        // Sort dates (now they're in YYYY-MM-DD format so string sorting works)
                        const sortedDates = Array.from(allDates).sort();
                        
                        // If no trades, show empty chart
                        let chartLabels, equityData, segmentBreakdown;
                        
                        if (sortedDates.length === 0) {
                            // No trades - show empty chart
                            chartLabels = [];
                            equityData = [];
                            segmentBreakdown = [];
                            
                            console.log('Equity Curve Chart - No trades data available');
                        } else {
                            // Calculate trading equity for each date
                            chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                            equityData = [];
                            segmentBreakdown = [];
                            
                            console.log('Equity Curve Chart - Data length:', equityData.length);
                            console.log('Equity Curve Chart - Chart labels length:', chartLabels.length);
                            
                            sortedDates.forEach(date => {
                                // Calculate realized P&L by segment
                                const realizedPnlBySegment = {
                                    equity: 0,
                                    fno: 0,
                                    commodity: 0,
                                    currency: 0
                                };
                            
                            closedTrades
                                .filter(trade => trade.exit_date && trade.exit_date <= date)
                                .forEach(trade => {
                                    const segment = (trade.segment || 'equity').toLowerCase();
                                    const pnl = calculateNetPnl(trade);
                                    
                                    if (segment.includes('equity') || segment.includes('stock')) {
                                        realizedPnlBySegment.equity += pnl;
                                    } else if (segment.includes('fno') || segment.includes('derivative') || segment.includes('futures') || segment.includes('options')) {
                                        realizedPnlBySegment.fno += pnl;
                                    } else if (segment.includes('commodity') || segment.includes('gold') || segment.includes('silver') || segment.includes('crude')) {
                                        realizedPnlBySegment.commodity += pnl;
                                    } else if (segment.includes('currency') || segment.includes('forex') || segment.includes('usd') || segment.includes('eur')) {
                                        realizedPnlBySegment.currency += pnl;
                                    } else {
                                        realizedPnlBySegment.equity += pnl; // Default to equity
                                    }
                                });
                            
                            // Calculate unrealized P&L by segment (for open positions)
                            const unrealizedPnlBySegment = {
                                equity: 0,
                                fno: 0,
                                commodity: 0,
                                currency: 0
                            };
                            
                            // Use all trades (not just closedTrades) to find open positions
                            const allTrades = appState.trades || [];
                            allTrades
                                .filter(trade => {
                                    const entryDate = trade.entry_date;
                                    const exitDate = trade.exit_date;
                                    // Only include trades that are open (no exit date) or partially closed on this date
                                    return entryDate && entryDate <= date && (!exitDate || exitDate > date);
                                })
                                .forEach(trade => {
                                    const segment = (trade.segment || 'equity').toLowerCase();
                                    // For unrealized P&L, we'll set to 0 since we don't have current market prices
                                    // In a real system, you'd use current market prices: (currentPrice - entryPrice) * quantity
                                    const unrealizedPnl = 0; // Set to 0 for now since we don't have real-time prices
                                    const quantity = trade.quantity || 0;
                                    const pnl = unrealizedPnl * quantity;
                                    
                                    if (segment.includes('equity') || segment.includes('stock')) {
                                        unrealizedPnlBySegment.equity += pnl;
                                    } else if (segment.includes('fno') || segment.includes('derivative') || segment.includes('futures') || segment.includes('options')) {
                                        unrealizedPnlBySegment.fno += pnl;
                                    } else if (segment.includes('commodity') || segment.includes('gold') || segment.includes('silver') || segment.includes('crude')) {
                                        unrealizedPnlBySegment.commodity += pnl;
                                    } else if (segment.includes('currency') || segment.includes('forex') || segment.includes('usd') || segment.includes('eur')) {
                                        unrealizedPnlBySegment.currency += pnl;
                                    } else {
                                        unrealizedPnlBySegment.equity += pnl; // Default to equity
                                    }
                                });
                            
                            // Calculate total realized and unrealized P&L
                            const totalRealizedPnl = Object.values(realizedPnlBySegment).reduce((sum, pnl) => sum + pnl, 0);
                            const totalUnrealizedPnl = Object.values(unrealizedPnlBySegment).reduce((sum, pnl) => sum + pnl, 0);
                            
                            // Equity = Cumulative Trading P&L only (starts from 0, no starting balance)
                            const equity = totalRealizedPnl + totalUnrealizedPnl;
                            
                            equityData.push(equity);
                            segmentBreakdown.push({
                                equity: realizedPnlBySegment.equity + unrealizedPnlBySegment.equity,
                                fno: realizedPnlBySegment.fno + unrealizedPnlBySegment.fno,
                                commodity: realizedPnlBySegment.commodity + unrealizedPnlBySegment.commodity,
                                currency: realizedPnlBySegment.currency + unrealizedPnlBySegment.currency,
                                realized: totalRealizedPnl,
                                unrealized: totalUnrealizedPnl
                            });
                        });
                    }
                    

                        const equityChart = new Chart(equityCtx, {
                            type: 'line',
                            data: {
                                labels: chartLabels,
                                datasets: [
                                    {
                                        label: 'Equity Curve',
                                        data: equityData,
                                        borderColor: function(context) {
                                            const value = context.parsed?.y;
                                            if (value === undefined || value === null) {
                                                return 'rgba(20, 184, 166, 1)'; // Default teal color
                                            }
                                            return value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'; // Green for profit, Red for loss
                                        },
                                        backgroundColor: function(context) {
                                            const value = context.parsed?.y;
                                            if (value === undefined || value === null) {
                                                return 'rgba(20, 184, 166, 0.1)'; // Default teal color
                                            }
                                            return value >= 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)'; // Green for profit, Red for loss
                                        },
                                        borderWidth: 2,
                                        fill: true,
                                        tension: 0.6, // Enhanced spline curve for smoother appearance
                                        borderSkipped: false, // Ensures smooth area fill
                                        spanGaps: true, // Handles missing data points smoothly
                                        pointRadius: 2, // Smaller circles for cleaner appearance
                                        pointHoverRadius: 4 // Smaller hover circles
                                    }
                                ]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                aspectRatio: 2, // Wider aspect ratio like in the image
                                layout: {
                                    padding: 0
                                },
                                elements: {
                                    line: {
                                        tension: 0.6, // Enhanced spline curve for smoother rendering
                                        capBezierPoints: false // Smoother curve rendering
                                    }
                                },
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    borderColor: 'rgba(20, 184, 166, 1)',
                                    callbacks: {
                                        title: function(context) {
                                            return `Date: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            return `Equity: ₹${context.parsed.y.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                        }
                                    }
                                }),
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                }
                            },
                                scales: {
                                    y: {
                                        beginAtZero: false,
                                        grid: { 
                                            color: 'rgba(128, 128, 128, 0.1)',
                                            drawBorder: false
                                        },
                                        ticks: {
                                            callback: function(value) {
                                                return '₹' + value.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                                            },
                                            color: themeColors.chartText || themeColors.textColor,
                                            font: {
                                                size: 11
                                            }
                                        }
                                    },
                                    x: {
                                        grid: { 
                                            color: 'rgba(128, 128, 128, 0.1)',
                                            drawBorder: false
                                        },
                                        ticks: {
                                            color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                            font: {
                                                size: 11
                                            },
                                            maxRotation: 45,
                                            minRotation: 0
                                        }
                                    }
                                }
                            }
                        });
                        chartInstances['equityCurveChart'] = equityChart;
                        console.log('Equity Curve Chart created successfully');
                        
                        // Add robust keyboard navigation and zoom functionality for equity curve chart
                        const addEquityCurveKeyboardNav = () => {
                            // Skip if keyboard navigation already exists for this canvas
                            if (equityChart.canvas && equityChart.canvas._hasKeyboardNav) {
                                console.log('Equity Curve Chart: Keyboard navigation already exists, skipping');
                                return;
                            }
                            
                            // Validate chart and canvas exist
                            if (!equityChart || !equityChart.canvas) {
                                console.warn('Equity Curve Chart: Canvas not available for keyboard navigation');
                                return;
                            }
                            
                            // Validate zoom plugin is available
                            if (!equityChart.options?.plugins?.zoom?.pan?.enabled) {
                                console.warn('Equity Curve Chart: Zoom plugin pan not enabled in chart options');
                                return;
                            }
                            
                            let isChartFocused = false;
                            
                            // Create event handlers with proper error handling
                            const handleMouseEnter = () => {
                                try {
                                    isChartFocused = true;
                                    if (equityChart && equityChart.canvas) {
                                        equityChart.canvas.style.cursor = 'grab';
                                    }
                                } catch (error) {
                                    console.error('Equity Curve Chart: Mouse enter error', error);
                                }
                            };
                            
                            const handleMouseLeave = () => {
                                try {
                                    isChartFocused = false;
                                    if (equityChart && equityChart.canvas) {
                                        equityChart.canvas.style.cursor = 'default';
                                    }
                                } catch (error) {
                                    console.error('Equity Curve Chart: Mouse leave error', error);
                                }
                            };
                            
                            const handleKeyDown = (e) => {
                                try {
                                    // Robust validation
                                    if (!isChartFocused || !equityChart || !equityChart.canvas) {
                                        return;
                                    }
                                    
                                    // Check if zoom plugin pan method is available
                                    if (typeof equityChart.pan !== 'function') {
                                        console.warn('Equity Curve Chart: Pan method not available on chart instance');
                                        return;
                                    }
                                    
                                    // Check for arrow keys (with fallback for older browsers)
                                    const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                    const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;
                                    
                                    if (isLeftArrow || isRightArrow) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        
                                        // Calculate pan amount with safety checks
                                        const chartWidth = equityChart.width || 400; // fallback width
                                        const panAmount = chartWidth * 0.1;
                                        const direction = isLeftArrow ? -panAmount : panAmount;
                                        
                                        console.log('Equity Curve Chart: Attempting to pan', { 
                                            direction: isLeftArrow ? 'left' : 'right', 
                                            panAmount, 
                                            chartWidth 
                                        });
                                        
                                        // Perform pan with error handling - try multiple methods
                                        let panSuccess = false;
                                        
                                        // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                        try {
                                            if (typeof equityChart.pan === 'function') {
                                                equityChart.pan({x: direction});
                                                console.log('Equity Curve Chart: Direct pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (panError) {
                                            console.warn('Equity Curve Chart: Direct pan method failed', panError);
                                        }
                                        
                                        // Method 2: Zoom plugin instance method
                                        if (!panSuccess) {
                                            try {
                                                if (equityChart.$zoom && typeof equityChart.$zoom.pan === 'function') {
                                                    equityChart.$zoom.pan({x: direction});
                                                    console.log('Equity Curve Chart: $zoom.pan method succeeded');
                                                    panSuccess = true;
                                                }
                                            } catch (zoomError) {
                                                console.warn('Equity Curve Chart: $zoom.pan method failed', zoomError);
                                            }
                                        }
                                        
                                        // Method 3: Manual scale adjustment (fallback)
                                        if (!panSuccess) {
                                            try {
                                                const xScale = equityChart.scales.x;
                                                if (xScale) {
                                                    const range = xScale.max - xScale.min;
                                                    const panPercent = direction / chartWidth;
                                                    const panAmount = range * panPercent;
                                                    
                                                    equityChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                    equityChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                    equityChart.update('none'); // Update without animation
                                                    console.log('Equity Curve Chart: Manual scale adjustment succeeded');
                                                    panSuccess = true;
                                                }
                                            } catch (scaleError) {
                                                console.warn('Equity Curve Chart: Manual scale adjustment failed', scaleError);
                                            }
                                        }
                                        
                                        if (!panSuccess) {
                                            console.error('Equity Curve Chart: All pan methods failed');
                                        }
                                    }
                                } catch (error) {
                                    console.error('Equity Curve Chart: Keyboard navigation error', error);
                                }
                            };
                            
                            // Add zoom reset on double-click
                            const handleDoubleClick = () => {
                                try {
                                    if (equityChart && typeof equityChart.resetZoom === 'function') {
                                        equityChart.resetZoom();
                                        console.log('Equity Curve Chart: Zoom reset');
                                    }
                                } catch (error) {
                                    console.error('Equity Curve Chart: Zoom reset error', error);
                                }
                            };
                            
                            // Add event listeners with error handling
                            try {
                                equityChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                                equityChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                                equityChart.canvas.addEventListener('dblclick', handleDoubleClick);
                                document.addEventListener('keydown', handleKeyDown);
                                
                                // Store references for proper cleanup
                                equityChart._keyboardNavHandler = handleKeyDown;
                                equityChart._mouseEnterHandler = handleMouseEnter;
                                equityChart._mouseLeaveHandler = handleMouseLeave;
                                equityChart._doubleClickHandler = handleDoubleClick;
                                
                                // Mark canvas as having keyboard navigation to prevent duplicates
                                equityChart.canvas._hasKeyboardNav = true;
                                
                                // Debug: Log chart capabilities
                                console.log('Equity Curve Chart: Keyboard navigation initialized successfully');
                                console.log('Equity Curve Chart: Pan method available?', typeof equityChart.pan === 'function');
                                console.log('Equity Curve Chart: Zoom plugin config:', equityChart.options?.plugins?.zoom);
                            } catch (error) {
                                console.error('Equity Curve Chart: Failed to initialize keyboard navigation', error);
                            }
                        };
                        
                        // Initialize keyboard navigation with error handling
                        try {
                            addEquityCurveKeyboardNav();
                        } catch (error) {
                            console.error('Equity Curve Chart: Failed to add keyboard navigation', error);
                        }
                }
                
                // Account Balance Chart - Account Value Only
                const balanceCtx = getCtx('accountBalanceChart');
                console.log('Account Balance Chart - Canvas found:', !!balanceCtx);
                if (balanceCtx) {
                    if (chartInstances['accountBalanceChart']) {
                        // Clean up keyboard navigation before destroying chart
                        const oldChart = chartInstances['accountBalanceChart'];
                        if (oldChart._keyboardNavHandler) {
                            document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                        }
                        if (oldChart._mouseEnterHandler) {
                            oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                        }
                        if (oldChart._mouseLeaveHandler) {
                            oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                        }
                        if (oldChart._doubleClickHandler) {
                            oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                        }
                        // Clear performance flag
                        if (oldChart.canvas) {
                            oldChart.canvas._hasKeyboardNav = false;
                        }
                        oldChart.destroy();
                    }
                    
                    
                    // Get first deposit to determine starting point
                    const firstDeposit = ledger.find(l => l.type === 'Deposit');
                    const initialBalance = firstDeposit ? firstDeposit.amount : 100000; // Default to 1L if no deposits
                    
                    // Get all unique dates from trades and ledger
                    const allDates = new Set();
                    
                    // Add trade dates - use filtered trades based on current filter
                    const allTrades = filterTradesByTimePeriod(appState.trades || [], balanceChartFilter);
                    allTrades.forEach(trade => {
                        if (trade.entry_date) {
                            try {
                                // Normalize date to YYYY-MM-DD format (strip time component)
                                const date = new Date(trade.entry_date);
                                if (!isNaN(date.getTime())) {
                                    const normalizedDate = date.toISOString().split('T')[0];
                                    allDates.add(normalizedDate);
                                } else {
                                    console.warn('Invalid entry_date:', trade.entry_date);
                                }
                            } catch (e) {
                                console.warn('Error parsing entry_date:', trade.entry_date, e);
                            }
                        }
                        if (trade.exit_date) {
                            try {
                                // Normalize date to YYYY-MM-DD format (strip time component)
                                const date = new Date(trade.exit_date);
                                if (!isNaN(date.getTime())) {
                                    const normalizedDate = date.toISOString().split('T')[0];
                                    allDates.add(normalizedDate);
                                } else {
                                    console.warn('Invalid exit_date:', trade.exit_date);
                                }
                            } catch (e) {
                                console.warn('Error parsing exit_date:', trade.exit_date, e);
                            }
                        }
                    });
                    
                    // Add ledger dates
                    ledger.forEach(entry => {
                        if (entry.date) {
                            try {
                                // Handle DD-MM-YYYY format
                                let date;
                                if (entry.date.includes('-') && entry.date.split('-')[0].length === 2) {
                                    // DD-MM-YYYY format
                                    const [day, month, year] = entry.date.split('-');
                                    date = new Date(year, month - 1, day);
                                } else {
                                    // Standard format
                                    date = new Date(entry.date);
                                }
                                
                                if (!isNaN(date.getTime())) {
                                    const normalizedDate = date.toISOString().split('T')[0];
                                    allDates.add(normalizedDate);
                                } else {
                                    console.warn('Invalid ledger date:', entry.date);
                                }
                            } catch (e) {
                                console.warn('Error parsing ledger date:', entry.date, e);
                            }
                        }
                    });
                    
                    // Deduplicate entries so each date appears once - keep the last balance of the day (highest timestamp)
                    // This prevents duplicate x-axis dates when multiple entries exist for the same day
                    const deduplicatedDates = Array.from(allDates);
                    
                    // Sort dates
                    const sortedDates = deduplicatedDates.sort();
                    
                    console.log('Account Balance Chart - sortedDates:', sortedDates);
                    console.log('Account Balance Chart - ledger length:', ledger.length);
                    console.log('Account Balance Chart - trades length:', allTrades.length);
                    
                    // Use real data only
                    let chartLabels, accountValueData, cumulativeDeposits, cumulativeWithdrawals, cumulativePnl;
                    
                    if (sortedDates.length === 0) {
                        // No data available
                        chartLabels = [];
                        accountValueData = [];
                        cumulativeDeposits = [];
                        cumulativeWithdrawals = [];
                        cumulativePnl = [];
                    } else {
                        // Calculate cumulative values for each date
                        chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                        accountValueData = [];
                        cumulativeDeposits = [];
                        cumulativeWithdrawals = [];
                        cumulativePnl = [];
                        
                        sortedDates.forEach(date => {
                            // Calculate deposits and withdrawals up to this date
                            // Normalize ledger dates for comparison
                            const depositsToDate = ledger
                                .filter(l => {
                                    if (l.type !== 'Deposit' || !l.date) return false;
                                    try {
                                        // Handle DD-MM-YYYY format
                                        let ledgerDate;
                                        if (l.date.includes('-') && l.date.split('-')[0].length === 2) {
                                            // DD-MM-YYYY format
                                            const [day, month, year] = l.date.split('-');
                                            ledgerDate = new Date(year, month - 1, day).toISOString().split('T')[0];
                                        } else {
                                            // Standard format
                                            ledgerDate = new Date(l.date).toISOString().split('T')[0];
                                        }
                                        return ledgerDate <= date;
                                    } catch (e) {
                                        console.warn('Error comparing deposit date:', l.date, e);
                                        return false;
                                    }
                                })
                                .reduce((sum, l) => sum + (l.amount || 0), 0);
                            
                            const withdrawalsToDate = ledger
                                .filter(l => {
                                    if (l.type !== 'Withdrawal' || !l.date) return false;
                                    try {
                                        // Handle DD-MM-YYYY format
                                        let ledgerDate;
                                        if (l.date.includes('-') && l.date.split('-')[0].length === 2) {
                                            // DD-MM-YYYY format
                                            const [day, month, year] = l.date.split('-');
                                            ledgerDate = new Date(year, month - 1, day).toISOString().split('T')[0];
                                        } else {
                                            // Standard format
                                            ledgerDate = new Date(l.date).toISOString().split('T')[0];
                                        }
                                        return ledgerDate <= date;
                                    } catch (e) {
                                        console.warn('Error comparing withdrawal date:', l.date, e);
                                        return false;
                                    }
                                })
                                .reduce((sum, l) => sum + (l.amount || 0), 0);
                            
                            // Calculate P&L up to this date
                            // Normalize trade exit dates for comparison
                            const pnlToDate = closedTrades
                                .filter(trade => {
                                    if (!trade.exit_date) return false;
                                    try {
                                        // Use date parsing that avoids timezone conversion issues
                                        let tradeDate;
                                        if (trade.exit_date.includes('T')) {
                                            // ISO format: 2024-01-15T10:30:00 - extract date part only
                                            tradeDate = trade.exit_date.split('T')[0];
                                        } else {
                                            // Date only format: 2024-01-15 - use as is
                                            tradeDate = trade.exit_date;
                                        }
                                        
                                        // Validate the date format
                                        if (!/^\d{4}-\d{2}-\d{2}$/.test(tradeDate)) {
                                            console.warn('Invalid exit_date format in PnL calculation:', trade.exit_date);
                                            return false;
                                        }
                                        
                                        return tradeDate <= date;
                                    } catch (e) {
                                        console.warn('Error comparing trade exit date:', trade.exit_date, e);
                                        return false;
                                    }
                                })
                                .reduce((sum, trade) => {
                                    const pnl = calculateNetPnl(trade);
                                    return sum + (isNaN(pnl) ? 0 : pnl);
                                }, 0);
                            
                            // Account Value = starting balance + deposits - withdrawals + P&L
                            // This shows the complete account value progression
                            const startingBalance = parseFloat(appState.startingBalance) || 0;
                            const accountValue = startingBalance + depositsToDate - withdrawalsToDate + pnlToDate;
                            
                            // Ensure no NaN values
                            accountValueData.push(isNaN(accountValue) ? 0 : accountValue);
                            cumulativeDeposits.push(isNaN(depositsToDate) ? 0 : depositsToDate);
                            cumulativeWithdrawals.push(isNaN(withdrawalsToDate) ? 0 : withdrawalsToDate);
                            cumulativePnl.push(isNaN(pnlToDate) ? 0 : pnlToDate);
                        });
                    }
                    
                    console.log('Account Balance Chart - Final data:', {
                        chartLabels: chartLabels,
                        accountValueData: accountValueData,
                        chartLabelsLength: chartLabels.length,
                        accountValueDataLength: accountValueData.length
                    });
                    
                    
                    const balanceChart = new Chart(balanceCtx, {
                        type: 'line',
                        data: {
                            labels: chartLabels,
                            datasets: [
                                {
                                    label: 'Account Value',
                                    data: accountValueData,
                                    borderColor: function(context) {
                                        const value = context.parsed?.y;
                                        if (value === undefined || value === null) {
                                            return 'rgba(20, 184, 166, 1)'; // Default teal color
                                        }
                                        return value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'; // Green for profit, Red for loss
                                    },
                                    backgroundColor: function(context) {
                                        const value = context.parsed?.y;
                                        if (value === undefined || value === null) {
                                            return 'rgba(20, 184, 166, 0.1)'; // Default teal color
                                        }
                                        return value >= 0 ? 'rgba(34, 197, 94, 0.1)' : 'rgba(239, 68, 68, 0.1)'; // Green for profit, Red for loss
                                    },
                                    borderWidth: 2,
                                    fill: true,
                                    tension: 0.6, // Enhanced spline curve for smoother appearance
                                    borderSkipped: false, // Ensures smooth area fill
                                    spanGaps: true, // Handles missing data points smoothly
                                    pointRadius: 2, // Smaller circles for cleaner appearance
                                    pointHoverRadius: 4 // Smaller hover circles
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            elements: {
                                line: {
                                    tension: 0.6, // Enhanced spline curve for smoother rendering
                                    capBezierPoints: false // Smoother curve rendering
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    borderColor: function(context) {
                                        const value = context.parsed?.y;
                                        if (value === undefined || value === null) {
                                            return 'rgba(20, 184, 166, 1)'; // Default teal color
                                        }
                                        return value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'; // Green for profit, Red for loss
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            return `Date: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            return `Account Value: ₹${context.parsed.y.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                        }
                                    }
                                }),
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                },
                            },
                            scales: {
                                y: {
                                    beginAtZero: false,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                                        },
                                        color: themeColors.chartText || themeColors.textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                x: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        },
                                        maxRotation: 45,
                                        minRotation: 0
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['accountBalanceChart'] = balanceChart;
                    console.log('Account Balance Chart created successfully');
                    
                    // Add robust keyboard navigation for account balance chart (performance optimized)
                    const addAccountBalanceKeyboardNav = () => {
                        // Skip if keyboard navigation already exists for this canvas
                        if (balanceChart.canvas && balanceChart.canvas._hasKeyboardNav) {
                            console.log('Account Balance Chart: Keyboard navigation already exists, skipping');
                            return;
                        }
                        
                        // Validate chart and canvas exist
                        if (!balanceChart || !balanceChart.canvas) {
                            console.warn('Account Balance Chart: Canvas not available for keyboard navigation');
                            return;
                        }
                        
                        // Validate zoom plugin is available
                        if (!balanceChart.options?.plugins?.zoom?.pan?.enabled) {
                            console.warn('Account Balance Chart: Zoom plugin pan not enabled in chart options');
                            return;
                        }
                        
                        let isChartFocused = false;
                        
                        // Create event handlers with proper error handling
                        const handleMouseEnter = () => {
                            try {
                                isChartFocused = true;
                                if (balanceChart && balanceChart.canvas) {
                                    balanceChart.canvas.style.cursor = 'grab';
                                }
                            } catch (error) {
                                console.error('Account Balance Chart: Mouse enter error', error);
                            }
                        };
                        
                        const handleMouseLeave = () => {
                            try {
                                isChartFocused = false;
                                if (balanceChart && balanceChart.canvas) {
                                    balanceChart.canvas.style.cursor = 'default';
                                }
                            } catch (error) {
                                console.error('Account Balance Chart: Mouse leave error', error);
                            }
                        };
                        
                        const handleKeyDown = (e) => {
                            try {
                                // Robust validation
                                if (!isChartFocused || !balanceChart || !balanceChart.canvas) {
                                    return;
                                }
                                
                                // Check if zoom plugin pan method is available
                                if (typeof balanceChart.pan !== 'function') {
                                    console.warn('Account Balance Chart: Pan method not available on chart instance');
                                    return;
                                }
                                
                                // Check for arrow keys (with fallback for older browsers)
                                const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;
                                
                                if (isLeftArrow || isRightArrow) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    // Calculate pan amount with safety checks
                                    const chartWidth = balanceChart.width || 400; // fallback width
                                    const panAmount = chartWidth * 0.1;
                                    const direction = isLeftArrow ? -panAmount : panAmount;
                                    
                                    console.log('Account Balance Chart: Attempting to pan', { 
                                        direction: isLeftArrow ? 'left' : 'right', 
                                        panAmount, 
                                        chartWidth 
                                    });
                                    
                                    // Perform pan with error handling - try multiple methods
                                    let panSuccess = false;
                                    
                                    // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                    try {
                                        if (typeof balanceChart.pan === 'function') {
                                            balanceChart.pan({x: direction});
                                            console.log('Account Balance Chart: Direct pan method succeeded');
                                            panSuccess = true;
                                        }
                                    } catch (panError) {
                                        console.warn('Account Balance Chart: Direct pan method failed', panError);
                                    }
                                    
                                    // Method 2: Zoom plugin instance method
                                    if (!panSuccess) {
                                        try {
                                            if (balanceChart.$zoom && typeof balanceChart.$zoom.pan === 'function') {
                                                balanceChart.$zoom.pan({x: direction});
                                                console.log('Account Balance Chart: $zoom.pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (zoomError) {
                                            console.warn('Account Balance Chart: $zoom.pan method failed', zoomError);
                                        }
                                    }
                                    
                                    // Method 3: Manual scale adjustment (fallback)
                                    if (!panSuccess) {
                                        try {
                                            const xScale = balanceChart.scales.x;
                                            if (xScale) {
                                                const range = xScale.max - xScale.min;
                                                const panPercent = direction / chartWidth;
                                                const panAmount = range * panPercent;
                                                
                                                balanceChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                balanceChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                balanceChart.update('none'); // Update without animation
                                                console.log('Account Balance Chart: Manual scale adjustment succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (scaleError) {
                                            console.warn('Account Balance Chart: Manual scale adjustment failed', scaleError);
                                        }
                                    }
                                    
                                    if (!panSuccess) {
                                        console.error('Account Balance Chart: All pan methods failed');
                                    }
                                }
                            } catch (error) {
                                console.error('Account Balance Chart: Keyboard navigation error', error);
                            }
                        };
                        
                        // Add zoom reset on double-click
                        const handleDoubleClick = () => {
                            try {
                                if (balanceChart && typeof balanceChart.resetZoom === 'function') {
                                    balanceChart.resetZoom();
                                    console.log('Account Balance Chart: Zoom reset');
                                }
                            } catch (error) {
                                console.error('Account Balance Chart: Zoom reset error', error);
                            }
                        };
                        
                        // Add event listeners with error handling
                        try {
                            balanceChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                            balanceChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                            balanceChart.canvas.addEventListener('dblclick', handleDoubleClick);
                            document.addEventListener('keydown', handleKeyDown);
                            
                            // Store references for proper cleanup
                            balanceChart._keyboardNavHandler = handleKeyDown;
                            balanceChart._mouseEnterHandler = handleMouseEnter;
                            balanceChart._mouseLeaveHandler = handleMouseLeave;
                            balanceChart._doubleClickHandler = handleDoubleClick;
                            
                            // Mark canvas as having keyboard navigation to prevent duplicates
                            balanceChart.canvas._hasKeyboardNav = true;
                            
                            // Debug: Log chart capabilities
                            console.log('Account Balance Chart: Keyboard navigation initialized successfully');
                            console.log('Account Balance Chart: Pan method available?', typeof balanceChart.pan === 'function');
                            console.log('Account Balance Chart: Zoom plugin config:', balanceChart.options?.plugins?.zoom);
                            console.log('Account Balance Chart: Chart instance methods:', Object.getOwnPropertyNames(balanceChart).filter(name => typeof balanceChart[name] === 'function'));
                        } catch (error) {
                            console.error('Account Balance Chart: Failed to initialize keyboard navigation', error);
                        }
                    };
                    
                    // Initialize keyboard navigation with error handling
                    try {
                        addAccountBalanceKeyboardNav();
                    } catch (error) {
                        console.error('Account Balance Chart: Failed to add keyboard navigation', error);
                    }
                }
                
                // Monthly Performance Chart
                const monthlyCtx = getCtx('monthlyPerformanceChart');
                if (monthlyCtx) {
                    if (chartInstances['monthlyPerformanceChart']) {
                        // Clean up keyboard navigation before destroying chart
                        const oldChart = chartInstances['monthlyPerformanceChart'];
                        if (oldChart._keyboardNavHandler) {
                            document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                        }
                        if (oldChart._mouseEnterHandler) {
                            oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                        }
                        if (oldChart._mouseLeaveHandler) {
                            oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                        }
                        if (oldChart._doubleClickHandler) {
                            oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                        }
                        // Clear performance flag
                        if (oldChart.canvas) {
                            oldChart.canvas._hasKeyboardNav = false;
                        }
                        oldChart.destroy();
                    }
                    
                    console.log('Creating Monthly Performance Chart with closedTrades:', closedTrades.length);
                    
                    // Calculate monthly P&L from trades - use filtered trades
                    const monthlyPnlData = {};
                    let totalTrades = 0;
                    let totalPnl = 0;
                    
                    const filteredClosedTrades = filterTradesByTimePeriod(closedTrades, monthlyPerformanceChartFilter);
                    filteredClosedTrades.forEach(trade => {
                        if (trade.exit_date) {
                            const date = new Date(trade.exit_date);
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            const pnl = calculateNetPnl(trade);
                            monthlyPnlData[monthKey] = (monthlyPnlData[monthKey] || 0) + pnl;
                            totalTrades++;
                            totalPnl += pnl;
                        }
                    });
                    
                    console.log('Monthly P&L Data:', monthlyPnlData);
                    console.log('Total trades processed:', totalTrades, 'Total P&L:', totalPnl);
                    
                    const sortedMonths = Object.keys(monthlyPnlData).sort();
                    const labels = sortedMonths.length > 0 ? sortedMonths.map(month => {
                        // Convert "2024-01" to "JAN 2024"
                        const [year, monthNum] = month.split('-');
                        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                          'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                        const monthName = monthNames[parseInt(monthNum) - 1];
                        return `${monthName} ${year}`;
                    }) : [];
                    const data = sortedMonths.length > 0 ? sortedMonths.map(month => monthlyPnlData[month]) : [];
                    
                    // Use real data only - no sample data
                    
                    console.log('Monthly chart labels:', labels);
                    console.log('Monthly chart data:', data);
                    
                    const monthlyChart = new Chart(monthlyCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Monthly P&L',
                                data: data,
                                backgroundColor: data.map(value => value >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
                                borderColor: data.map(value => value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'),
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    callbacks: {
                                        title: function(context) {
                                            return `Month: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            const isProfit = value >= 0;
                                            return [
                                                `Monthly P&L: ₹${value.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`,
                                                `Status: ${isProfit ? 'Profit' : 'Loss'}`
                                            ];
                                        }
                                    }
                                }),
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString('en-IN', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: { size: 11 }
                                    }
                                },
                                x: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: { size: 11 }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['monthlyPerformanceChart'] = monthlyChart;
                    console.log('Monthly Performance Chart created successfully');
                    
                    // Add keyboard navigation and zoom functionality for Monthly Performance Chart
                    const addMonthlyPerformanceKeyboardNav = () => {
                        // Skip if keyboard navigation already exists for this canvas
                        if (monthlyChart.canvas && monthlyChart.canvas._hasKeyboardNav) {
                            console.log('Monthly Performance Chart: Keyboard navigation already exists, skipping');
                            return;
                        }

                        // Validate chart and canvas exist
                        if (!monthlyChart || !monthlyChart.canvas) {
                            console.warn('Monthly Performance Chart: Canvas not available for keyboard navigation');
                            return;
                        }

                        // Validate zoom plugin is available
                        if (!monthlyChart.options?.plugins?.zoom?.pan?.enabled) {
                            console.warn('Monthly Performance Chart: Zoom plugin pan not enabled in chart options');
                            return;
                        }

                        let isChartFocused = false;

                        // Create event handlers with proper error handling
                        const handleMouseEnter = () => {
                            try {
                                isChartFocused = true;
                                if (monthlyChart && monthlyChart.canvas) {
                                    monthlyChart.canvas.style.cursor = 'grab';
                                }
                            } catch (error) {
                                console.error('Monthly Performance Chart: Mouse enter error', error);
                            }
                        };

                        const handleMouseLeave = () => {
                            try {
                                isChartFocused = false;
                                if (monthlyChart && monthlyChart.canvas) {
                                    monthlyChart.canvas.style.cursor = 'default';
                                }
                            } catch (error) {
                                console.error('Monthly Performance Chart: Mouse leave error', error);
                            }
                        };

                        const handleKeyDown = (e) => {
                            try {
                                // Robust validation
                                if (!isChartFocused || !monthlyChart || !monthlyChart.canvas) {
                                    return;
                                }

                                // Check for arrow keys (with fallback for older browsers)
                                const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;

                                if (isLeftArrow || isRightArrow) {
                                    e.preventDefault();
                                    e.stopPropagation();

                                    // Calculate pan amount with safety checks
                                    const chartWidth = monthlyChart.width || 400; // fallback width
                                    const panAmount = chartWidth * 0.1;
                                    const direction = isLeftArrow ? -panAmount : panAmount;

                                    console.log('Monthly Performance Chart: Attempting to pan', {
                                        direction: isLeftArrow ? 'left' : 'right',
                                        panAmount,
                                        chartWidth
                                    });

                                    // Perform pan with error handling - try multiple methods
                                    let panSuccess = false;

                                    // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                    try {
                                        if (typeof monthlyChart.pan === 'function') {
                                            monthlyChart.pan({x: direction});
                                            console.log('Monthly Performance Chart: Direct pan method succeeded');
                                            panSuccess = true;
                                        }
                                    } catch (panError) {
                                        console.warn('Monthly Performance Chart: Direct pan method failed', panError);
                                    }

                                    // Method 2: Zoom plugin instance method
                                    if (!panSuccess) {
                                        try {
                                            if (monthlyChart.$zoom && typeof monthlyChart.$zoom.pan === 'function') {
                                                monthlyChart.$zoom.pan({x: direction});
                                                console.log('Monthly Performance Chart: $zoom.pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (zoomError) {
                                            console.warn('Monthly Performance Chart: $zoom.pan method failed', zoomError);
                                        }
                                    }

                                    // Method 3: Manual scale adjustment (fallback)
                                    if (!panSuccess) {
                                        try {
                                            const xScale = monthlyChart.scales.x;
                                            if (xScale) {
                                                const range = xScale.max - xScale.min;
                                                const panPercent = direction / chartWidth;
                                                const panAmount = range * panPercent;

                                                monthlyChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                monthlyChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                monthlyChart.update('none'); // Update without animation
                                                console.log('Monthly Performance Chart: Manual scale adjustment succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (scaleError) {
                                            console.warn('Monthly Performance Chart: Manual scale adjustment failed', scaleError);
                                        }
                                    }

                                    if (!panSuccess) {
                                        console.error('Monthly Performance Chart: All pan methods failed');
                                    }
                                }
                            } catch (error) {
                                console.error('Monthly Performance Chart: Keyboard navigation error', error);
                            }
                        };

                        // Add zoom reset on double-click
                        const handleDoubleClick = () => {
                            try {
                                if (monthlyChart && typeof monthlyChart.resetZoom === 'function') {
                                    monthlyChart.resetZoom();
                                    console.log('Monthly Performance Chart: Zoom reset');
                                }
                            } catch (error) {
                                console.error('Monthly Performance Chart: Zoom reset error', error);
                            }
                        };

                        // Add event listeners with error handling
                        try {
                            monthlyChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                            monthlyChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                            monthlyChart.canvas.addEventListener('dblclick', handleDoubleClick);
                            document.addEventListener('keydown', handleKeyDown);

                            // Store references for proper cleanup
                            monthlyChart._keyboardNavHandler = handleKeyDown;
                            monthlyChart._mouseEnterHandler = handleMouseEnter;
                            monthlyChart._mouseLeaveHandler = handleMouseLeave;
                            monthlyChart._doubleClickHandler = handleDoubleClick;

                            // Mark canvas as having keyboard navigation to prevent duplicates
                            monthlyChart.canvas._hasKeyboardNav = true;

                            // Debug: Log chart capabilities
                            console.log('Monthly Performance Chart: Keyboard navigation initialized successfully');
                        } catch (error) {
                            console.error('Monthly Performance Chart: Failed to initialize keyboard navigation', error);
                        }
                    };

                    // Initialize keyboard navigation with error handling
                    try {
                        addMonthlyPerformanceKeyboardNav();
                    } catch (error) {
                        console.error('Monthly Performance Chart: Failed to add keyboard navigation', error);
                    }
                } else {
                    console.log('Monthly Performance Chart canvas not found');
                }
                
                // P&L by Segment Chart
                const segmentCtx = getCtx('pnlBySegmentChart');
                if (segmentCtx) {
                    if (chartInstances['pnlBySegmentChart']) {
                        chartInstances['pnlBySegmentChart'].destroy();
                    }
                    
                    // Calculate P&L by segment
                    const segmentData = {};
                    closedTrades.forEach(trade => {
                        const segment = trade.segment || 'Equity'; // Default to Equity if no segment specified
                        const pnl = calculateNetPnl(trade);
                        if (!segmentData[segment]) {
                            segmentData[segment] = { totalPnl: 0, tradeCount: 0 };
                        }
                        segmentData[segment].totalPnl += pnl;
                        segmentData[segment].tradeCount += 1;
                    });
                    
                    let segmentLabels = Object.keys(segmentData);
                    let segmentPnlValues = segmentLabels.map(segment => segmentData[segment].totalPnl);
                    
                    // Use real data only - no sample data
                    
                    // Use different colors for each segment
                    const segmentColors = [
                        'rgba(34, 197, 94, 0.7)',   // Green for Equity
                        'rgba(59, 130, 246, 0.7)',  // Blue for Commodity
                        'rgba(168, 85, 247, 0.7)',  // Purple for Currency
                        'rgba(245, 158, 11, 0.7)',  // Amber for Derivatives
                        'rgba(239, 68, 68, 0.7)',   // Red for others
                        'rgba(16, 185, 129, 0.7)',  // Emerald for others
                        'rgba(236, 72, 153, 0.7)'   // Pink for others
                    ];
                    
                    const segmentBorderColors = [
                        'rgba(34, 197, 94, 1)',
                        'rgba(59, 130, 246, 1)',
                        'rgba(168, 85, 247, 1)',
                        'rgba(245, 158, 11, 1)',
                        'rgba(239, 68, 68, 1)',
                        'rgba(16, 185, 129, 1)',
                        'rgba(236, 72, 153, 1)'
                    ];
                    
                    const segmentChart = new Chart(segmentCtx, {
                        type: 'bar',
                        data: {
                            labels: segmentLabels,
                            datasets: [{
                                label: 'P&L by Segment',
                                data: segmentPnlValues,
                                backgroundColor: segmentLabels.map((_, index) => segmentColors[index % segmentColors.length]),
                                borderColor: segmentLabels.map((_, index) => segmentBorderColors[index % segmentBorderColors.length]),
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            return `P&L: ₹${value.toLocaleString()}`;
                                        },
                                        afterLabel: function(context) {
                                            const segment = context.label;
                                            const data = segmentData[segment];
                                            if (data && data.tradeCount > 0) {
                                                return `Trades: ${data.tradeCount}`;
                                            }
                                            return '';
                                        }
                                    }
                                }),
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                x: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['pnlBySegmentChart'] = segmentChart;
                }
                
                // P&L by Trading Style Chart
                const tradingStyleCtx = getCtx('pnlByTradingStyleChart');
                if (tradingStyleCtx) {
                    if (chartInstances['pnlByTradingStyleChart']) {
                        chartInstances['pnlByTradingStyleChart'].destroy();
                    }
                    
                    // Calculate P&L by trading style
                    const tradingStyleData = {};
                    closedTrades.forEach(trade => {
                        const tradingStyle = trade.trading_style || 'Intraday'; // Default to Intraday if no trading style specified
                        const pnl = calculateNetPnl(trade);
                        if (!tradingStyleData[tradingStyle]) {
                            tradingStyleData[tradingStyle] = { totalPnl: 0, tradeCount: 0 };
                        }
                        tradingStyleData[tradingStyle].totalPnl += pnl;
                        tradingStyleData[tradingStyle].tradeCount += 1;
                    });
                    
                    let tradingStyleLabels = Object.keys(tradingStyleData);
                    let tradingStylePnlValues = tradingStyleLabels.map(style => tradingStyleData[style].totalPnl);
                    
                    // Use real data only - no sample data
                    
                    // Use different colors for each trading style
                    const tradingStyleColors = [
                        'rgba(239, 68, 68, 0.7)',   // Red for Scalping
                        'rgba(34, 197, 94, 0.7)',   // Green for Intraday
                        'rgba(59, 130, 246, 0.7)',  // Blue for Swing
                        'rgba(168, 85, 247, 0.7)',  // Purple for Position
                        'rgba(245, 158, 11, 0.7)',  // Amber for Long-Term
                        'rgba(16, 185, 129, 0.7)',  // Emerald for others
                        'rgba(236, 72, 153, 0.7)'   // Pink for others
                    ];
                    
                    const tradingStyleBorderColors = [
                        'rgba(239, 68, 68, 1)',
                        'rgba(34, 197, 94, 1)',
                        'rgba(59, 130, 246, 1)',
                        'rgba(168, 85, 247, 1)',
                        'rgba(245, 158, 11, 1)',
                        'rgba(16, 185, 129, 1)',
                        'rgba(236, 72, 153, 1)'
                    ];
                    
                    const tradingStyleChart = new Chart(tradingStyleCtx, {
                        type: 'bar',
                        data: {
                            labels: tradingStyleLabels,
                            datasets: [{
                                label: 'P&L by Trading Style',
                                data: tradingStylePnlValues,
                                backgroundColor: tradingStyleLabels.map((_, index) => tradingStyleColors[index % tradingStyleColors.length]),
                                borderColor: tradingStyleLabels.map((_, index) => tradingStyleBorderColors[index % tradingStyleBorderColors.length]),
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            return `P&L: ₹${value.toLocaleString()}`;
                                        },
                                        afterLabel: function(context) {
                                            const style = context.label;
                                            const data = tradingStyleData[style];
                                            if (data && data.tradeCount > 0) {
                                                return `Trades: ${data.tradeCount}`;
                                            }
                                            return '';
                                        }
                                    }
                                }),
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                x: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['pnlByTradingStyleChart'] = tradingStyleChart;
                }
                
                // Win/Loss Distribution Chart (Donut Chart)
                const winLossCtx = getCtx('winLossDistributionChart');
                if (winLossCtx) {
                    if (chartInstances['winLossDistributionChart']) {
                        chartInstances['winLossDistributionChart'].destroy();
                    }
                    
                    const wins = closedTrades.filter(trade => calculateNetPnl(trade) > 0).length;
                    const losses = closedTrades.filter(trade => calculateNetPnl(trade) < 0).length;
                    
                    // Show message if no trades
                    const winLossMessage = document.getElementById('winLossMessage');
                    if (wins === 0 && losses === 0) {
                        if (winLossMessage) winLossMessage.classList.remove('hidden');
                        const winLossChart = new Chart(winLossCtx, {
                            type: 'doughnut',
                            data: {
                                labels: ['Winning Trades', 'Losing Trades'],
                                datasets: [{
                                    data: [1, 1], // Dummy data to show chart structure
                                    backgroundColor: ['rgba(16, 185, 129, 0.8)', 'rgba(239, 68, 68, 0.8)'],
                                    borderColor: ['rgba(16, 185, 129, 1)', 'rgba(239, 68, 68, 1)'],
                                    borderWidth: 2,
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                cutout: '60%',
                                plugins: {
                                    legend: { 
                                        display: true,
                                        position: 'bottom',
                                        labels: {
                                            color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                            font: { size: 12 },
                                            padding: 20,
                                            usePointStyle: true
                                        }
                                    },
                                    tooltip: {
                                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                        titleColor: '#ffffff',
                                        bodyColor: '#ffffff',
                                        borderColor: 'rgba(255, 255, 255, 0.1)',
                                        borderWidth: 1,
                                        padding: 12,
                                        titleFont: { size: 14, weight: 'bold' },
                                        bodyFont: { size: 13 },
                                        callbacks: {
                                            label: function(context) {
                                                const label = context.label || '';
                                                const value = context.parsed;
                                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                const percentage = ((value / total) * 100).toFixed(1);
                                                return `${label}: ${value} trades (${percentage}%)`;
                                            }
                                        }
                                    }
                                },
                                animation: {
                                    duration: 1000,
                                    easing: 'easeInOutQuart'
                                }
                            }
                        });
                        chartInstances['winLossDistributionChart'] = winLossChart;
                    } else {
                        if (winLossMessage) winLossMessage.classList.add('hidden');
                        const winLossChart = new Chart(winLossCtx, {
                            type: 'doughnut',
                            data: {
                                labels: ['Winning Trades', 'Losing Trades'],
                                datasets: [{
                                    data: [wins, losses],
                                    backgroundColor: ['rgba(16, 185, 129, 0.8)', 'rgba(239, 68, 68, 0.8)'],
                                    borderColor: ['rgba(16, 185, 129, 1)', 'rgba(239, 68, 68, 1)'],
                                    borderWidth: 2,
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                cutout: '60%',
                                plugins: {
                                    legend: { 
                                        display: true,
                                        position: 'bottom',
                                        labels: {
                                            color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                            font: { size: 12 },
                                            padding: 20,
                                            usePointStyle: true
                                        }
                                    },
                                    tooltip: {
                                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                        titleColor: '#ffffff',
                                        bodyColor: '#ffffff',
                                        borderColor: 'rgba(255, 255, 255, 0.1)',
                                        borderWidth: 1,
                                        padding: 12,
                                        titleFont: { size: 14, weight: 'bold' },
                                        bodyFont: { size: 13 },
                                        callbacks: {
                                            label: function(context) {
                                                const label = context.label || '';
                                                const value = context.parsed;
                                                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                const percentage = ((value / total) * 100).toFixed(1);
                                                return `${label}: ${value} trades (${percentage}%)`;
                                            }
                                        }
                                    }
                                },
                                animation: {
                                    duration: 1000,
                                    easing: 'easeInOutQuart'
                                }
                            }
                        });
                        chartInstances['winLossDistributionChart'] = winLossChart;
                    }
                }
                
                // Performance by Day of Week Chart (P&L per day)
                const performanceCtx = getCtx('performanceByDayChart');
                if (performanceCtx) {
                    if (chartInstances['performanceByDayChart']) {
                        chartInstances['performanceByDayChart'].destroy();
                    }
                    
                    // Calculate P&L by day of the week
                    const dayPnlData = {
                        'Sunday': 0,
                        'Monday': 0,
                        'Tuesday': 0,
                        'Wednesday': 0,
                        'Thursday': 0,
                        'Friday': 0,
                        'Saturday': 0
                    };
                    
                    // Calculate P&L by day of the week
                    closedTrades.forEach(trade => {
                        if (trade.entry_date) {
                            const date = new Date(trade.entry_date);
                            const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                            const pnl = calculateNetPnl(trade);
                            if (dayPnlData.hasOwnProperty(dayName)) {
                                dayPnlData[dayName] += pnl;
                            }
                        }
                    });
                    
                    const dayLabels = Object.keys(dayPnlData);
                    const dayPnlValues = Object.values(dayPnlData);
                    
                    // Use real data only - no sample data
                    
                    // Color bars based on profit/loss
                    const dayColors = Object.values(dayPnlData).map(pnl => 
                        pnl >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'
                    );
                    const dayBorderColors = Object.values(dayPnlData).map(pnl => 
                        pnl >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'
                    );
                    
                    const performanceChart = new Chart(performanceCtx, {
                        type: 'bar',
                        data: {
                            labels: dayLabels,
                            datasets: [{
                                label: 'P&L by Day',
                                data: Object.values(dayPnlData),
                                backgroundColor: dayColors,
                                borderColor: dayBorderColors,
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            indexAxis: 'y', // Horizontal bar chart
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 1.5,
                            plugins: {
                                legend: { display: false },
                                tooltip: {
                                    enabled: true,
                                    mode: 'point',
                                    intersect: true,
                                    position: 'nearest',
                                    backgroundColor: '#111827',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    borderColor: 'rgba(255, 255, 255, 0.06)',
                                    borderWidth: 1,
                                    cornerRadius: 6,
                                    displayColors: false,
                                    padding: 12,
                                    titleFont: {
                                        size: 13,
                                        weight: 'bold'
                                    },
                                    bodyFont: {
                                        size: 12
                                    },
                                    animation: {
                                        duration: 0
                                    },
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.x;
                                            return `P&L: ₹${value.toLocaleString()}`;
                                        }
                                    }
                                },
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                y: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['performanceByDayChart'] = performanceChart;
                }
                
                // Trade Distribution by Day of the Week Chart - Performance Optimized
                const tradeDistributionCtx = getCtx('tradeDistributionChart');
                if (tradeDistributionCtx) {
                    // Clean up existing chart efficiently
                    if (chartInstances['tradeDistributionChart']) {
                        chartInstances['tradeDistributionChart'].destroy();
                        chartInstances['tradeDistributionChart'] = null;
                    }
                    
                    try {
                        // Pre-define day order for performance
                        const dayOrder = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                        const dayData = [0, 0, 0, 0, 0, 0, 0]; // Array is faster than object
                        
                        // Optimized trade counting with minimal operations
                        const tradesLength = closedTrades.length;
                        for (let i = 0; i < tradesLength; i++) {
                            const trade = closedTrades[i];
                            if (trade?.exit_date) {
                                const exitDate = new Date(trade.exit_date);
                                if (!isNaN(exitDate.getTime())) {
                                    const dayIndex = exitDate.getDay(); // 0-6, faster than string conversion
                                    if (dayIndex >= 0 && dayIndex <= 6) {
                                        dayData[dayIndex]++;
                                    }
                                }
                            }
                        }
                        
                        // Create chart matching Performance by Day of Week style
                        const tradeDistributionChart = new Chart(tradeDistributionCtx, {
                            type: 'bar',
                            data: {
                                labels: dayOrder,
                                datasets: [{
                                    label: 'Number of Trades',
                                    data: dayData,
                                    backgroundColor: 'rgba(249, 115, 22, 0.7)', // Orange color like Performance chart
                                    borderColor: 'rgba(249, 115, 22, 1)',
                                    borderWidth: 1,
                                    borderRadius: 4,
                                    borderSkipped: false
                                }]
                            },
                            options: {
                                indexAxis: 'y', // Horizontal bar chart
                                responsive: true,
                                maintainAspectRatio: false,
                                aspectRatio: 1.5,
                                plugins: {
                                    legend: { display: false },
                                    tooltip: {
                                        enabled: true,
                                        mode: 'point',
                                        intersect: true,
                                        position: 'nearest',
                                        backgroundColor: '#111827',
                                        titleColor: '#ffffff',
                                        bodyColor: '#ffffff',
                                        borderColor: 'rgba(255, 255, 255, 0.06)',
                                        borderWidth: 1,
                                        cornerRadius: 6,
                                        displayColors: false,
                                        padding: 12,
                                        titleFont: {
                                            size: 13,
                                            weight: 'bold'
                                        },
                                        bodyFont: {
                                            size: 12
                                        },
                                        animation: {
                                            duration: 0
                                        },
                                        callbacks: {
                                            label: function(context) {
                                                const value = context.parsed.x;
                                                const count = Math.round(value);
                                                return `Trades: ${count}`;
                                            }
                                        }
                                    },
                                },
                                scales: {
                                    x: {
                                        beginAtZero: true,
                                        grid: { 
                                            color: 'rgba(128, 128, 128, 0.1)',
                                            drawBorder: false
                                        },
                                        ticks: {
                                            stepSize: 1,
                                            color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                            font: {
                                                size: 11
                                            }
                                        }
                                    },
                                    y: {
                                        grid: { 
                                            color: 'rgba(128, 128, 128, 0.1)',
                                            drawBorder: false
                                        },
                                        ticks: {
                                            color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                            font: {
                                                size: 11
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        
                        chartInstances['tradeDistributionChart'] = tradeDistributionChart;
                        
                    } catch (error) {
                        console.error('Error creating Trade Distribution chart:', error);
                    }
                }
                // Daily Win Rate Chart with comprehensive P&L analysis
                const dailyWinRateCtx = getCtx('dailyWinRateChart');
                const dailyWinRateMessage = document.getElementById('dailyWinRateMessage');
                if (dailyWinRateCtx && typeof Chart !== 'undefined') {
                    if (chartInstances['dailyWinRateChart']) {
                        // Clean up keyboard navigation before destroying chart
                        const oldChart = chartInstances['dailyWinRateChart'];
                        if (oldChart._keyboardNavHandler) {
                            document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                        }
                        if (oldChart._mouseEnterHandler) {
                            oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                        }
                        if (oldChart._mouseLeaveHandler) {
                            oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                        }
                        if (oldChart._doubleClickHandler) {
                            oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                        }
                        // Clear performance flag
                        if (oldChart.canvas) {
                            oldChart.canvas._hasKeyboardNav = false;
                        }
                        oldChart.destroy();
                    }
                    
                    // Show loading message
                    if (dailyWinRateMessage) {
                        dailyWinRateMessage.classList.remove('hidden');
                        dailyWinRateMessage.textContent = 'Loading chart...';
                    }
                    
                    // Set a timeout to hide loading message if chart creation takes too long
                    const loadingTimeout = setTimeout(() => {
                        if (dailyWinRateMessage && !dailyWinRateMessage.classList.contains('hidden')) {
                            console.warn('Daily Win Rate Chart: Loading timeout, showing error message');
                            dailyWinRateMessage.textContent = 'Chart loading timeout - please refresh the page';
                        }
                    }, 10000); // 10 second timeout
                    
                    console.log('Creating Daily Win Rate Chart with closedTrades:', closedTrades.length);
                    
                    // Function to calculate daily win rate statistics
                    function calculateDailyWinRateStats(trades, date) {
                        const dayTrades = trades.filter(trade => {
                            let tradeDate;
                            if (trade.exit_date) {
                                const exitDate = new Date(trade.exit_date);
                                if (isNaN(exitDate.getTime())) {
                                    console.warn('Invalid exit_date in reports:', trade.exit_date, 'for trade:', trade);
                                    return false;
                                }
                                tradeDate = exitDate.toISOString().split('T')[0];
                            } else if (trade.entry_date) {
                                const entryDate = new Date(trade.entry_date);
                                if (isNaN(entryDate.getTime())) {
                                    console.warn('Invalid entry_date in reports:', trade.entry_date, 'for trade:', trade);
                                    return false;
                                }
                                tradeDate = entryDate.toISOString().split('T')[0];
                            } else {
                                return false;
                            }
                            return tradeDate === date;
                        });
                        
                        let dailyWins = 0;
                        let dailyLosses = 0;
                        let dailyBreakeven = 0;
                        let totalTrades = dayTrades.length;
                        let totalWinAmount = 0;
                        let totalLossAmount = 0;
                        let netPnl = 0;
                        
                        dayTrades.forEach(trade => {
                            const pnl = calculateNetPnl(trade);
                            netPnl += pnl;
                            
                            if (pnl > 0) {
                                dailyWins++;
                                totalWinAmount += pnl;
                            } else if (pnl < 0) {
                                dailyLosses++;
                                totalLossAmount += pnl;
                            } else {
                                dailyBreakeven++;
                            }
                        });
                        
                        // Calculate win rate percentage (breakeven excluded)
                        const dailyRatePct = (dailyWins + dailyLosses) > 0 ? 
                            (dailyWins / (dailyWins + dailyLosses)) * 100 : 0;
                        
                        // Calculate average win/loss sizes
                        const avgWinSize = dailyWins > 0 ? totalWinAmount / dailyWins : 0;
                        const avgLossSize = dailyLosses > 0 ? totalLossAmount / dailyLosses : 0;
                        
                        return {
                            date,
                            dailyWins,
                            dailyLosses,
                            dailyBreakeven,
                            totalTrades,
                            dailyRatePct,
                            avgWinSize,
                            avgLossSize,
                            netPnl
                        };
                    }
                    
                    // Get all unique dates from trades - use filtered trades
                    const allDates = new Set();
                    const filteredClosedTrades = filterTradesByTimePeriod(closedTrades, dailyWinRateChartFilter);
                    filteredClosedTrades.forEach(trade => {
                        if (trade.entry_date) {
                            const date = new Date(trade.entry_date);
                            if (!isNaN(date.getTime())) {
                                const formattedDate = date.toISOString().split('T')[0];
                                allDates.add(formattedDate);
                            } else {
                                console.warn('Invalid entry_date in reports date collection:', trade.entry_date, 'for trade:', trade);
                            }
                        }
                        if (trade.exit_date) {
                            const date = new Date(trade.exit_date);
                            if (!isNaN(date.getTime())) {
                                const formattedDate = date.toISOString().split('T')[0];
                                allDates.add(formattedDate);
                            } else {
                                console.warn('Invalid exit_date in reports date collection:', trade.exit_date, 'for trade:', trade);
                            }
                        }
                    });
                    
                    const sortedDates = Array.from(allDates).sort();
                    
                    // Use real data only
                    let chartLabels, dailyWinRateData, avgWinRateData, tooltipData;
                    
                    if (sortedDates.length === 0) {
                        // No data available
                        chartLabels = [];
                        dailyWinRateData = [];
                        avgWinRateData = [];
                        tooltipData = [];
                        
                        
                    } else {
                        console.log('Processing actual trade data for Daily Win Rate Chart');
                        
                        // Process actual trade data
                        chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                        dailyWinRateData = [];
                        avgWinRateData = [];
                        tooltipData = [];
                        
                        let cumulativeWins = 0;
                        let cumulativeTrades = 0;
                        
                        sortedDates.forEach(date => {
                            const stats = calculateDailyWinRateStats(filteredClosedTrades, date);
                            dailyWinRateData.push(stats.dailyRatePct);
                            
                            // Calculate cumulative average win rate
                            cumulativeWins += stats.dailyWins;
                            cumulativeTrades += stats.totalTrades;
                            const avgWinRate = cumulativeTrades > 0 ? (cumulativeWins / cumulativeTrades) * 100 : 0;
                            avgWinRateData.push(avgWinRate);
                            
                            tooltipData.push(stats);
                        });
                    }
                    
                    console.log('Creating Daily Win Rate Chart with data:', {
                        labels: chartLabels,
                        dailyWinRateData: dailyWinRateData,
                        labelsLength: chartLabels.length,
                        dataLength: dailyWinRateData.length
                    });
                    
                    // Ensure we have data to display
                    if (chartLabels.length === 0 || dailyWinRateData.length === 0) {
                        console.log('Daily Win Rate Chart: No trades data available - chart will show empty state');
                        clearTimeout(loadingTimeout);
                        if (dailyWinRateMessage) {
                            dailyWinRateMessage.textContent = 'No trades data available. Add some trades to see your daily win rate analysis.';
                            dailyWinRateMessage.classList.remove('hidden');
                        }
                        return;
                    }
                    
                    // Validate data arrays
                    if (!Array.isArray(chartLabels) || !Array.isArray(dailyWinRateData)) {
                        console.error('Daily Win Rate Chart: Invalid data format', {
                            chartLabels: typeof chartLabels,
                            dailyWinRateData: typeof dailyWinRateData
                        });
                        clearTimeout(loadingTimeout);
                        if (dailyWinRateMessage) {
                            dailyWinRateMessage.textContent = 'Invalid data format';
                            dailyWinRateMessage.classList.remove('hidden');
                        }
                        return;
                    }
                    
                    // Ensure tooltipData is properly aligned with chart data
                    if (tooltipData.length !== chartLabels.length) {
                        console.warn('Daily Win Rate Chart: tooltipData length mismatch, adjusting...');
                        tooltipData = tooltipData.slice(0, chartLabels.length);
                    }
                    
                    try {
                        console.log('Creating Daily Win Rate Chart with config:', {
                            labels: chartLabels.length,
                            data: dailyWinRateData.length,
                            tooltipData: tooltipData.length,
                            ctx: !!dailyWinRateCtx
                        });
                        
                        
                        const dailyWinRateChart = new Chart(dailyWinRateCtx, {
                        type: 'line',
                        data: {
                            labels: chartLabels,
                            datasets: [
                                {
                                    label: 'Daily Win Rate',
                                    data: dailyWinRateData,
                                    borderColor: 'rgba(59, 130, 246, 1)',
                                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                    borderWidth: 2,
                                    fill: true, // Enable area fill for spline area chart
                                    tension: 0.6, // Enhanced spline curve for smoother appearance
                                    borderSkipped: false, // Ensures smooth area fill
                                    spanGaps: true, // Handles missing data points smoothly
                                    pointRadius: 2, // Smaller circles for cleaner appearance
                                    pointHoverRadius: 4 // Smaller hover circles
                                },
                                {
                                    label: 'Average Win Rate',
                                    data: avgWinRateData,
                                    borderColor: 'rgba(239, 68, 68, 1)',
                                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                    borderWidth: 2,
                                    fill: true, // Enable area fill for spline area chart
                                    tension: 0.6, // Enhanced spline curve for smoother appearance
                                    borderSkipped: false, // Ensures smooth area fill
                                    spanGaps: true, // Handles missing data points smoothly
                                    pointRadius: 2, // Smaller circles for cleaner appearance
                                    pointHoverRadius: 4, // Smaller hover circles
                                    borderDash: [5, 5]
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            elements: {
                                line: {
                                    tension: 0.6, // Enhanced spline curve for smoother rendering
                                    capBezierPoints: false // Smoother curve rendering
                                }
                            },
                            plugins: {
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 20,
                                        color: themeColors.chartText || '#212529',
                                        font: {
                                            size: 12
                                        }
                                    }
                                },
                                tooltip: {
                                    enabled: true,
                                    mode: 'index',
                                    intersect: false,
                                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    borderColor: 'rgba(255, 255, 255, 0.2)',
                                    borderWidth: 1,
                                    cornerRadius: 6,
                                    displayColors: true,
                                    callbacks: {
                                        title: function(context) {
                                            const index = context[0].dataIndex;
                                            const data = tooltipData[index];
                                            if (!data || !data.date) {
                                                return `Date: ${context[0].label}`;
                                            }
                                            return `Date: ${data.date}`;
                                        },
                                        label: function(context) {
                                            const datasetLabel = context.dataset.label;
                                            const value = context.parsed.y;
                                            
                                            if (datasetLabel === 'Daily Win Rate') {
                                                return `Daily Win Rate: ${value.toFixed(1)}%`;
                                            } else if (datasetLabel === 'Average Win Rate') {
                                                return `Average Win Rate: ${value.toFixed(1)}%`;
                                            }
                                            return `${datasetLabel}: ${value.toFixed(1)}%`;
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                },
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 110,
                                    ticks: {
                                        callback: function(value) {
                                            return value + '%';
                                        },
                                        color: themeColors.chartText || '#212529',
                                        font: {
                                            size: 11
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)'
                                    }
                                },
                                x: {
                                    ticks: {
                                        color: themeColors.chartText || '#212529',
                                        font: {
                                            size: 11
                                        },
                                        callback: function(value, index, ticks) {
                                            const label = this.getLabelForValue(value);
                                            if (label) {
                                                if (label.includes('-') && label.split('-').length === 3) {
                                                    return label;
                                                }
                                                const date = new Date(label);
                                                return date.toLocaleDateString('en-IN', { 
                                                    day: '2-digit', 
                                                    month: '2-digit', 
                                                    year: '2-digit' 
                                                });
                                            }
                                            return label;
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)'
                                    }
                                }
                            }
                        }
                        });
                        chartInstances['dailyWinRateChart'] = dailyWinRateChart;
                        console.log('Daily Win Rate Chart created successfully:', dailyWinRateChart);
                        
                        // Add keyboard navigation and zoom functionality for Daily Win Rate Chart
                        const addDailyWinRateKeyboardNav = () => {
                            // Skip if keyboard navigation already exists for this canvas
                            if (dailyWinRateChart.canvas && dailyWinRateChart.canvas._hasKeyboardNav) {
                                console.log('Daily Win Rate Chart: Keyboard navigation already exists, skipping');
                                return;
                            }

                            // Validate chart and canvas exist
                            if (!dailyWinRateChart || !dailyWinRateChart.canvas) {
                                console.warn('Daily Win Rate Chart: Canvas not available for keyboard navigation');
                                return;
                            }

                            // Validate zoom plugin is available
                            if (!dailyWinRateChart.options?.plugins?.zoom?.pan?.enabled) {
                                console.warn('Daily Win Rate Chart: Zoom plugin pan not enabled in chart options');
                                return;
                            }

                            let isChartFocused = false;

                            // Create event handlers with proper error handling
                            const handleMouseEnter = () => {
                                try {
                                    isChartFocused = true;
                                    if (dailyWinRateChart && dailyWinRateChart.canvas) {
                                        dailyWinRateChart.canvas.style.cursor = 'grab';
                                    }
                                } catch (error) {
                                    console.error('Daily Win Rate Chart: Mouse enter error', error);
                                }
                            };

                            const handleMouseLeave = () => {
                                try {
                                    isChartFocused = false;
                                    if (dailyWinRateChart && dailyWinRateChart.canvas) {
                                        dailyWinRateChart.canvas.style.cursor = 'default';
                                    }
                                } catch (error) {
                                    console.error('Daily Win Rate Chart: Mouse leave error', error);
                                }
                            };

                            const handleKeyDown = (e) => {
                                try {
                                    // Robust validation
                                    if (!isChartFocused || !dailyWinRateChart || !dailyWinRateChart.canvas) {
                                        return;
                                    }

                                    // Check for arrow keys (with fallback for older browsers)
                                    const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                    const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;

                                    if (isLeftArrow || isRightArrow) {
                                        e.preventDefault();
                                        e.stopPropagation();

                                        // Calculate pan amount with safety checks
                                        const chartWidth = dailyWinRateChart.width || 400; // fallback width
                                        const panAmount = chartWidth * 0.1;
                                        const direction = isLeftArrow ? -panAmount : panAmount;

                                        console.log('Daily Win Rate Chart: Attempting to pan', {
                                            direction: isLeftArrow ? 'left' : 'right',
                                            panAmount,
                                            chartWidth
                                        });

                                        // Perform pan with error handling - try multiple methods
                                        let panSuccess = false;

                                        // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                        try {
                                            if (typeof dailyWinRateChart.pan === 'function') {
                                                dailyWinRateChart.pan({x: direction});
                                                console.log('Daily Win Rate Chart: Direct pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (panError) {
                                            console.warn('Daily Win Rate Chart: Direct pan method failed', panError);
                                        }

                                        // Method 2: Zoom plugin instance method
                                        if (!panSuccess) {
                                            try {
                                                if (dailyWinRateChart.$zoom && typeof dailyWinRateChart.$zoom.pan === 'function') {
                                                    dailyWinRateChart.$zoom.pan({x: direction});
                                                    console.log('Daily Win Rate Chart: $zoom.pan method succeeded');
                                                    panSuccess = true;
                                                }
                                            } catch (zoomError) {
                                                console.warn('Daily Win Rate Chart: $zoom.pan method failed', zoomError);
                                            }
                                        }

                                        // Method 3: Manual scale adjustment (fallback)
                                        if (!panSuccess) {
                                            try {
                                                const xScale = dailyWinRateChart.scales.x;
                                                if (xScale) {
                                                    const range = xScale.max - xScale.min;
                                                    const panPercent = direction / chartWidth;
                                                    const panAmount = range * panPercent;

                                                    dailyWinRateChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                    dailyWinRateChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                    dailyWinRateChart.update('none'); // Update without animation
                                                    console.log('Daily Win Rate Chart: Manual scale adjustment succeeded');
                                                    panSuccess = true;
                                                }
                                            } catch (scaleError) {
                                                console.warn('Daily Win Rate Chart: Manual scale adjustment failed', scaleError);
                                            }
                                        }

                                        if (!panSuccess) {
                                            console.error('Daily Win Rate Chart: All pan methods failed');
                                        }
                                    }
                                } catch (error) {
                                    console.error('Daily Win Rate Chart: Keyboard navigation error', error);
                                }
                            };

                            // Add zoom reset on double-click
                            const handleDoubleClick = () => {
                                try {
                                    if (dailyWinRateChart && typeof dailyWinRateChart.resetZoom === 'function') {
                                        dailyWinRateChart.resetZoom();
                                        console.log('Daily Win Rate Chart: Zoom reset');
                                    }
                                } catch (error) {
                                    console.error('Daily Win Rate Chart: Zoom reset error', error);
                                }
                            };

                            // Add event listeners with error handling
                            try {
                                dailyWinRateChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                                dailyWinRateChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                                dailyWinRateChart.canvas.addEventListener('dblclick', handleDoubleClick);
                                document.addEventListener('keydown', handleKeyDown);

                                // Store references for proper cleanup
                                dailyWinRateChart._keyboardNavHandler = handleKeyDown;
                                dailyWinRateChart._mouseEnterHandler = handleMouseEnter;
                                dailyWinRateChart._mouseLeaveHandler = handleMouseLeave;
                                dailyWinRateChart._doubleClickHandler = handleDoubleClick;

                                // Mark canvas as having keyboard navigation to prevent duplicates
                                dailyWinRateChart.canvas._hasKeyboardNav = true;

                                // Debug: Log chart capabilities
                                console.log('Daily Win Rate Chart: Keyboard navigation initialized successfully');
                            } catch (error) {
                                console.error('Daily Win Rate Chart: Failed to initialize keyboard navigation', error);
                            }
                        };

                        // Initialize keyboard navigation with error handling
                        try {
                            addDailyWinRateKeyboardNav();
                        } catch (error) {
                            console.error('Daily Win Rate Chart: Failed to add keyboard navigation', error);
                        }
                        
                        // Clear the loading timeout
                        clearTimeout(loadingTimeout);
                        
                        // Hide loading message on success
                        if (dailyWinRateMessage) {
                            dailyWinRateMessage.classList.add('hidden');
                        }
                    } catch (error) {
                        console.error('Error creating Daily Win Rate Chart:', error);
                        console.error('Error details:', {
                            message: error.message,
                            stack: error.stack,
                            chartLabels: chartLabels,
                            dailyWinRateData: dailyWinRateData,
                            tooltipData: tooltipData,
                            themeColors: themeColors
                        });
                        
                        // Clear the loading timeout
                        clearTimeout(loadingTimeout);
                        
                        // Show error message
                        if (dailyWinRateMessage) {
                            dailyWinRateMessage.textContent = `Error loading chart: ${error.message}`;
                            dailyWinRateMessage.classList.remove('hidden');
                        }
                    }
                } else {
                    if (!dailyWinRateCtx) {
                        console.log('Daily Win Rate Chart canvas not found - canvas element missing');
                    } else if (typeof Chart === 'undefined') {
                        console.error('Chart.js not loaded - cannot create Daily Win Rate Chart');
                        if (dailyWinRateMessage) {
                            dailyWinRateMessage.textContent = 'Chart library not loaded';
                            dailyWinRateMessage.classList.remove('hidden');
                        }
                    }
                }
                
                // Strategy vs P&L Chart
                const strategyCtx = getCtx('strategyPnlChart');
                if (strategyCtx) {
                    if (chartInstances['strategyPnlChart']) {
                        chartInstances['strategyPnlChart'].destroy();
                    }
                    
                    // Calculate P&L by strategy
                    const strategyData = {};
                    closedTrades.forEach(trade => {
                        const strategy = trade.strategy || 'No Strategy';
                        const pnl = calculateNetPnl(trade);
                        if (!strategyData[strategy]) {
                            strategyData[strategy] = { totalPnl: 0, tradeCount: 0 };
                        }
                        strategyData[strategy].totalPnl += pnl;
                        strategyData[strategy].tradeCount += 1;
                    });
                    
                    let strategyLabels = Object.keys(strategyData);
                    let strategyPnlValues = strategyLabels.map(strategy => strategyData[strategy].totalPnl);
                    
                    // Use real data only - no sample data
                    
                    // Use consistent purple color for all bars as shown in the image
                    const strategyColors = strategyLabels.map(() => 'rgba(147, 51, 234, 0.7)'); // purple-600 with opacity
                    const strategyBorderColors = strategyLabels.map(() => 'rgba(147, 51, 234, 1)'); // purple-600 solid
                    
                    const strategyChart = new Chart(strategyCtx, {
                        type: 'bar',
                        data: {
                            labels: strategyLabels,
                            datasets: [{
                                label: 'P&L by Strategy',
                                data: strategyPnlValues,
                                backgroundColor: strategyColors,
                                borderColor: strategyBorderColors,
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { display: false },
                                tooltip: getContinuousTooltipConfig(themeColors, {
                                    borderColor: 'rgba(147, 51, 234, 1)',
                                    callbacks: {
                                        label: function(context) {
                                            const value = context.parsed.y;
                                            return `P&L: ₹${value.toLocaleString()}`;
                                        },
                                        afterLabel: function(context) {
                                            const strategy = context.label;
                                            const data = strategyData[strategy];
                                            if (data && data.tradeCount > 0) {
                                                return `Trades: ${data.tradeCount}`;
                                            }
                                            return '';
                                        }
                                    }
                                }),
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                x: {
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        maxRotation: 0,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['strategyPnlChart'] = strategyChart;
                }
                
                // Monthly Commission/Charges Chart
                const monthlyChargesCtx = getCtx('monthlyChargesChart');
                if (monthlyChargesCtx) {
                    if (chartInstances['monthlyChargesChart']) {
                        // Clean up keyboard navigation before destroying chart
                        const oldChart = chartInstances['monthlyChargesChart'];
                        if (oldChart._keyboardNavHandler) {
                            document.removeEventListener('keydown', oldChart._keyboardNavHandler);
                        }
                        if (oldChart._mouseEnterHandler) {
                            oldChart.canvas.removeEventListener('mouseenter', oldChart._mouseEnterHandler);
                        }
                        if (oldChart._mouseLeaveHandler) {
                            oldChart.canvas.removeEventListener('mouseleave', oldChart._mouseLeaveHandler);
                        }
                        if (oldChart._doubleClickHandler) {
                            oldChart.canvas.removeEventListener('dblclick', oldChart._doubleClickHandler);
                        }
                        // Clear performance flag
                        if (oldChart.canvas) {
                            oldChart.canvas._hasKeyboardNav = false;
                        }
                        oldChart.destroy();
                    }
                    
                    // Calculate monthly charges from trades - use filtered trades
                    const monthlyChargesData = {};
                    const filteredClosedTrades = filterTradesByTimePeriod(closedTrades, monthlyCommissionChartFilter);
                    filteredClosedTrades.forEach(trade => {
                        if (trade.exit_date) {
                            const date = new Date(trade.exit_date);
                            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                            
                            const brokerage = trade.brokerage || 0;
                            const otherFees = trade.other_fees || 0;
                            const totalCharges = brokerage + otherFees;
                            
                            if (!monthlyChargesData[monthKey]) {
                                monthlyChargesData[monthKey] = { 
                                    totalCharges: 0, 
                                    brokerage: 0, 
                                    otherFees: 0, 
                                    tradeCount: 0 
                                };
                            }
                            
                            monthlyChargesData[monthKey].totalCharges += totalCharges;
                            monthlyChargesData[monthKey].brokerage += brokerage;
                            monthlyChargesData[monthKey].otherFees += otherFees;
                            monthlyChargesData[monthKey].tradeCount += 1;
                        }
                    });
                    
                    const sortedMonths = Object.keys(monthlyChargesData).sort();
                    const labels = sortedMonths.length > 0 ? sortedMonths.map(month => {
                        // Convert "2024-01" to "JAN 2024"
                        const [year, monthNum] = month.split('-');
                        const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 
                                          'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
                        const monthName = monthNames[parseInt(monthNum) - 1];
                        return `${monthName} ${year}`;
                    }) : [];
                    
                    const totalChargesData = sortedMonths.length > 0 ? sortedMonths.map(month => monthlyChargesData[month].totalCharges) : [];
                    const brokerageData = sortedMonths.length > 0 ? sortedMonths.map(month => monthlyChargesData[month].brokerage) : [];
                    const otherFeesData = sortedMonths.length > 0 ? sortedMonths.map(month => monthlyChargesData[month].otherFees) : [];
                    
                    // Use real data only - no sample data
                    
                    const monthlyChargesChart = new Chart(monthlyChargesCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [
                                {
                                    label: 'Brokerage',
                                    data: brokerageData,
                                    backgroundColor: 'rgba(239, 68, 68, 0.7)', // Red for brokerage
                                    borderColor: 'rgba(239, 68, 68, 1)',
                                    borderWidth: 1,
                                    borderRadius: 4,
                                    borderSkipped: false
                                },
                                {
                                    label: 'Charges',
                                    data: otherFeesData,
                                    backgroundColor: 'rgba(245, 158, 11, 0.7)', // Amber for charges                                                                                                         
                                    borderColor: 'rgba(245, 158, 11, 1)',
                                    borderWidth: 1,
                                    borderRadius: 4,
                                    borderSkipped: false
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            aspectRatio: 2,
                            plugins: {
                                legend: { 
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 12
                                        }
                                    }
                                },
                                tooltip: {
                                    enabled: true,
                                    mode: 'index',
                                    intersect: false,
                                    backgroundColor: '#111827',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    borderColor: 'rgba(255, 255, 255, 0.06)',
                                    borderWidth: 1,
                                    cornerRadius: 6,
                                    displayColors: false,
                                    padding: 12,
                                    titleFont: {
                                        size: 13,
                                        weight: 'bold'
                                    },
                                    bodyFont: {
                                        size: 12
                                    },
                                    animation: {
                                        duration: 0
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            const monthKey = sortedMonths[context[0].dataIndex];
                                            return monthKey;
                                        },
                                        label: function(context) {
                                            // Only show custom content for the first dataset to avoid duplication
                                            if (context.datasetIndex === 0) {
                                                const monthKey = sortedMonths[context.dataIndex];
                                                const data = monthlyChargesData[monthKey];
                                                if (data && data.tradeCount > 0) {
                                                    return [
                                                        `Brokerage: ₹${data.brokerage.toLocaleString()}`,
                                                        `Charges: ₹${data.otherFees.toLocaleString()}`,
                                                        `Trades: ${data.tradeCount}`,
                                                        `Total Charges: ₹${data.totalCharges.toLocaleString()}`
                                                    ];
                                                }
                                            }
                                            return ''; // Hide default dataset labels
                                        }
                                    }
                                },
                                zoom: {
                                    pan: {
                                        enabled: true,
                                        mode: 'x',
                                        threshold: 10,
                                        onPan: function({chart}) {
                                            // Optional: Add any custom behavior during pan
                                        },
                                        onPanComplete: function({chart}) {
                                            // Optional: Add any custom behavior after pan
                                        }
                                    },
                                    zoom: {
                                        mode: 'x',
                                        wheel: {
                                            enabled: true,
                                            speed: 0.00001,
                                            modifierKey: null // Allow zoom without modifier key
                                        },
                                        limits: {
                                            x: {min: 'original', max: 'original'},
                                            y: {min: 'original', max: 'original'}
                                        },
                                        pinch: {
                                            enabled: true
                                        },
                                        drag: {
                                            enabled: false // Disable drag zoom to avoid conflicts with pan
                                        },
                                        onZoom: function({chart}) {
                                            // Optional: Add any custom behavior during zoom
                                        },
                                        onZoomComplete: function({chart}) {
                                            // Optional: Add any custom behavior after zoom
                                        }
                                    }
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    stacked: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return '₹' + value.toLocaleString();
                                        },
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                },
                                x: {
                                    stacked: true,
                                    grid: { 
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    ticks: {
                                        maxRotation: 45,
                                        minRotation: 0,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            }
                        }
                    });
                    chartInstances['monthlyChargesChart'] = monthlyChargesChart;
                    
                    // Add keyboard navigation and zoom functionality for Monthly Charges Chart
                    const addMonthlyChargesKeyboardNav = () => {
                        // Skip if keyboard navigation already exists for this canvas
                        if (monthlyChargesChart.canvas && monthlyChargesChart.canvas._hasKeyboardNav) {
                            console.log('Monthly Charges Chart: Keyboard navigation already exists, skipping');
                            return;
                        }

                        // Validate chart and canvas exist
                        if (!monthlyChargesChart || !monthlyChargesChart.canvas) {
                            console.warn('Monthly Charges Chart: Canvas not available for keyboard navigation');
                            return;
                        }

                        // Validate zoom plugin is available
                        if (!monthlyChargesChart.options?.plugins?.zoom?.pan?.enabled) {
                            console.warn('Monthly Charges Chart: Zoom plugin pan not enabled in chart options');
                            return;
                        }

                        let isChartFocused = false;

                        // Create event handlers with proper error handling
                        const handleMouseEnter = () => {
                            try {
                                isChartFocused = true;
                                if (monthlyChargesChart && monthlyChargesChart.canvas) {
                                    monthlyChargesChart.canvas.style.cursor = 'grab';
                                }
                            } catch (error) {
                                console.error('Monthly Charges Chart: Mouse enter error', error);
                            }
                        };

                        const handleMouseLeave = () => {
                            try {
                                isChartFocused = false;
                                if (monthlyChargesChart && monthlyChargesChart.canvas) {
                                    monthlyChargesChart.canvas.style.cursor = 'default';
                                }
                            } catch (error) {
                                console.error('Monthly Charges Chart: Mouse leave error', error);
                            }
                        };

                        const handleKeyDown = (e) => {
                            try {
                                // Robust validation
                                if (!isChartFocused || !monthlyChargesChart || !monthlyChargesChart.canvas) {
                                    return;
                                }

                                // Check for arrow keys (with fallback for older browsers)
                                const isLeftArrow = e.key === 'ArrowLeft' || e.keyCode === 37;
                                const isRightArrow = e.key === 'ArrowRight' || e.keyCode === 39;

                                if (isLeftArrow || isRightArrow) {
                                    e.preventDefault();
                                    e.stopPropagation();

                                    // Calculate pan amount with safety checks
                                    const chartWidth = monthlyChargesChart.width || 400; // fallback width
                                    const panAmount = chartWidth * 0.1;
                                    const direction = isLeftArrow ? -panAmount : panAmount;

                                    console.log('Monthly Charges Chart: Attempting to pan', {
                                        direction: isLeftArrow ? 'left' : 'right',
                                        panAmount,
                                        chartWidth
                                    });

                                    // Perform pan with error handling - try multiple methods
                                    let panSuccess = false;

                                    // Method 1: Direct pan method (Chart.js 4.x with zoom plugin)
                                    try {
                                        if (typeof monthlyChargesChart.pan === 'function') {
                                            monthlyChargesChart.pan({x: direction});
                                            console.log('Monthly Charges Chart: Direct pan method succeeded');
                                            panSuccess = true;
                                        }
                                    } catch (panError) {
                                        console.warn('Monthly Charges Chart: Direct pan method failed', panError);
                                    }

                                    // Method 2: Zoom plugin instance method
                                    if (!panSuccess) {
                                        try {
                                            if (monthlyChargesChart.$zoom && typeof monthlyChargesChart.$zoom.pan === 'function') {
                                                monthlyChargesChart.$zoom.pan({x: direction});
                                                console.log('Monthly Charges Chart: $zoom.pan method succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (zoomError) {
                                            console.warn('Monthly Charges Chart: $zoom.pan method failed', zoomError);
                                        }
                                    }

                                    // Method 3: Manual scale adjustment (fallback)
                                    if (!panSuccess) {
                                        try {
                                            const xScale = monthlyChargesChart.scales.x;
                                            if (xScale) {
                                                const range = xScale.max - xScale.min;
                                                const panPercent = direction / chartWidth;
                                                const panAmount = range * panPercent;

                                                monthlyChargesChart.options.scales.x.min = (xScale.min || 0) + panAmount;
                                                monthlyChargesChart.options.scales.x.max = (xScale.max || range) + panAmount;
                                                monthlyChargesChart.update('none'); // Update without animation
                                                console.log('Monthly Charges Chart: Manual scale adjustment succeeded');
                                                panSuccess = true;
                                            }
                                        } catch (scaleError) {
                                            console.warn('Monthly Charges Chart: Manual scale adjustment failed', scaleError);
                                        }
                                    }

                                    if (!panSuccess) {
                                        console.error('Monthly Charges Chart: All pan methods failed');
                                    }
                                }
                            } catch (error) {
                                console.error('Monthly Charges Chart: Keyboard navigation error', error);
                            }
                        };

                        // Add zoom reset on double-click
                        const handleDoubleClick = () => {
                            try {
                                if (monthlyChargesChart && typeof monthlyChargesChart.resetZoom === 'function') {
                                    monthlyChargesChart.resetZoom();
                                    console.log('Monthly Charges Chart: Zoom reset');
                                }
                            } catch (error) {
                                console.error('Monthly Charges Chart: Zoom reset error', error);
                            }
                        };

                        // Add event listeners with error handling
                        try {
                            monthlyChargesChart.canvas.addEventListener('mouseenter', handleMouseEnter);
                            monthlyChargesChart.canvas.addEventListener('mouseleave', handleMouseLeave);
                            monthlyChargesChart.canvas.addEventListener('dblclick', handleDoubleClick);
                            document.addEventListener('keydown', handleKeyDown);

                            // Store references for proper cleanup
                            monthlyChargesChart._keyboardNavHandler = handleKeyDown;
                            monthlyChargesChart._mouseEnterHandler = handleMouseEnter;
                            monthlyChargesChart._mouseLeaveHandler = handleMouseLeave;
                            monthlyChargesChart._doubleClickHandler = handleDoubleClick;

                            // Mark canvas as having keyboard navigation to prevent duplicates
                            monthlyChargesChart.canvas._hasKeyboardNav = true;

                            // Debug: Log chart capabilities
                            console.log('Monthly Charges Chart: Keyboard navigation initialized successfully');
                        } catch (error) {
                            console.error('Monthly Charges Chart: Failed to initialize keyboard navigation', error);
                        }
                    };

                    // Initialize keyboard navigation with error handling
                    try {
                        addMonthlyChargesKeyboardNav();
                    } catch (error) {
                        console.error('Monthly Charges Chart: Failed to add keyboard navigation', error);
                    }
                }
                
                // Net P&L by Mood Chart
                const netPnlByMoodCtx = getCtx('netPnlByMoodChart');
                const netPnlByMoodMessage = document.getElementById('netPnlByMoodMessage');
                if (netPnlByMoodCtx) {
                    if (chartInstances['netPnlByMoodChart']) {
                        chartInstances['netPnlByMoodChart'].destroy();
                    }
                    
                    // Show loading message
                    if (netPnlByMoodMessage) {
                        netPnlByMoodMessage.classList.remove('hidden');
                    }
                    
                    // Get trades to analyze (use filtered trades if available, otherwise all trades)
                    const tradesToAnalyze = appState.trades || [];
                    
                    // Calculate Net P&L by mood
                    const moodPnl = {};
                    const moodTradeCounts = {};
                    
                    // Define all possible moods
                    const allMoods = ['Calm', 'Confident', 'Neutral', 'Anxious', 'Panicked', 'Excited', 'Frustrated', 'Greedy', 'Fearful'];
                    
                    // Initialize all moods with zero values
                    allMoods.forEach(mood => {
                        moodPnl[mood] = 0;
                        moodTradeCounts[mood] = 0;
                    });
                    
                    // Calculate P&L for each mood
                    tradesToAnalyze.forEach(trade => {
                        if (trade.emotionalState && trade.exit_date && trade.exit_price) {
                            const pnl = calculateNetPnl(trade);
                            moodPnl[trade.emotionalState] = (moodPnl[trade.emotionalState] || 0) + pnl;
                            moodTradeCounts[trade.emotionalState] = (moodTradeCounts[trade.emotionalState] || 0) + 1;
                        }
                    });
                    
                    // Filter out moods with no trades and sort by P&L
                    const moodData = Object.entries(moodPnl)
                        .filter(([mood, pnl]) => moodTradeCounts[mood] > 0)
                        .sort(([,a], [,b]) => b - a); // Sort by P&L descending
                    
                    if (moodData.length === 0) {
                        // Show message if no mood data
                        if (netPnlByMoodMessage) {
                            if (appState.trades.length === 0) {
                                netPnlByMoodMessage.textContent = 'No trades found. Add some trades first.';
                            } else {
                                netPnlByMoodMessage.textContent = 'No emotional state data found. Select emotional state while adding trades to see analysis.';
                            }
                            netPnlByMoodMessage.classList.remove('hidden');
                        }
                        return;
                    }
                    
                    const labels = moodData.map(([mood]) => mood);
                    const data = moodData.map(([, pnl]) => pnl);
                    const tradeCounts = moodData.map(([mood]) => moodTradeCounts[mood]);
                    
                    // Hide loading message
                    if (netPnlByMoodMessage) {
                        netPnlByMoodMessage.classList.add('hidden');
                    }
                    
                    const netPnlByMoodChart = new Chart(netPnlByMoodCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Net P&L',
                                data: data,
                                backgroundColor: data.map(pnl => pnl >= 0 ? 'rgba(16, 185, 129, 0.8)' : 'rgba(239, 68, 68, 0.8)'),
                                borderColor: data.map(pnl => pnl >= 0 ? 'rgba(16, 185, 129, 1)' : 'rgba(239, 68, 68, 1)'),
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false,
                            }]
                        },
                        options: {
                            indexAxis: 'y', // Horizontal bar chart
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    backgroundColor: '#111827',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    borderColor: 'rgba(255, 255, 255, 0.06)',
                                    borderWidth: 1,
                                    cornerRadius: 6,
                                    padding: 12,
                                    titleFont: {
                                        size: 13,
                                        weight: 'bold'
                                    },
                                    bodyFont: {
                                        size: 12
                                    },
                                    animation: {
                                        duration: 0
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            return context[0].label;
                                        },
                                        label: function(context) {
                                            const pnl = context.parsed.x;
                                            const mood = context.label;
                                            const tradeCount = moodTradeCounts[mood];
                                            return `Net P&L: ${window.utils.formatCurrency(pnl)}`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 12
                                        },
                                        callback: function(value) {
                                            return window.utils.formatCurrency(value);
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    title: {
                                        display: false
                                    }
                                },
                                y: {
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 12
                                        }
                                    },
                                    grid: {
                                        display: false
                                    },
                                    title: {
                                        display: false
                                    }
                                }
                            },
                            animation: {
                                duration: 1000,
                                easing: 'easeInOutQuart'
                            }
                        }
                    });
                    
                    chartInstances['netPnlByMoodChart'] = netPnlByMoodChart;
                }
                
                // Most Common Mistakes Chart
                const mostCommonMistakesCtx = getCtx('mostCommonMistakesChart');
                const mostCommonMistakesMessage = document.getElementById('mostCommonMistakesMessage');
                if (mostCommonMistakesCtx) {
                    if (chartInstances['mostCommonMistakesChart']) {
                        chartInstances['mostCommonMistakesChart'].destroy();
                    }
                    
                    // Show loading message
                    if (mostCommonMistakesMessage) {
                        mostCommonMistakesMessage.classList.remove('hidden');
                    }
                    
                    // Calculate mistakes from trades in the last month
                    const oneMonthAgo = new Date();
                    oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                    
                    console.log('All trades in appState:', appState.trades.length);
                    console.log('One month ago date:', oneMonthAgo);
                    
                    // Include ALL trades (both open and closed) from the last month
                    const recentTrades = appState.trades.filter(trade => {
                        if (!trade.entry_date) {
                            console.log('Trade without entry_date:', trade);
                            return false;
                        }
                        const tradeDate = new Date(trade.entry_date);
                        const isRecent = tradeDate >= oneMonthAgo;
                        console.log('Trade date:', trade.entry_date, 'isRecent:', isRecent);
                        return isRecent;
                    });
                    
                    // Count mistakes
                    const mistakeCounts = {};
                    console.log('Recent trades for mistakes analysis:', recentTrades.length);
                    
                    // If no recent trades, use all trades for debugging
                    let tradesToAnalyze = recentTrades.length > 0 ? recentTrades : appState.trades;
                    console.log('Trades to analyze:', tradesToAnalyze.length);
                    
                    // Use real data only - no demo data
                    
                    tradesToAnalyze.forEach(trade => {
                        console.log('Trade mistakes:', trade.mistakes, 'Trade ID:', trade.id);
                        if (trade.mistakes && Array.isArray(trade.mistakes)) {
                            trade.mistakes.forEach(mistake => {
                                if (mistake !== 'No Mistakes') { // Exclude "No Mistakes" from the chart
                                    mistakeCounts[mistake] = (mistakeCounts[mistake] || 0) + 1;
                                }
                            });
                        }
                    });
                    
                    console.log('Mistake counts:', mistakeCounts);
                    
                    // Sort mistakes by count (descending) and take top 5
                    const sortedMistakes = Object.entries(mistakeCounts)
                        .sort(([,a], [,b]) => b - a)
                        .slice(0, 5);
                    
                    if (sortedMistakes.length === 0) {
                        // Show message if no mistakes data
                        if (mostCommonMistakesMessage) {
                            if (appState.trades.length === 0) {
                                mostCommonMistakesMessage.textContent = 'No trades found. Add some trades first.';
                            } else if (recentTrades.length === 0) {
                                mostCommonMistakesMessage.textContent = `No trades found in the last month. Found ${appState.trades.length} total trades.`;
                            } else {
                                mostCommonMistakesMessage.textContent = 'No mistakes recorded in recent trades. Select mistakes while adding trades to see analysis.';
                            }
                            mostCommonMistakesMessage.classList.remove('hidden');
                        }
                        
                        return;
                    }
                    
                    const labels = sortedMistakes.map(([mistake]) => mistake);
                    const data = sortedMistakes.map(([, count]) => count);
                    
                    // Hide loading message
                    if (mostCommonMistakesMessage) {
                        mostCommonMistakesMessage.classList.add('hidden');
                    }
                    
                    const mostCommonMistakesChart = new Chart(mostCommonMistakesCtx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Number of Trades',
                                data: data,
                                backgroundColor: 'rgba(239, 68, 68, 0.8)', // Red color matching the image
                                borderColor: 'rgba(239, 68, 68, 1)',
                                borderWidth: 1,
                                borderRadius: 4,
                                borderSkipped: false,
                            }]
                        },
                        options: {
                            indexAxis: 'y', // Horizontal bar chart
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    backgroundColor: '#111827',
                                    titleColor: '#ffffff',
                                    bodyColor: '#ffffff',
                                    borderColor: 'rgba(255, 255, 255, 0.06)',
                                    borderWidth: 1,
                                    cornerRadius: 6,
                                    padding: 12,
                                    titleFont: {
                                        size: 13,
                                        weight: 'bold'
                                    },
                                    bodyFont: {
                                        size: 12
                                    },
                                    animation: {
                                        duration: 0
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            return context[0].label;
                                        },
                                        label: function(context) {
                                            return `${context.parsed.x} trades`;
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    ticks: {
                                        stepSize: 1,
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 12
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(128, 128, 128, 0.1)',
                                        drawBorder: false
                                    },
                                    title: {
                                        display: false
                                    }
                                },
                                y: {
                                    ticks: {
                                        color: (themeColors || getThemeColors()).chartText || (themeColors || getThemeColors()).textColor,
                                        font: {
                                            size: 12
                                        }
                                    },
                                    grid: {
                                        display: false
                                    },
                                    title: {
                                        display: false
                                    }
                                }
                            },
                            animation: {
                                duration: 1000,
                                easing: 'easeInOutQuart'
                            }
                        }
                    });
                    
                    chartInstances['mostCommonMistakesChart'] = mostCommonMistakesChart;
                }
                
                // Challenge Progress Chart is handled by updateChallengeProgress function
                // No need to create it here as it's already created in the challenge section
            } catch (e) {
                console.error('renderAllCharts error', e);
            }
            }, forceRender ? 0 : 50); // 50ms debounce, or immediate if forced
        };

        // --- ACCOUNT BALANCE CHART FILTER LOGIC ---
        let balanceChartFilter = 'month'; // Default to current month
        
        // Function to get period date range
        const getPeriodDateRange = (period) => {
            const now = new Date();
            switch (period) {
                case 'week':
                    const weekStart = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));
                    return { start: weekStart, end: now };
                case 'month':
                    const monthStart = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
                    return { start: monthStart, end: now };
                case 'all':
                default:
                    return { start: null, end: null }; // All time
            }
        };

        // Function to filter trades by time period
        const filterTradesByTimePeriod = (trades, period) => {
            if (!trades || trades.length === 0) return [];
            
            const dateRange = getPeriodDateRange(period);
            if (!dateRange.start) return trades; // All time
            
            return trades.filter(trade => {
                const tradeDate = new Date(trade.entry_date || trade.exit_date);
                return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
            });
        };

        // Chart state reset functions to prevent hover interference
        const resetChartState = (chart) => {
            if (!chart) return;
            try {
                // Reset zoom if available
                if (chart.resetZoom && typeof chart.resetZoom === 'function') {
                    chart.resetZoom();
                }
                // Reset any hover states
                if (chart.update && typeof chart.update === 'function') {
                    chart.update('none');
                }
            } catch (e) {
                console.warn('Chart state reset warning:', e);
            }
        };

        const clearChartHoverStates = () => {
            // Remove any active hover classes from chart containers
            document.querySelectorAll('.chart-container, canvas').forEach(container => {
                container.classList.remove('chart-hover', 'hover');
            });
        };

        // Function to update balance chart with filtered data
        const updateBalanceChart = (period) => {
            try {
                const chart = chartInstances['accountBalanceChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                const ledger = appState.ledger || [];
                
                // For All Time: use all data
                // For Week/Month: filter data within period
                let filteredTrades = allTrades;
                let filteredLedger = ledger;
                
                if (dateRange.start && dateRange.end) {
                    // Filter trades within period
                    filteredTrades = allTrades.filter(trade => {
                        const tradeDate = new Date(trade.entry_date || trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                    
                    // Filter ledger within period
                    filteredLedger = ledger.filter(entry => {
                        const entryDate = new Date(entry.date);
                        return entryDate >= dateRange.start && entryDate <= dateRange.end;
                    });
                }
                
                // Get all unique dates from trades and ledger
                const allDates = new Set();
                
                if (period === 'all') {
                    // All Time: Use ALL data for complete historical view
                    allTrades.forEach(trade => {
                        if (trade.entry_date) allDates.add(trade.entry_date);
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                    
                    ledger.forEach(entry => {
                        if (entry.date) allDates.add(entry.date);
                    });
                } else {
                    // Week/Month: Use filtered data for period-specific view
                    filteredTrades.forEach(trade => {
                        if (trade.entry_date) allDates.add(trade.entry_date);
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                    
                    filteredLedger.forEach(entry => {
                        if (entry.date) allDates.add(entry.date);
                    });
                }
                
                const deduplicatedDates = Array.from(allDates);
                const sortedDates = deduplicatedDates.sort();
                
                if (sortedDates.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    return;
                }
                
                // Calculate balance progression
                const chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                const accountValueData = [];
                
                if (period === 'all') {
                    // All Time: Show cumulative balance from beginning
                    sortedDates.forEach(date => {
                        const dateTime = new Date(date).getTime();
                        
                        // Calculate P&L up to this date (from all trades)
                        let pnlToDate = 0;
                        allTrades.forEach(trade => {
                            const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                            if (exitDate && exitDate <= dateTime) {
                                pnlToDate += calculateNetPnl(trade);
                            }
                        });
                        
                        // Calculate deposits up to this date (from all ledger)
                        let depositsToDate = 0;
                        ledger.forEach(entry => {
                            const entryDate = new Date(entry.date).getTime();
                            if (entryDate <= dateTime && entry.type === 'Deposit') {
                                depositsToDate += parseFloat(entry.amount) || 0;
                            }
                        });
                        
                        // Calculate withdrawals up to this date (from all ledger)
                        let withdrawalsToDate = 0;
                        ledger.forEach(entry => {
                            const entryDate = new Date(entry.date).getTime();
                            if (entryDate <= dateTime && entry.type === 'Withdrawal') {
                                withdrawalsToDate += parseFloat(entry.amount) || 0;
                            }
                        });
                        
                        // Account value = starting balance + deposits - withdrawals + P&L
                        const startingBalance = parseFloat(appState.startingBalance) || 0;
                        const accountValue = startingBalance + depositsToDate - withdrawalsToDate + pnlToDate;
                        accountValueData.push(accountValue);
                    });
                } else {
                    // Week/Month: Show balance progression within period
                    // Get starting balance at beginning of period
                    const periodStartTime = dateRange.start.getTime();
                    let startingBalanceForPeriod = parseFloat(appState.startingBalance) || 0;
                    
                    // Add deposits before period
                    ledger.forEach(entry => {
                        const entryDate = new Date(entry.date).getTime();
                        if (entryDate < periodStartTime && entry.type === 'Deposit') {
                            startingBalanceForPeriod += parseFloat(entry.amount) || 0;
                        }
                    });
                    
                    // Subtract withdrawals before period
                    ledger.forEach(entry => {
                        const entryDate = new Date(entry.date).getTime();
                        if (entryDate < periodStartTime && entry.type === 'Withdrawal') {
                            startingBalanceForPeriod -= parseFloat(entry.amount) || 0;
                        }
                    });
                    
                    // Add P&L before period
                    allTrades.forEach(trade => {
                        const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                        if (exitDate && exitDate < periodStartTime) {
                            startingBalanceForPeriod += calculateNetPnl(trade);
                        }
                    });
                    
                    // Now calculate progression within period
                    sortedDates.forEach(date => {
                        const dateTime = new Date(date).getTime();
                        
                        // Calculate P&L within period up to this date
                        let pnlInPeriod = 0;
                        filteredTrades.forEach(trade => {
                            const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                            if (exitDate && exitDate <= dateTime) {
                                pnlInPeriod += calculateNetPnl(trade);
                            }
                        });
                        
                        // Calculate deposits within period up to this date
                        let depositsInPeriod = 0;
                        filteredLedger.forEach(entry => {
                            const entryDate = new Date(entry.date).getTime();
                            if (entryDate <= dateTime && entry.type === 'Deposit') {
                                depositsInPeriod += parseFloat(entry.amount) || 0;
                            }
                        });
                        
                        // Calculate withdrawals within period up to this date
                        let withdrawalsInPeriod = 0;
                        filteredLedger.forEach(entry => {
                            const entryDate = new Date(entry.date).getTime();
                            if (entryDate <= dateTime && entry.type === 'Withdrawal') {
                                withdrawalsInPeriod += parseFloat(entry.amount) || 0;
                            }
                        });
                        
                        // Account value = starting balance + deposits - withdrawals + P&L
                        const accountValue = startingBalanceForPeriod + depositsInPeriod - withdrawalsInPeriod + pnlInPeriod;
                        accountValueData.push(accountValue);
                    });
                }
                
                // Update chart data
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = accountValueData;
                chart.update();
                
            } catch (e) {
                console.error('updateBalanceChart error', e);
            }
        };

        // Function to set active filter button
        const setActiveFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#balance-filter-week, #balance-filter-month, #balance-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`balance-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };

        // Add event listeners for filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const weekButton = document.getElementById('balance-filter-week');
            const monthButton = document.getElementById('balance-filter-month');
            const allButton = document.getElementById('balance-filter-all');
            
            if (weekButton) {
                weekButton.addEventListener('click', () => {
                    balanceChartFilter = 'week';
                    setActiveFilterButton('week');
                    updateBalanceChart('week');
                });
            }
            
            if (monthButton) {
                monthButton.addEventListener('click', () => {
                    balanceChartFilter = 'month';
                    setActiveFilterButton('month');
                    updateBalanceChart('month');
                });
            }
            
            if (allButton) {
                allButton.addEventListener('click', () => {
                    // Reset chart states to prevent hover interference
                    resetChartState(chartInstances['accountBalanceChart']);
                    clearChartHoverStates();
                    
                    balanceChartFilter = 'all';
                    setActiveFilterButton('all');
                    updateBalanceChart('all');
                });
            }
            
            // Set initial active state
            setActiveFilterButton('month');
            
            // Initialize chart with current month data
            updateBalanceChart('month');
            
            // Profile form event listeners
            const profileForm = document.getElementById('profile-info-form');
            if (profileForm) {
                profileForm.addEventListener('submit', handleProfileFormSubmit);
            }
            
            const passwordForm = document.getElementById('change-password-form');
            if (passwordForm) {
                passwordForm.addEventListener('submit', handlePasswordFormSubmit);
            }
        });

        // --- EQUITY CURVE CHART FILTER LOGIC ---
        let equityChartFilter = 'month'; // Default to current month
        
        // Function to update equity chart with filtered data
        const updateEquityChart = (period) => {
            try {
                const chart = chartInstances['equityCurveChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                
                // For All Time: use all data
                // For Week/Month: filter data within period
                let filteredTrades = allTrades;
                
                if (dateRange.start && dateRange.end) {
                    // Filter trades within period
                    filteredTrades = allTrades.filter(trade => {
                        const tradeDate = new Date(trade.entry_date || trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                }
                
                // Get all unique dates from filtered trades
                const allDates = new Set();
                
                if (period === 'all') {
                    // All Time: Use ALL data for complete historical view
                    allTrades.forEach(trade => {
                        if (trade.entry_date) allDates.add(trade.entry_date);
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                } else {
                    // Week/Month: Use filtered data for period-specific view
                    filteredTrades.forEach(trade => {
                        if (trade.entry_date) allDates.add(trade.entry_date);
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                }
                
                const deduplicatedDates = Array.from(allDates);
                const sortedDates = deduplicatedDates.sort();
                
                if (sortedDates.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    return;
                }
                
                // Calculate equity curve progression
                const chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                const equityData = [];
                
                if (period === 'all') {
                    // All Time: Show cumulative equity from beginning
                    let cumulativePnl = 0;
                    sortedDates.forEach(date => {
                        const dateTime = new Date(date).getTime();
                        
                        // Calculate P&L up to this date (from all trades)
                        let pnlToDate = 0;
                        allTrades.forEach(trade => {
                            const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                            if (exitDate && exitDate <= dateTime) {
                                pnlToDate += calculateNetPnl(trade);
                            }
                        });
                        
                        cumulativePnl = pnlToDate;
                        equityData.push(cumulativePnl);
                    });
                } else {
                    // Week/Month: Show equity progression within period
                    // Get starting equity at beginning of period
                    const periodStartTime = dateRange.start.getTime();
                    let startingEquityForPeriod = 0;
                    
                    // Add P&L before period
                    allTrades.forEach(trade => {
                        const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                        if (exitDate && exitDate < periodStartTime) {
                            startingEquityForPeriod += calculateNetPnl(trade);
                        }
                    });
                    
                    // Now calculate progression within period
                    sortedDates.forEach(date => {
                        const dateTime = new Date(date).getTime();
                        
                        // Calculate P&L within period up to this date
                        let pnlInPeriod = 0;
                        filteredTrades.forEach(trade => {
                            const exitDate = trade.exit_date ? new Date(trade.exit_date).getTime() : null;
                            if (exitDate && exitDate <= dateTime) {
                                pnlInPeriod += calculateNetPnl(trade);
                            }
                        });
                        
                        // Equity = starting equity + P&L in period
                        const equity = startingEquityForPeriod + pnlInPeriod;
                        equityData.push(equity);
                    });
                }
                
                // Update chart data
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = equityData;
                chart.update();
                
            } catch (e) {
                console.error('updateEquityChart error', e);
            }
        };

        // Function to set active equity filter button
        const setActiveEquityFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#equity-filter-week, #equity-filter-month, #equity-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`equity-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };

        // Add event listeners for equity filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const equityWeekButton = document.getElementById('equity-filter-week');
            const equityMonthButton = document.getElementById('equity-filter-month');
            const equityAllButton = document.getElementById('equity-filter-all');
            
            if (equityWeekButton) {
                equityWeekButton.addEventListener('click', () => {
                    equityChartFilter = 'week';
                    setActiveEquityFilterButton('week');
                    updateEquityChart('week');
                });
            }
            
            if (equityMonthButton) {
                equityMonthButton.addEventListener('click', () => {
                    equityChartFilter = 'month';
                    setActiveEquityFilterButton('month');
                    updateEquityChart('month');
                });
            }
            
            if (equityAllButton) {
                equityAllButton.addEventListener('click', () => {
                    // Reset chart states to prevent hover interference
                    resetChartState(chartInstances['equityCurveChart']);
                    clearChartHoverStates();
                    
                    equityChartFilter = 'all';
                    setActiveEquityFilterButton('all');
                    updateEquityChart('all');
                });
            }
            
            // Set initial active state
            setActiveEquityFilterButton('month');
            
            // Initialize chart with current month data
            updateEquityChart('month');
        });

        // --- DAILY P&L CHART FILTER LOGIC ---
        let dailyPnlChartFilter = 'month'; // Default to current month
        
        // Function to update daily P&L chart with filtered data
        const updateDailyPnlChart = (period) => {
            try {
                const chart = chartInstances['dailyPnlChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                
                // For All Time: use all closed trades
                // For Week/Month: filter closed trades within period
                let filteredTrades = allTrades.filter(trade => {
                    // Only include closed trades (consistent with original chart)
                    return trade.exit_date && trade.exit_price && (!trade.exit_quantity || trade.exit_quantity >= trade.quantity);
                });
                
                if (dateRange.start && dateRange.end) {
                    // Filter closed trades within period
                    filteredTrades = filteredTrades.filter(trade => {
                        const tradeDate = new Date(trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                }
                
                // Get all unique dates from filtered trades with date normalization
                const allDates = new Set();
                
                if (period === 'all') {
                    // All Time: Use ALL closed trades for complete historical view
                    allTrades.filter(trade => {
                        return trade.exit_date && trade.exit_price && (!trade.exit_quantity || trade.exit_quantity >= trade.quantity);
                    }).forEach(trade => {
                        if (trade.exit_date) {
                            try {
                                const exitDate = new Date(trade.exit_date);
                                if (!isNaN(exitDate.getTime())) {
                                    const normalizedDate = exitDate.toISOString().split('T')[0];
                                    allDates.add(normalizedDate);
                                }
                            } catch (e) {
                                console.warn('Daily P&L: Invalid exit_date for date collection:', trade.id, trade.exit_date);
                            }
                        }
                    });
                } else {
                    // Week/Month: Use filtered data for period-specific view
                    filteredTrades.forEach(trade => {
                        if (trade.exit_date) {
                            try {
                                const exitDate = new Date(trade.exit_date);
                                if (!isNaN(exitDate.getTime())) {
                                    const normalizedDate = exitDate.toISOString().split('T')[0];
                                    allDates.add(normalizedDate);
                                }
                            } catch (e) {
                                console.warn('Daily P&L: Invalid exit_date for date collection:', trade.id, trade.exit_date);
                            }
                        }
                    });
                }
                
                const deduplicatedDates = Array.from(allDates);
                const sortedDates = deduplicatedDates.sort();
                
                if (sortedDates.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    return;
                }
                
                // Calculate daily P&L data with date normalization
                const chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                const dailyPnlData = {};
                
                // Calculate daily P&L from filtered trades with consistent logic
                filteredTrades.forEach(trade => {
                    if (trade.exit_date) {
                        try {
                            // Normalize date to YYYY-MM-DD format for consistent grouping
                            const exitDate = new Date(trade.exit_date);
                            if (!isNaN(exitDate.getTime())) {
                                const normalizedDate = exitDate.toISOString().split('T')[0];
                                const pnl = calculateNetPnl(trade);
                                if (isFinite(pnl)) {
                                    dailyPnlData[normalizedDate] = (dailyPnlData[normalizedDate] || 0) + pnl;
                                }
                            }
                        } catch (e) {
                            console.warn('Daily P&L Filter: Invalid exit_date for trade:', trade.id, trade.exit_date);
                        }
                    }
                });
                
                const data = sortedDates.map(date => dailyPnlData[date] || 0);
                
                // Update chart data
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = data;
                
                // Update colors based on positive/negative values
                chart.data.datasets[0].backgroundColor = data.map(value => 
                    value >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'
                );
                chart.data.datasets[0].borderColor = data.map(value => 
                    value >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'
                );
                
                chart.update();
                
            } catch (e) {
                console.error('updateDailyPnlChart error', e);
            }
        };

        // Function to set active daily P&L filter button
        const setActiveDailyPnlFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#dailyPnl-filter-week, #dailyPnl-filter-month, #dailyPnl-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`dailyPnl-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };

        // Add event listeners for daily P&L filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const dailyPnlWeekButton = document.getElementById('dailyPnl-filter-week');
            const dailyPnlMonthButton = document.getElementById('dailyPnl-filter-month');
            const dailyPnlAllButton = document.getElementById('dailyPnl-filter-all');
            
            if (dailyPnlWeekButton) {
                dailyPnlWeekButton.addEventListener('click', () => {
                    dailyPnlChartFilter = 'week';
                    setActiveDailyPnlFilterButton('week');
                    updateDailyPnlChart('week');
                });
            }
            
            if (dailyPnlMonthButton) {
                dailyPnlMonthButton.addEventListener('click', () => {
                    dailyPnlChartFilter = 'month';
                    setActiveDailyPnlFilterButton('month');
                    updateDailyPnlChart('month');
                });
            }
            
            if (dailyPnlAllButton) {
                dailyPnlAllButton.addEventListener('click', () => {
                    // Reset chart states to prevent hover interference
                    resetChartState(chartInstances['dailyPnlChart']);
                    clearChartHoverStates();
                    
                    dailyPnlChartFilter = 'all';
                    setActiveDailyPnlFilterButton('all');
                    updateDailyPnlChart('all');
                });
            }
            
            // Set initial active state
            setActiveDailyPnlFilterButton('month');
            
            // Initialize chart with current month data
            updateDailyPnlChart('month');
        });

        // --- DAILY WIN RATE CHART FILTER LOGIC ---
        let dailyWinRateChartFilter = 'month'; // Default to current month
        
        // Function to update daily win rate chart with filtered data
        const updateDailyWinRateChart = (period) => {
            try {
                const chart = chartInstances['dailyWinRateChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                
                // For All Time: use all data
                // For Week/Month: filter data within period
                let filteredTrades = allTrades;
                
                if (dateRange.start && dateRange.end) {
                    // Filter trades within period
                    filteredTrades = allTrades.filter(trade => {
                        const tradeDate = new Date(trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                }
                
                // Get all unique dates from filtered trades
                const allDates = new Set();
                
                if (period === 'all') {
                    // All Time: Use ALL data for complete historical view
                    allTrades.forEach(trade => {
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                } else {
                    // Week/Month: Use filtered data for period-specific view
                    filteredTrades.forEach(trade => {
                        if (trade.exit_date) allDates.add(trade.exit_date);
                    });
                }
                
                const deduplicatedDates = Array.from(allDates);
                const sortedDates = deduplicatedDates.sort();
                
                if (sortedDates.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.data.datasets[1].data = [];
                    chart.update();
                    return;
                }
                
                // Calculate daily win rate data
                const chartLabels = sortedDates.map(date => window.utils.formatDateDDMMYYYY(date));
                const dailyWinRateData = [];
                const avgWinRateData = [];
                
                let cumulativeWins = 0;
                let cumulativeTrades = 0;
                
                sortedDates.forEach(date => {
                    // Calculate daily win rate statistics for this date
                    const dayTrades = filteredTrades.filter(trade => {
                        if (trade.exit_date) {
                            const exitDate = new Date(trade.exit_date);
                            const tradeDate = exitDate.toISOString().split('T')[0];
                            return tradeDate === date;
                        }
                        return false;
                    });
                    
                    const dailyWins = dayTrades.filter(trade => calculateNetPnl(trade) > 0).length;
                    const totalTrades = dayTrades.length;
                    const dailyRatePct = totalTrades > 0 ? (dailyWins / totalTrades) * 100 : 0;
                    
                    dailyWinRateData.push(dailyRatePct);
                    
                    // Calculate cumulative average win rate
                    cumulativeWins += dailyWins;
                    cumulativeTrades += totalTrades;
                    const avgWinRate = cumulativeTrades > 0 ? (cumulativeWins / cumulativeTrades) * 100 : 0;
                    avgWinRateData.push(avgWinRate);
                });
                
                // Update chart data
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = dailyWinRateData;
                chart.data.datasets[1].data = avgWinRateData;
                chart.update();
                
            } catch (e) {
                console.error('updateDailyWinRateChart error', e);
            }
        };

        // Function to set active daily win rate filter button
        const setActiveDailyWinRateFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#dailyWinRate-filter-week, #dailyWinRate-filter-month, #dailyWinRate-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`dailyWinRate-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };

        // Add event listeners for daily win rate filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const dailyWinRateWeekButton = document.getElementById('dailyWinRate-filter-week');
            const dailyWinRateMonthButton = document.getElementById('dailyWinRate-filter-month');
            const dailyWinRateAllButton = document.getElementById('dailyWinRate-filter-all');
            
            if (dailyWinRateWeekButton) {
                dailyWinRateWeekButton.addEventListener('click', () => {
                    dailyWinRateChartFilter = 'week';
                    setActiveDailyWinRateFilterButton('week');
                    updateDailyWinRateChart('week');
                });
            }
            
            if (dailyWinRateMonthButton) {
                dailyWinRateMonthButton.addEventListener('click', () => {
                    dailyWinRateChartFilter = 'month';
                    setActiveDailyWinRateFilterButton('month');
                    updateDailyWinRateChart('month');
                });
            }
            
            if (dailyWinRateAllButton) {
                dailyWinRateAllButton.addEventListener('click', () => {
                    // Reset chart states to prevent hover interference
                    resetChartState(chartInstances['dailyWinRateChart']);
                    clearChartHoverStates();
                    
                    dailyWinRateChartFilter = 'all';
                    setActiveDailyWinRateFilterButton('all');
                    updateDailyWinRateChart('all');
                });
            }
            
            // Set initial active state
            setActiveDailyWinRateFilterButton('month');
            
            // Initialize chart with current month data
            updateDailyWinRateChart('month');
        });

        // Monthly Performance Chart Filter Logic
        let monthlyPerformanceChartFilter = 'month'; // Default to 12 months
        
        // Function to update monthly performance chart with filtered data
        const updateMonthlyPerformanceChart = (period) => {
            try {
                const chart = chartInstances['monthlyPerformanceChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                
                // For All Time: use all data
                // For Month: filter data within last 12 months
                let filteredTrades = allTrades;
                
                if (dateRange.start && dateRange.end) {
                    // Filter trades within period
                    filteredTrades = allTrades.filter(trade => {
                        const tradeDate = new Date(trade.entry_date || trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                }
                
                // Calculate monthly P&L from filtered trades
                const monthlyPnlData = {};
                let totalTrades = 0;
                let totalPnl = 0;
                
                filteredTrades.forEach(trade => {
                    if (trade.exit_date && trade.exit_date !== '') {
                        const exitDate = new Date(trade.exit_date);
                        const monthKey = `${exitDate.getFullYear()}-${String(exitDate.getMonth() + 1).padStart(2, '0')}`;
                        
                        if (!monthlyPnlData[monthKey]) {
                            monthlyPnlData[monthKey] = {
                                pnl: 0,
                                trades: 0,
                                wins: 0,
                                losses: 0
                            };
                        }
                        
                        const netPnl = calculateNetPnl(trade);
                        monthlyPnlData[monthKey].pnl += netPnl;
                        monthlyPnlData[monthKey].trades += 1;
                        totalTrades += 1;
                        totalPnl += netPnl;
                        
                        if (netPnl > 0) {
                            monthlyPnlData[monthKey].wins += 1;
                        } else if (netPnl < 0) {
                            monthlyPnlData[monthKey].losses += 1;
                        }
                    }
                });
                
                // Sort months chronologically
                const sortedMonths = Object.keys(monthlyPnlData).sort();
                
                if (sortedMonths.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    return;
                }
                
                // Prepare chart data
                const chartLabels = sortedMonths.map(month => {
                    const [year, monthNum] = month.split('-');
                    const date = new Date(year, monthNum - 1);
                    return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                });
                
                const chartData = sortedMonths.map(month => monthlyPnlData[month].pnl);
                
                // Update chart
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = chartData;
                chart.update();
                
            } catch (e) {
                console.error('updateMonthlyPerformanceChart error', e);
            }
        };
        
        // Function to set active filter button for Monthly Performance
        const setActiveMonthlyPerformanceFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#monthly-performance-filter-month, #monthly-performance-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`monthly-performance-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };
        
        // Add event listeners for Monthly Performance filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const monthButton = document.getElementById('monthly-performance-filter-month');
            const allButton = document.getElementById('monthly-performance-filter-all');
            
            if (monthButton) {
                monthButton.addEventListener('click', () => {
                    monthlyPerformanceChartFilter = 'month';
                    setActiveMonthlyPerformanceFilterButton('month');
                    updateMonthlyPerformanceChart('month');
                });
            }
            
            if (allButton) {
                allButton.addEventListener('click', () => {
                    // Reset chart states to prevent hover interference
                    resetChartState(chartInstances['monthlyPerformanceChart']);
                    clearChartHoverStates();
                    
                    monthlyPerformanceChartFilter = 'all';
                    setActiveMonthlyPerformanceFilterButton('all');
                    updateMonthlyPerformanceChart('all');
                });
            }
            
            // Set initial active state
            setActiveMonthlyPerformanceFilterButton('month');
            
            // Initialize chart with 12-month data
            updateMonthlyPerformanceChart('month');
        });

        // Monthly Commission/Charges Chart Filter Logic
        let monthlyCommissionChartFilter = 'month'; // Default to 12 months
        
        // Function to update monthly commission/charges chart with filtered data
        const updateMonthlyCommissionChart = (period) => {
            try {
                const chart = chartInstances['monthlyChargesChart'];
                if (!chart) return;

                const dateRange = getPeriodDateRange(period);
                const allTrades = appState.trades || [];
                
                // For All Time: use all data
                // For Month: filter data within last 12 months
                let filteredTrades = allTrades;
                
                if (dateRange.start && dateRange.end) {
                    // Filter trades within period
                    filteredTrades = allTrades.filter(trade => {
                        const tradeDate = new Date(trade.entry_date || trade.exit_date);
                        return tradeDate >= dateRange.start && tradeDate <= dateRange.end;
                    });
                }
                
                // Calculate monthly commission/charges from filtered trades
                const monthlyChargesData = {};
                let totalTrades = 0;
                let totalCharges = 0;
                
                filteredTrades.forEach(trade => {
                    if (trade.exit_date && trade.exit_date !== '') {
                        const exitDate = new Date(trade.exit_date);
                        const monthKey = `${exitDate.getFullYear()}-${String(exitDate.getMonth() + 1).padStart(2, '0')}`;
                        
                        if (!monthlyChargesData[monthKey]) {
                            monthlyChargesData[monthKey] = {
                                charges: 0,
                                trades: 0,
                                brokerage: 0,
                                otherCharges: 0
                            };
                        }
                        
                        // Calculate total charges for this trade
                        const tradeCharges = parseFloat(trade.brokerage || 0) + parseFloat(trade.charges || 0);
                        monthlyChargesData[monthKey].charges += tradeCharges;
                        monthlyChargesData[monthKey].brokerage += parseFloat(trade.brokerage || 0);
                        monthlyChargesData[monthKey].otherCharges += parseFloat(trade.charges || 0);
                        monthlyChargesData[monthKey].trades += 1;
                        totalTrades += 1;
                        totalCharges += tradeCharges;
                    }
                });
                
                // Sort months chronologically
                const sortedMonths = Object.keys(monthlyChargesData).sort();
                
                if (sortedMonths.length === 0) {
                    chart.data.labels = [];
                    chart.data.datasets[0].data = [];
                    chart.update();
                    return;
                }
                
                // Prepare chart data
                const chartLabels = sortedMonths.map(month => {
                    const [year, monthNum] = month.split('-');
                    const date = new Date(year, monthNum - 1);
                    return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
                });
                
                const chartData = sortedMonths.map(month => monthlyChargesData[month].charges);
                
                // Update chart
                chart.data.labels = chartLabels;
                chart.data.datasets[0].data = chartData;
                chart.update();
                
            } catch (e) {
                console.error('updateMonthlyCommissionChart error', e);
            }
        };
        
        // Function to set active filter button for Monthly Commission/Charges
        const setActiveMonthlyCommissionFilterButton = (activePeriod) => {
            // Remove active class from all buttons
            document.querySelectorAll('#monthly-commission-filter-month, #monthly-commission-filter-all').forEach(btn => {
                btn.classList.remove('active');
                btn.style.backgroundColor = 'var(--bg-secondary)';
                btn.style.color = 'var(--text-secondary)';
            });
            
            // Add active class to selected button
            const activeButton = document.getElementById(`monthly-commission-filter-${activePeriod}`);
            if (activeButton) {
                activeButton.classList.add('active');
                activeButton.style.backgroundColor = 'var(--accent-color, #3b82f6)';
                activeButton.style.color = 'white';
            }
        };
        
        // Add event listeners for Monthly Commission/Charges filter buttons
        document.addEventListener('DOMContentLoaded', function() {
            const monthButton = document.getElementById('monthly-commission-filter-month');
            const allButton = document.getElementById('monthly-commission-filter-all');
            
            if (monthButton) {
                monthButton.addEventListener('click', () => {
                    monthlyCommissionChartFilter = 'month';
                    setActiveMonthlyCommissionFilterButton('month');
                    updateMonthlyCommissionChart('month');
                });
            }
            
            if (allButton) {
                allButton.addEventListener('click', () => {
                    monthlyCommissionChartFilter = 'all';
                    setActiveMonthlyCommissionFilterButton('all');
                    updateMonthlyCommissionChart('all');
                });
            }
            
            // Set initial active state
            setActiveMonthlyCommissionFilterButton('month');
            
            // Initialize chart with 12-month data
            updateMonthlyCommissionChart('month');
        });
        
        // --- FORM LOGIC (ALL FILLED IN) ---
        const tradeForm = document.getElementById('manual-trade-form');
        const updateCalculations = () => {
            const entryPrice = parseFloat(document.getElementById('entry-price').value) || 0;
            const qty = parseFloat(document.getElementById('quantity').value) || 0;
            const exitPrice = parseFloat(document.getElementById('exit-price').value) || 0;
            const exitQuantity = parseFloat(document.getElementById('exit-quantity').value) || 0;
            const stopLoss = parseFloat(document.getElementById('stop-loss').value) || 0;
            const target = parseFloat(document.getElementById('target').value) || 0;
            const brokerage = parseFloat(document.getElementById('brokerage').value) || 0;
            const otherFees = parseFloat(document.getElementById('other-fees').value) || 0;
            
            // Calculate total amount
            const total = entryPrice * qty;
            
            // Get direction from active button or default to Long
            const direction = document.querySelector('#direction-group .active')?.dataset?.value || 'Long';
            const directionMultiplier = direction === 'Short' ? -1 : 1;
            
            // Calculate stop loss and target percentages based on direction
            let stopLossPercent = 0;
            let targetPercent = 0;
            
            if (entryPrice && stopLoss) {
                if (direction === 'Long') {
                    // For Long: risk percentage = (entry - stop loss) / entry * 100
                    stopLossPercent = ((entryPrice - stopLoss) / entryPrice) * 100;
                } else {
                    // For Short: risk percentage = (stop loss - entry) / entry * 100
                    stopLossPercent = ((stopLoss - entryPrice) / entryPrice) * 100;
                }
            }
            
            if (entryPrice && target) {
                if (direction === 'Long') {
                    // For Long: profit percentage = (target - entry) / entry * 100
                    targetPercent = ((target - entryPrice) / entryPrice) * 100;
                } else {
                    // For Short: profit percentage = (entry - target) / entry * 100
                    targetPercent = ((entryPrice - target) / entryPrice) * 100;
                }
            }
            const exitQty = exitQuantity > 0 ? exitQuantity : qty; // Use exit quantity if specified, otherwise full quantity
            const grossPnl = (exitPrice && exitQty) ? (exitPrice - entryPrice) * exitQty * directionMultiplier : 0;
            
            // Calculate net P&L (after brokerage and charges)
            const totalCharges = brokerage + otherFees;
            const netPnl = grossPnl - totalCharges;
            
            // Calculate P&L percentage based on total investment and total return
            // This shows the actual return percentage on the total investment
            // For partial exits: shows what percentage of total investment was returned
            const totalInvestment = entryPrice * qty; // Always use full entry quantity for total investment
            const pnlPct = (entryPrice && qty && exitPrice) ? (netPnl / totalInvestment) * 100 : 0;
            
            // Update total amount
            const totalEl = document.getElementById('total-amount');
            if (totalEl) totalEl.textContent = window.utils.formatCurrency(total);
            
            // Update stop loss percentage
            const stopLossPercentEl = document.getElementById('stop-loss-percent');
            if (stopLossPercentEl) {
                if (stopLoss && entryPrice) {
                    stopLossPercentEl.textContent = `(${stopLossPercent.toFixed(2)}%)`;
                    // Stop loss is always a risk, so show in red
                    stopLossPercentEl.style.color = '#ef4444';
                } else {
                    stopLossPercentEl.textContent = '';
                }
            }
            
            // Update target percentage
            const targetPercentEl = document.getElementById('target-percent');
            if (targetPercentEl) {
                if (target && entryPrice) {
                    targetPercentEl.textContent = `(${targetPercent.toFixed(2)}%)`;
                    // Target is always a profit expectation, so show in green
                    targetPercentEl.style.color = '#22c55e';
                } else {
                    targetPercentEl.textContent = '';
                }
            }
            
            // Update Gross P&L
            const grossPnlEl = document.getElementById('gross-pnl-amount');
            if (grossPnlEl) {
                grossPnlEl.textContent = window.utils.formatCurrency(grossPnl);
                grossPnlEl.style.color = grossPnl >= 0 ? '#22c55e' : '#ef4444';
            }
            
            // Update Total Charges
            const totalChargesEl = document.getElementById('total-charges');
            if (totalChargesEl) {
                totalChargesEl.textContent = window.utils.formatCurrency(totalCharges);
            }
            
            // Update Net P&L Amount (after charges)
            const pnlAmtEl = document.getElementById('pnl-amount');
            if (pnlAmtEl) {
                pnlAmtEl.textContent = window.utils.formatCurrency(netPnl);
                pnlAmtEl.style.color = netPnl >= 0 ? '#22c55e' : '#ef4444';
            }
            
            // Update P&L Percentage
            const pnlPctEl = document.getElementById('pnl-percent');
            if (pnlPctEl) {
                pnlPctEl.textContent = `${pnlPct.toFixed(2)}%`;
                pnlPctEl.style.color = pnlPct >= 0 ? '#22c55e' : '#ef4444';
            }
        };
        const clearTradeForm = () => {
            if (!tradeForm) return;
            tradeForm.reset();
            
            // Reset button groups to default active states
            document.querySelectorAll('.form-btn-group').forEach(group => {
                group.querySelectorAll('button').forEach(btn => {
                    btn.classList.remove('active', 'active-long', 'active-short', 'active-green');
                });
            });
            
            // Set default active buttons with proper classes
            const longBtn = document.querySelector('#direction-group button[data-value="Long"]');
            const equityBtn = document.querySelector('#segment-group button[data-value="Equity"]');
            const intradayBtn = document.querySelector('#trading-style-group button[data-value="Intraday"]');
            
            if (longBtn) {
                longBtn.classList.add('active', 'active-long');
            }
            if (equityBtn) {
                equityBtn.classList.add('active', 'active-green');
            }
            if (intradayBtn) {
                intradayBtn.classList.add('active', 'active-green');
            }
            
            // Clear Psychology fields
            const emotionalStateSelect = document.getElementById('emotional-state');
            if (emotionalStateSelect) {
                emotionalStateSelect.value = '';
            }
            
            // Clear all mistake checkboxes
            document.querySelectorAll('input[name="mistakes"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            updateCalculations();
        };
        // Add event listeners for all calculation inputs
        const calculationInputs = [
            'entry-price', 'quantity', 'exit-price', 'exit-quantity', 'stop-loss', 'target', 
            'brokerage', 'other-fees'
        ];
        
        calculationInputs.forEach(inputId => {
            const input = document.getElementById(inputId);
            if (input) {
                input.addEventListener('input', updateCalculations);
                input.addEventListener('change', updateCalculations);
            }
        });
        
        // Also listen to form input events as fallback
        tradeForm.addEventListener('input', e => {
            updateCalculations();
        });
        // Button group functionality
        const setupButtonGroups = () => {
            const groups = document.querySelectorAll('.form-btn-group');
            console.log('Found button groups:', groups.length);
            
            groups.forEach(group => {
                console.log('Setting up group:', group.id);
                group.addEventListener('click', e => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log('Group clicked:', group.id, 'Target:', e.target);
                    
                    const btn = e.target.closest('button');
                    if (!btn || btn.tagName !== 'BUTTON') {
                        console.log('No button found or not a button element');
                        return;
                    }
                    
                    console.log('Button clicked:', btn.dataset.value, 'in group:', group.id);
                    
                    // Remove active class from all buttons in this group
                    group.querySelectorAll('button').forEach(b => {
                        b.classList.remove('active', 'active-long', 'active-short', 'active-green');
                    });
                    
                    // Add active class to clicked button
                    btn.classList.add('active');
                    
                    // Add specific classes for direction buttons
                    if (group.id === 'direction-group') {
                        if (btn.dataset.value === 'Long') {
                            btn.classList.add('active-long');
                            console.log('Long button activated - should be green');
                        } else if (btn.dataset.value === 'Short') {
                            btn.classList.add('active-short');
                            console.log('Short button activated - should be red');
                        }
                    } else {
                        btn.classList.add('active-green');
                    }
                    
                    // Update form calculations
                    updateCalculations();
                    
                    console.log('Button state updated:', btn.className);
                });
            });
        };
        
        // Setup button groups will be called on DOM ready
        
        document.getElementById('clear-trade-form-btn').addEventListener('click', clearTradeForm);
        
        // Prevent Enter key from submitting the form (except on submit button)
        tradeForm.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.target.type !== 'submit') {
                e.preventDefault();
                console.log('Enter key prevented from submitting form');
            }
        });
        
        tradeForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            console.log('Form submitted! Event:', e);
            console.log('Submitter:', e.submitter);
            console.log('Target:', e.target);
            console.log('Current active tab:', document.querySelector('#trade-tab').style.backgroundColor);
            
            // Check if this is coming from the Save Trade button
            if (e.submitter && e.submitter.textContent.includes('Save Trade')) {
                console.log('Form submitted from Save Trade button - proceeding with save');
            } else {
                console.log('Form submitted from unexpected source - blocking save');
                return;
            }
            
            const form = new FormData(tradeForm);
            console.log('Form data collected:', Object.fromEntries(form.entries()));
            console.log('Entry Date:', form.get('entryDate'));
            console.log('Entry Time:', form.get('entryTime'));
            console.log('Exit Date:', form.get('exitDate'));
            console.log('Exit Time:', form.get('exitTime'));
            
            // Collect mistakes made (checkboxes)
            const mistakes = [];
            document.querySelectorAll('input[name="mistakes"]:checked').forEach(checkbox => {
                mistakes.push(checkbox.value);
            });
            
            // Helper function to create valid timestamp
            const createTimestamp = (date, time) => {
                console.log('createTimestamp called with:', { date, time });
                if (!date || String(date).trim() === '') {
                    console.log('Missing date, returning null');
                    return null;
                }
                // If time is missing, default to 00:00; otherwise use provided time
                const safeTime = (!time || String(time).trim() === '') ? '00:00' : String(time).trim();
                try {
                    const timestamp = `${date}T${safeTime}:00`;
                    console.log('Created timestamp:', timestamp);
                    // Validate the timestamp
                    const dateObj = new Date(timestamp);
                    const isValid = !isNaN(dateObj.getTime());
                    console.log('Timestamp validation:', { timestamp, isValid, dateObj });
                    if (!isValid) {
                        console.error('Invalid timestamp created:', timestamp);
                        return null;
                    }
                    return timestamp;
                } catch (error) {
                    console.error('Error creating timestamp:', error);
                    return null;
                }
            };

            // Get current active challenge for trade tagging from the app's state
            const activeChallenge = appState.challenge;
            const challengeId = activeChallenge ? activeChallenge.id : null;
            const challengeCreatedAt = activeChallenge ? activeChallenge.createdAt : null;

            const trade = {
                id: document.getElementById('trade-id').value || window.utils.generateUUID(),
                user_id: appState.user?.id || 'anonymous',
                asset: form.get('asset') || '',
                direction: document.querySelector('#direction-group .active')?.dataset?.value || form.get('direction') || 'Long',
                segment: document.querySelector('#segment-group .active')?.dataset?.value || form.get('segment') || 'Equity',
                trading_style: document.querySelector('#trading-style-group .active')?.dataset?.value || form.get('tradingStyle') || 'Intraday',
                entry_date: createTimestamp(form.get('entryDate'), form.get('entryTime')),
                entry_price: parseFloat(form.get('entryPrice')) || 0,
                quantity: parseFloat(form.get('quantity')) || 0,
                // Challenge isolation tags
                challenge_id: challengeId,
                challenge_created_at: challengeCreatedAt,
                stop_loss: form.get('stopLoss') ? parseFloat(form.get('stopLoss')) : null,
                target: form.get('target') ? parseFloat(form.get('target')) : null,
                exit_date: createTimestamp(form.get('exitDate'), form.get('exitTime')),
                exit_price: form.get('exitPrice') ? parseFloat(form.get('exitPrice')) : null,
                exit_quantity: form.get('exitQuantity') ? parseFloat(form.get('exitQuantity')) : null,
                brokerage: form.get('brokerage') ? parseFloat(form.get('brokerage')) : 0,
                other_fees: form.get('otherFees') ? parseFloat(form.get('otherFees')) : 0,
                strategy: form.get('strategy') || '',
                outcomeSummary: form.get('outcomeSummary') || '',
                reasons: form.get('reasons') || '',
                emotionalState: form.get('emotionalState') || '',
                mistakes: mistakes
            };
            try {
                console.log('Attempting to save trade:', trade);
                console.log('Trade entry_date:', trade.entry_date, 'type:', typeof trade.entry_date);
                console.log('Trade exit_date:', trade.exit_date, 'type:', typeof trade.exit_date);
                console.log('Supabase client available:', !!supabase);
                await dataStore.upsertTrade(trade);
                console.log('Trade saved successfully');
                appState.trades = await dataStore.getTrades();
                console.log('Trades refreshed, count:', appState.trades.length);
                clearTradeForm();
                window.main.loadDashboardData().then(data => {
                  window.ui.renderDashboardUI(data);
                }).catch(err => {
                  console.error('loadDashboardData error', err);
                });
                renderTradeHistory();
                // Refresh AI Analyst if it's the current page
                if (document.getElementById('ai-analyst').classList.contains('active')) {
                    renderAIAnalyst();
                }
                feather.replace();
                showTradeSavedModal();
            } catch (err) {
                console.error('Failed to save trade', err);
                console.error('Error details:', {
                    message: err.message,
                    code: err.code,
                    details: err.details,
                    hint: err.hint
                });
                window.utils.showToast(`Failed to save trade: ${err.message}`, 'error');
            }
        });

        // --- CSV UPLOAD FUNCTIONALITY ---
        let csvUploadInProgress = false;
        let csvEventListenersAttached = false; // Prevent duplicate event listeners
        let lastProcessedFile = null; // Track last processed file to prevent duplicates

        // CSV Upload Event Listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Prevent attaching event listeners multiple times
            if (csvEventListenersAttached) {
                console.log('CSV event listeners already attached, skipping');
                return;
            }
            
            const csvBrowseBtn = document.getElementById('csv-browse-btn');
            const csvFileInput = document.getElementById('csv-file-input');
            const dropZone = document.getElementById('csv-drop-zone');
            const downloadSampleBtn = document.getElementById('download-sample-csv');
            
            // Check if elements exist before attaching listeners
            if (!csvBrowseBtn || !csvFileInput || !dropZone) {
                console.log('CSV elements not found, skipping event listener setup');
                return;
            }

            // Browse button click handler
            csvBrowseBtn?.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling to parent drop zone
                console.log('Browse button clicked');
                csvFileInput?.click();
            });

            // File input change handler
            csvFileInput?.addEventListener('change', (e) => {
                console.log('File input changed, files:', e.target.files.length);
                if (e.target.files.length > 0) {
                    console.log('Selected file:', e.target.files[0].name);
                }
                handleCSVFile(e);
            });

            // Sample CSV download handler
            downloadSampleBtn?.addEventListener('click', downloadSampleCSV);

            // Drag and Drop functionality
            dropZone?.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone?.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone?.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/csv') {
                    handleCSVFile({ target: { files: [files[0]] } });
                } else {
                    window.utils.showToast('Please select a CSV file', 'error');
                }
            });

            // Click to browse (but not when clicking the browse button itself)
            dropZone?.addEventListener('click', (e) => {
                // Prevent triggering file input if user clicked the browse button
                if (e.target.id !== 'csv-browse-btn' && !e.target.closest('#csv-browse-btn')) {
                    csvFileInput?.click();
                }
            });
            
            // Mark that event listeners have been attached
            csvEventListenersAttached = true;
            console.log('CSV event listeners attached successfully');
        });


        // CSV Processing Functions
        async function handleCSVFile(event) {
            console.log('handleCSVFile called');
            const file = event.target.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }
            
            console.log('Processing file:', file.name, 'Size:', file.size, 'Type:', file.type);
            
            // Check if this is the same file we just processed
            const fileSignature = `${file.name}_${file.size}_${file.lastModified}`;
            if (lastProcessedFile === fileSignature) {
                console.log('Same file already processed, ignoring duplicate');
                window.utils.showToast('This file was already processed', 'warning');
                return;
            }
            
            if (csvUploadInProgress) {
                console.log('Upload already in progress, ignoring');
                window.utils.showToast('CSV upload already in progress', 'error');
                return;
            }
            
            try {
                csvUploadInProgress = true;
                lastProcessedFile = fileSignature; // Mark this file as being processed
                showCSVProgress();
                
                const csvData = await parseCSVFile(file);
                const validationResult = validateCSVData(csvData);
                
                if (!validationResult.isValid) {
                    showCSVError(validationResult.errors);
                    return;
                }
                
                await uploadTradesFromCSV(csvData);
                
            } catch (error) {
                console.error('CSV upload error:', error);
                showCSVError([`Failed to process CSV: ${error.message}`]);
            } finally {
                csvUploadInProgress = false;
                hideCSVProgress();
                // Clear the file input to prevent double uploads
                if (event.target) {
                    event.target.value = '';
                }
                
                // Clear the processed file signature after 5 seconds to allow re-upload if needed
                setTimeout(() => {
                    if (lastProcessedFile === fileSignature) {
                        lastProcessedFile = null;
                        console.log('Cleared processed file signature, file can be uploaded again');
                    }
                }, 5000);
            }
        }

        function parseCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const csvText = e.target.result;
                        const lines = csvText.split('\n').filter(line => line.trim());
                        
                        if (lines.length < 2) {
                            throw new Error('CSV file must have at least a header and one data row');
                        }
                        
                        const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/"/g, ''));
                        const data = lines.slice(1).map(line => {
                            const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                            const row = {};
                            headers.forEach((header, index) => {
                                row[header] = values[index] || '';
                            });
                            return row;
                        });
                        
                        resolve({ headers, data });
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        function validateCSVData(csvData) {
            const requiredFields = ['symbol', 'direction', 'entry_date', 'entry_quantity'];
            const errors = [];
            
            // Check headers
            const missingHeaders = requiredFields.filter(field => 
                !csvData.headers.includes(field)
            );
            
            if (missingHeaders.length > 0) {
                errors.push(`Missing required columns: ${missingHeaders.join(', ')}`);
            }
            
            // Validate data rows
            csvData.data.forEach((row, index) => {
                const rowNum = index + 2; // +2 because we start from row 2 (after header)
                
                requiredFields.forEach(field => {
                    if (!row[field] || row[field].trim() === '') {
                        errors.push(`Row ${rowNum}: ${field} is required`);
                    }
                });
                
                // Optional time fields validation (only validate format if provided)
                const optionalTimeFields = ['entry_time', 'exit_time'];
                optionalTimeFields.forEach(field => {
                    if (row[field] && row[field].trim() !== '') {
                        // Basic time format validation (HH:MM or HH:MM:SS)
                        const timePattern = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;
                        if (!timePattern.test(row[field].trim())) {
                            errors.push(`Row ${rowNum}: ${field} must be in HH:MM or HH:MM:SS format`);
                        }
                    }
                });
                
                // Validate direction
                if (row.direction && !['Long', 'Short'].includes(row.direction)) {
                    errors.push(`Row ${rowNum}: direction must be 'Long' or 'Short'`);
                }
                
                // Validate numeric fields
                const numericFields = ['entry_quantity', 'entry_price', 'exit_quantity', 'exit_price', 'stop_loss', 'target_price', 'brokerage', 'charges'];
                numericFields.forEach(field => {
                    if (row[field] && row[field].trim() !== '' && isNaN(parseFloat(row[field]))) {
                        errors.push(`Row ${rowNum}: ${field} must be a valid number`);
                    }
                });

                // Validate date fields
                if (row.entry_date && row.entry_date.trim() !== '') {
                    const entryDate = window.utils.parseCSVDate(row.entry_date);
                    if (!entryDate || isNaN(entryDate.getTime())) {
                        errors.push(`Row ${rowNum}: entry_date must be a valid date (DD-MM-YYYY or YYYY-MM-DD format)`);
                    }
                }

                if (row.exit_date && row.exit_date.trim() !== '') {
                    const exitDate = window.utils.parseCSVDate(row.exit_date);
                    if (!exitDate || isNaN(exitDate.getTime())) {
                        errors.push(`Row ${rowNum}: exit_date must be a valid date (DD-MM-YYYY or YYYY-MM-DD format)`);
                    }
                }
            });
            
            return {
                isValid: errors.length === 0,
                errors
            };
        }

        async function uploadTradesFromCSV(csvData) {
            const progressContainer = document.getElementById('csv-progress-container');
            const progressBar = document.getElementById('csv-progress-bar');
            const progressText = document.getElementById('csv-progress-text');
            
            const totalTrades = csvData.data.length;
            let successCount = 0;
            let errorCount = 0;
            const errors = [];
            
            for (let i = 0; i < csvData.data.length; i++) {
                const row = csvData.data[i];
                
                try {
                    // Map CSV data to trade object
                    const trade = mapCSVRowToTrade(row);
                    
                    // Save trade using existing dataStore function
                    await dataStore.upsertTrade(trade);
                    successCount++;
                    
                } catch (error) {
                    errorCount++;
                    errors.push(`Row ${i + 2}: ${error.message}`);
                }
                
                // Update progress
                const progress = ((i + 1) / totalTrades) * 100;
                progressBar.style.width = `${progress}%`;
                progressText.textContent = `${i + 1}/${totalTrades}`;
                
                // Small delay to show progress
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            // Show results
            if (errorCount === 0) {
                showCSVSuccess(`Successfully uploaded ${successCount} trades`);
                // Refresh the UI
                appState.trades = await dataStore.getTrades();
                updateTradeDependentUI();
                window.utils.showToast(`Successfully uploaded ${successCount} trades`, 'success');
            } else {
                showCSVError(errors);
                if (successCount > 0) {
                    window.utils.showToast(`${successCount} trades uploaded successfully, ${errorCount} failed`, 'warning');
                    // Refresh the UI for successful trades
                    appState.trades = await dataStore.getTrades();
                    updateTradeDependentUI();
                }
            }
        }

        function mapCSVRowToTrade(row) {
            const entryDate = window.utils.parseCSVDate(row.entry_date);
            const exitDate = window.utils.parseCSVDate(row.exit_date);
            
            return {
                id: window.utils.generateUUID(),
                user_id: appState.user?.id || 'anonymous',
                asset: row.symbol || '',
                direction: row.direction || 'Long',
                segment: 'Equity', // Default segment
                trading_style: row.trading_style || 'Scalping',
                entry_date: entryDate ? entryDate.toISOString() : null,
                entry_time: row.entry_time || '',
                entry_price: parseFloat(row.entry_price) || 0,
                quantity: parseFloat(row.entry_quantity) || 0,
                stop_loss: parseFloat(row.stop_loss) || null,
                target: parseFloat(row.target_price) || null,
                exit_date: exitDate ? exitDate.toISOString() : null,
                exit_time: row.exit_time || '',
                exit_price: parseFloat(row.exit_price) || null,
                exit_quantity: parseFloat(row.exit_quantity) || null,
                brokerage: parseFloat(row.brokerage) || 0,
                other_fees: parseFloat(row.charges) || 0,
                strategy: row.strategy_tag || 'Price Action',
                outcomeSummary: row.outcome_summary || '',
                reasons: row.notes || '',
                emotionalState: row.emotional_state || '',
                mistakes: []
            };
        }

        // UI Helper Functions
        function showCSVProgress() {
            document.getElementById('csv-progress-container').classList.remove('hidden');
            document.getElementById('csv-results').classList.add('hidden');
        }

        function hideCSVProgress() {
            document.getElementById('csv-progress-container').classList.add('hidden');
        }

        function showCSVSuccess(message) {
            const resultsDiv = document.getElementById('csv-results');
            const successDiv = document.getElementById('csv-success-message');
            const errorDiv = document.getElementById('csv-error-message');
            
            resultsDiv.classList.remove('hidden');
            successDiv.classList.remove('hidden');
            errorDiv.classList.add('hidden');
            successDiv.textContent = message;
        }

        function showCSVError(errors) {
            const resultsDiv = document.getElementById('csv-results');
            const successDiv = document.getElementById('csv-success-message');
            const errorDiv = document.getElementById('csv-error-message');
            
            resultsDiv.classList.remove('hidden');
            successDiv.classList.add('hidden');
            errorDiv.classList.remove('hidden');
            errorDiv.innerHTML = errors.map(error => `<div>${error}</div>`).join('');
        }

        // Sample CSV Download Function
        function downloadSampleCSV() {
            const sampleData = [
                // Header row
                'symbol,direction,entry_date,entry_time,entry_quantity,entry_price,exit_date,exit_time,exit_price,exit_quantity,stop_loss,target_price,brokerage,charges,trading_style,strategy_tag,emotional_state,outcome_summary,notes',
                // Sample trade 1 - Complete trade (DD-MM-YYYY format)
                'AAPL,Long,15-01-2024,09:30,100,150.25,15-01-2024,15:45,152.80,100,148.00,155.00,2.50,1.25,Scalping,Price Action,Confident,Good trade - hit target,Strong momentum breakout',
                // Sample trade 2 - Open position without times (DD-MM-YYYY format)
                'TSLA,Short,16-01-2024,,50,245.30,,,,,240.00,250.00,1.25,0.75,Day Trading,Momentum,Neutral,,Short on resistance level',
                // Sample trade 3 - Partial exit (YYYY-MM-DD format - shows both formats work)
                'MSFT,Long,2024-01-17,11:00,200,380.50,2024-01-17,14:30,385.20,100,375.00,390.00,5.00,2.50,Swing Trading,Technical Analysis,Confident,Partial profit taken,Strong earnings play'
            ];

            const csvContent = sampleData.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', 'tradlyst_sample_trades.csv');
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        // --- INITIAL LOAD ---
        applyTheme();
        feather.replace();
        // Ensure export buttons are wired on initial load as well
        wireCsvButtons();
        // Setup global event listeners
        setupGlobalEventListeners();
        // Setup trade table event listeners
        setupTradeTableEventListeners();
        // Setup bulk delete event listeners
        setupBulkDeleteListeners();
        

        // Robust chart initialization with proper loading detection
        const initializeCharts = () => {
            const maxRetries = 10;
            let retryCount = 0;
            
            const tryInitializeCharts = () => {
                if (typeof Chart !== 'undefined' && typeof ChartZoom !== 'undefined') {
                    console.log('Chart.js and ChartZoom loaded successfully, initializing charts...');
                    renderAllCharts();
                } else if (retryCount < maxRetries) {
                    retryCount++;
                    console.log(`Chart.js not ready, retrying... (${retryCount}/${maxRetries})`);
                    setTimeout(tryInitializeCharts, 200 * retryCount); // Exponential backoff
                } else {
                    console.error('Chart.js failed to load after maximum retries');
                    // Show error message to user
                    const chartContainers = document.querySelectorAll('[id*="chart"], [id*="Chart"]');
                    chartContainers.forEach(container => {
                        const message = container.querySelector('.chart-message') || document.createElement('div');
                        message.className = 'chart-message text-center text-red-500 p-4';
                        message.textContent = 'Charts failed to load. Please refresh the page.';
                        container.appendChild(message);
                    });
                }
            };
            
            // Start trying to initialize charts
            tryInitializeCharts();
        };
        
        // Initialize charts when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeCharts);
        } else {
            initializeCharts();
        }

        // --- SUPABASE CONTROLS ---
        // Using the main supabase client from line 3111

        // Connection status tracking
        let supabaseConnectionStatus = 'unknown';
        let lastSyncTime = null;
        
        // Operation queuing to prevent race conditions
        const operationQueue = new Map();
        const pendingOperations = new Set();
        
        // Helper function to show connection status
        const updateConnectionStatus = (status, message = '') => {
            supabaseConnectionStatus = status;
            const statusIndicator = document.getElementById('connection-status');
            if (statusIndicator) {
                statusIndicator.className = `connection-status ${status}`;
                statusIndicator.textContent = message || (status === 'connected' ? 'Synced' : status === 'disconnected' ? 'Offline' : 'Syncing...');
            }
        };
        
        // Helper function to show sync notifications
        const showSyncNotification = (message, type = 'info') => {
            console.log(`[SYNC] ${message}`);
            // You can add toast notifications here if you have a toast system
            if (window.window.utils.showToast) {
                window.utils.showToast(message, type);
            }
        };
        
        // Helper function to add timeout to Supabase operations
        const withTimeout = (promise, timeoutMs = 10000, operation = 'operation') => {
            return Promise.race([
                promise,
                new Promise((_, reject) => {
                    setTimeout(() => {
                        reject(new Error(`${operation} timed out after ${timeoutMs}ms`));
                    }, timeoutMs);
                })
            ]);
        };
        
        // Helper function to retry operations with exponential backoff
        const retryOperation = async (operationFn, maxRetries = 3, baseDelay = 1000) => {
            let lastError;
            
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    return await operationFn();
                } catch (error) {
                    lastError = error;
                    
                    // Don't retry on timeout or authentication errors
                    if (error.message.includes('timed out') || 
                        error.message.includes('auth') || 
                        error.message.includes('permission')) {
                        throw error;
                    }
                    
                    // Don't retry on the last attempt
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    
                    // Calculate delay with exponential backoff
                    const delay = baseDelay * Math.pow(2, attempt);
                    console.log(`Operation failed, retrying in ${delay}ms (attempt ${attempt + 1}/${maxRetries + 1})`);
                    
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            
            throw lastError;
        };
        
        // Helper function to queue operations and prevent race conditions
        const queueOperation = async (operationKey, operationFn) => {
            // If operation is already pending, wait for it to complete
            if (pendingOperations.has(operationKey)) {
                return new Promise((resolve, reject) => {
                    const queue = operationQueue.get(operationKey) || [];
                    queue.push({ resolve, reject });
                    operationQueue.set(operationKey, queue);
                });
            }
            
            // Mark operation as pending
            pendingOperations.add(operationKey);
            
            try {
                const result = await retryOperation(operationFn);
                
                // Resolve all queued operations with the same result
                const queue = operationQueue.get(operationKey) || [];
                queue.forEach(({ resolve }) => resolve(result));
                operationQueue.delete(operationKey);
                
                return result;
            } catch (error) {
                // Reject all queued operations with the same error
                const queue = operationQueue.get(operationKey) || [];
                queue.forEach(({ reject: queueReject }) => queueReject(error));
                operationQueue.delete(operationKey);
                
                throw error;
            } finally {
                // Remove from pending operations
                pendingOperations.delete(operationKey);
            }
        };

        // --- Trade sync helpers ---
        // Note: mergeTradesById function removed - now using only Supabase data

        // Note: syncLocalOnlyTradesToRemote function removed - now using only Supabase data

        // Clean localStorage function to remove unwanted data
        const cleanLocalStorage = () => {
            // Keep only essential UI preferences
            const theme = localStorage.getItem('theme');
            const currentPage = localStorage.getItem('currentPage');
            
            // Clear all data storage
            localStorage.removeItem('trades');
            localStorage.removeItem('ledger');
            
            // Clear partial exits
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('partial_exits_')) {
                    localStorage.removeItem(key);
                }
            });
            
            // Restore only UI preferences
            if (theme) localStorage.setItem('theme', theme);
            if (currentPage) localStorage.setItem('currentPage', currentPage);
            
            console.log('localStorage cleaned - removed all data, kept UI preferences');
        };

        const dataStore = {
            async getTrades() {
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        if (supabase) {
                            const supabasePromise = supabase.from('trades').select('*').order('entry_date', { ascending: true });
                            const { data, error } = await withTimeout(supabasePromise, 10000, 'Fetch trades');
                            
                            if (!error) {
                                updateConnectionStatus('connected');
                                lastSyncTime = new Date();
                                const remote = data || [];
                                
                                // Use only Supabase data - no localStorage sync
                                
                                return remote; // Return only Supabase data
                            } else {
                                console.warn(`Supabase getTrades error (attempt ${retryCount + 1}):`, error);
                                if (retryCount < maxRetries - 1) {
                                    console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                                    await new Promise(resolve => setTimeout(resolve, 2000));
                                    retryCount++;
                                    continue;
                                } else {
                                    showSyncNotification('Unable to load trades - please check your connection', 'error');
                                    updateConnectionStatus('disconnected');
                                }
                            }
                        }
                    } catch (error) {
                        if (retryCount < maxRetries - 1) {
                            if (error.message && error.message.includes('timed out')) {
                                console.warn(`Supabase getTrades timeout (attempt ${retryCount + 1}):`, error);
                            } else {
                                console.warn(`Supabase connection failed (attempt ${retryCount + 1}):`, error);
                            }
                            console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            retryCount++;
                            continue;
                        } else {
                            if (error.message && error.message.includes('timed out')) {
                                console.warn('Supabase getTrades timeout after all retries:', error);
                                showSyncNotification('Connection timeout - please try again', 'error');
                            } else {
                                console.warn('Supabase connection failed after all retries:', error);
                                showSyncNotification('Connection issue - please try again', 'error');
                            }
                            updateConnectionStatus('disconnected');
                        }
                    }
                }
                
                // Return empty array if all retries failed
                return [];
            },
            async upsertTrade(trade) {
                const operationKey = `upsert-trade-${trade.id}`;
                
                return queueOperation(operationKey, async () => {
                    let retryCount = 0;
                    const maxRetries = 3;
                    
                    while (retryCount < maxRetries) {
                        try {
                            if (supabase) {
                                // Sanitize payload for Supabase: omit fields not present in DB schema
                                const tradeForDb = { ...trade };
                                delete tradeForDb.status; // UI-derived; not a DB column
                                const supabasePromise = supabase.from('trades').upsert(tradeForDb);
                                const { error } = await withTimeout(supabasePromise, 10000, 'Save trade');
                                
                                if (!error) {
                                    updateConnectionStatus('connected');
                                    lastSyncTime = new Date();
                                    showSyncNotification('Trade saved successfully', 'success');
                                    return true;
                                } else {
                                    console.warn(`Supabase upsert error (attempt ${retryCount + 1}):`, error);
                                    if (retryCount < maxRetries - 1) {
                                        console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                                        await new Promise(resolve => setTimeout(resolve, 2000));
                                        retryCount++;
                                        continue;
                                    } else {
                                        showSyncNotification('Failed to save trade - please try again', 'error');
                                        updateConnectionStatus('disconnected');
                                        throw new Error(`Database error: ${error.message}`);
                                    }
                                }
                            }
                        } catch (error) {
                            if (retryCount < maxRetries - 1) {
                                if (error.message.includes('timed out')) {
                                    console.warn(`Supabase upsert timeout (attempt ${retryCount + 1}):`, error);
                                } else {
                                    console.warn(`Supabase connection failed (attempt ${retryCount + 1}):`, error);
                                }
                                console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                retryCount++;
                                continue;
                            } else {
                                if (error.message.includes('timed out')) {
                                    console.warn('Supabase upsert timeout after all retries:', error);
                                    showSyncNotification('Connection timeout - please try again', 'error');
                                } else {
                                    console.warn('Supabase connection failed after all retries:', error);
                                    showSyncNotification('Connection issue - please try again', 'error');
                                }
                                updateConnectionStatus('disconnected');
                                throw error;
                            }
                        }
                    }
                });
            },
            async deleteTrade(id) {
                const operationKey = `delete-trade-${id}`;
                
                return queueOperation(operationKey, async () => {
                    try {
                        if (supabase) {
                            const supabasePromise = supabase.from('trades').delete().eq('id', id);
                            const { error } = await withTimeout(supabasePromise, 10000, 'Delete trade');
                            
                            if (!error) {
                                updateConnectionStatus('connected');
                                lastSyncTime = new Date();
                                showSyncNotification('Trade deleted successfully', 'success');
                            } else {
                                console.warn('Supabase delete error:', error);
                                showSyncNotification('Failed to delete trade - please try again', 'error');
                                updateConnectionStatus('disconnected');
                                throw new Error(`Database error: ${error.message}`);
                            }
                        }
                    } catch (error) {
                        if (error.message.includes('timed out')) {
                            console.warn('Supabase delete timeout:', error);
                            showSyncNotification('Connection timeout - please try again', 'error');
                        } else {
                            console.warn('Supabase connection failed:', error);
                            showSyncNotification('Connection issue - please try again', 'error');
                        }
                        updateConnectionStatus('disconnected');
                        throw error;
                    }
                });
            },
            async deleteMultipleTrades(ids) {
                if (!ids || ids.length === 0) {
                    throw new Error('No trade IDs provided for deletion');
                }

                try {
                    if (supabase) {
                        const { error } = await supabase.from('trades').delete().in('id', ids);
                        if (error) {
                            console.error('Supabase bulk delete error:', error);
                            throw new Error(`Database error: ${error.message}`);
                        }
                        return true;
                    } else {
                        throw new Error('No database connection available');
                    }
                } catch (error) {
                    console.error('deleteMultipleTrades failed:', error);
                    throw error;
                }
            },
            async deleteAllTrades() {
                try {
                    if (supabase) {
                        const { error } = await supabase.from('trades').delete().neq('id', '');
                        if (error) {
                            console.error('Supabase delete all error:', error);
                            throw new Error(`Database error: ${error.message}`);
                        }
                        return true;
                    } else {
                        throw new Error('No database connection available');
                    }
                } catch (error) {
                    console.error('deleteAllTrades failed:', error);
                    throw error;
                }
            },
            async getLedger() {
                let retryCount = 0;
                const maxRetries = 3;
                
                while (retryCount < maxRetries) {
                    try {
                        if (supabase) {
                            const supabasePromise = supabase.from('ledger').select('*').order('date', { ascending: true });
                            const { data, error } = await withTimeout(supabasePromise, 10000, 'Fetch ledger');
                            
                            if (!error) {
                                updateConnectionStatus('connected');
                                lastSyncTime = new Date();
                                const remote = data || [];
                                
                                // Use only Supabase data - no localStorage sync
                                
                                return remote; // Return only Supabase data
                            } else {
                                console.warn(`Supabase getLedger error (attempt ${retryCount + 1}):`, error);
                                if (retryCount < maxRetries - 1) {
                                    console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                                    await new Promise(resolve => setTimeout(resolve, 2000));
                                    retryCount++;
                                    continue;
                                } else {
                                    showSyncNotification('Unable to load ledger - please check your connection', 'error');
                                    updateConnectionStatus('disconnected');
                                }
                            }
                        }
                    } catch (error) {
                        if (retryCount < maxRetries - 1) {
                            if (error.message.includes('timed out')) {
                                console.warn(`Supabase getLedger timeout (attempt ${retryCount + 1}):`, error);
                            } else {
                                console.warn(`Supabase connection failed (attempt ${retryCount + 1}):`, error);
                            }
                            console.log(`Retrying in 2 seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            retryCount++;
                            continue;
                        } else {
                            if (error.message.includes('timed out')) {
                                console.warn('Supabase getLedger timeout after all retries:', error);
                                showSyncNotification('Connection timeout - please try again', 'error');
                            } else {
                                console.warn('Supabase connection failed after all retries:', error);
                                showSyncNotification('Connection issue - please try again', 'error');
                            }
                            updateConnectionStatus('disconnected');
                        }
                    }
                }
                
                // Return empty array if all retries failed
                return [];
            },
            async upsertLedger(entry) {
                const operationKey = `upsert-ledger-${entry.id}`;
                
                return queueOperation(operationKey, async () => {
                    try {
                        if (supabase) {
                            const supabasePromise = supabase.from('ledger').upsert(entry);
                            const { error } = await withTimeout(supabasePromise, 10000, 'Save ledger entry');
                            
                            if (!error) {
                                updateConnectionStatus('connected');
                                lastSyncTime = new Date();
                                showSyncNotification('Ledger entry saved successfully', 'success');
                                return true;
                            } else {
                                console.warn('Supabase ledger upsert error:', error);
                                showSyncNotification('Failed to save ledger entry - please try again', 'error');
                                updateConnectionStatus('disconnected');
                                throw new Error(`Database error: ${error.message}`);
                            }
                        }
                    } catch (error) {
                        if (error.message.includes('timed out')) {
                            console.warn('Supabase ledger upsert timeout:', error);
                            showSyncNotification('Connection timeout - please try again', 'error');
                        } else {
                            console.warn('Supabase connection failed:', error);
                            showSyncNotification('Connection issue - please try again', 'error');
                        }
                        updateConnectionStatus('disconnected');
                        throw error;
                    }
                });
            },
            async deleteLedger(id) {
                try {
                    if (supabase) {
                        const { error } = await supabase.from('ledger').delete().eq('id', id);
                        if (error) {
                            console.error('Supabase ledger delete error:', error);
                            throw new Error(`Database error: ${error.message}`);
                        }
                        return true;
                    } else {
                        throw new Error('No database connection available');
                    }
                } catch (error) {
                    console.error('deleteLedger failed:', error);
                    throw error;
                }
            },
            async upsertChallenge(challenge) {
                const operationKey = `upsert-challenge-${challenge.id}`;
                
                return queueOperation(operationKey, async () => {
                    try {
                        if (supabase) {
                            // Add user_id to challenge and exclude completed field (not in DB schema)
                            const challengeForDb = {
                                id: challenge.id,
                                title: challenge.title,
                                description: challenge.description,
                                timeframe: challenge.timeframe,
                                maxRisk: challenge.maxRisk,
                                startDate: challenge.startDate,
                                endDate: challenge.endDate,
                                createdAt: challenge.createdAt,
                                success: challenge.success,
                                startingCapital: challenge.startingCapital,
                                targetCapital: challenge.targetCapital,
                                user_id: appState.user?.id || 'anonymous',
                                status: challenge.completed ? 'completed' : 'active'
                            };
                            
                            const supabasePromise = supabase.from('challenges').upsert(challengeForDb);
                            const { error } = await withTimeout(supabasePromise, 10000, 'Save challenge');
                            
                            if (!error) {
                                updateConnectionStatus('connected');
                                lastSyncTime = new Date();
                                showSyncNotification('Challenge saved successfully', 'success');
                                return true;
                            } else {
                                console.warn('Supabase challenge upsert error:', error);
                                showSyncNotification('Failed to save challenge - please try again', 'error');
                                updateConnectionStatus('disconnected');
                                throw new Error(`Database error: ${error.message}`);
                            }
                        } else {
                            throw new Error('No database connection available');
                        }
                    } catch (error) {
                        if (error.message.includes('timed out')) {
                            console.warn('Supabase challenge upsert timeout:', error);
                            showSyncNotification('Connection timeout - please try again', 'error');
                        } else {
                            console.warn('Supabase connection failed:', error);
                            showSyncNotification('Connection issue - please try again', 'error');
                        }
                        updateConnectionStatus('disconnected');
                        throw error;
                    }
                });
            },
            async getChallenges() {
                try {
                    if (supabase) {
                        const { data, error } = await withTimeout(
                            supabase.from('challenges').select('*').eq('user_id', appState.user?.id).order('createdAt', { ascending: false }),
                            10000, 'Fetch challenges'
                        );
                        
                        if (!error) {
                            updateConnectionStatus('connected');
                            lastSyncTime = new Date();
                            return data || [];
                        } else {
                            console.warn('Supabase getChallenges error:', error);
                            showSyncNotification('Unable to load challenges - please check your connection', 'error');
                            updateConnectionStatus('disconnected');
                        }
                    }
                } catch (error) {
                    if (error.message.includes('timed out')) {
                        console.warn('Supabase getChallenges timeout:', error);
                        showSyncNotification('Connection timeout - please try again', 'error');
                    } else {
                        console.warn('Supabase connection failed:', error);
                        showSyncNotification('Connection issue - please try again', 'error');
                    }
                    updateConnectionStatus('disconnected');
                }
                
                return [];
            },
            async getPartialExits(tradeId) {
                try {
                    if (supabase && appState.user?.id) {
                        const { data, error } = await withTimeout(
                            supabase.from('partial_exits').select('*').eq('trade_id', tradeId).eq('user_id', appState.user.id).order('exit_date', { ascending: true }),
                            5000, 'Fetch partial exits'
                        );
                        
                        if (!error) {
                            return data || [];
                        } else {
                            console.warn('Supabase getPartialExits error:', error);
                        }
                    }
                } catch (error) {
                    console.warn('Supabase getPartialExits failed:', error);
                }
                
                return [];
            },
            async savePartialExit(partialExit) {
                try {
                    if (supabase && appState.user?.id) {
                        const partialExitData = {
                            ...partialExit,
                            user_id: appState.user.id
                        };
                        
                        const { data, error } = await withTimeout(
                            supabase.from('partial_exits').insert([partialExitData]).select(),
                            5000, 'Save partial exit'
                        );
                        
                        if (!error) {
                            return data[0];
                        } else {
                            console.warn('Supabase savePartialExit error:', error);
                            throw error;
                        }
                    }
                } catch (error) {
                    console.warn('Supabase savePartialExit failed:', error);
                    throw error;
                }
            },
            async deletePartialExit(partialExitId) {
                try {
                    if (supabase && appState.user?.id) {
                        const { error } = await withTimeout(
                            supabase.from('partial_exits').delete().eq('id', partialExitId).eq('user_id', appState.user.id),
                            5000, 'Delete partial exit'
                        );
                        
                        if (!error) {
                            return true;
                        } else {
                            console.warn('Supabase deletePartialExit error:', error);
                            throw error;
                        }
                    }
                } catch (error) {
                    console.warn('Supabase deletePartialExit failed:', error);
                    throw error;
                }
            },
            async deleteChallenge(challengeId) {
                try {
                    if (supabase && appState.user?.id) {
                        const { error } = await withTimeout(
                            supabase.from('challenges').delete().eq('id', challengeId).eq('user_id', appState.user.id),
                            5000, 'Delete challenge'
                        );
                        
                        if (!error) {
                            return true;
                        } else {
                            console.warn('Supabase deleteChallenge error:', error);
                            throw error;
                        }
                    }
                } catch (error) {
                    console.warn('Supabase deleteChallenge failed:', error);
                    throw error;
                }
            }
        };
        
        // Load user data only (without rendering all pages)
        const loadUserDataOnly = async () => {
            try {
                // Clean localStorage to remove any unwanted data
                cleanLocalStorage();
                
                appState.trades = await dataStore.getTrades();
                appState.ledger = await dataStore.getLedger();
                
                // Load ALL challenges from Supabase
                if (supabase && appState.user?.id) {
                    try {
                        const allChallenges = await dataStore.getChallenges();
                        
                        // Find the currently active challenge
                        const activeChallenge = allChallenges.find(c => c.status === 'active');
                        
                        if (activeChallenge) {
                            appState.challenge = activeChallenge;
                            console.log('Active challenge loaded from Supabase:', activeChallenge);
                        } else {
                            appState.challenge = null; // Ensure it's null if no active one is found
                        }

                        // The rest are history - map Supabase data to app format
                        appState.challengeHistory = allChallenges
                            .filter(c => c.status !== 'active')
                            .map(challenge => ({
                                ...challenge,
                                completed: challenge.status === 'completed',
                                success: challenge.success || false
                            }));
                        console.log(`Loaded ${appState.challengeHistory.length} challenges into history.`);

                    } catch (error) {
                        console.error('Error loading challenges from Supabase:', error);
                        appState.challenge = null;
                        appState.challengeHistory = [];
                    }
                }
                
                console.log('User data loaded successfully');
            } catch (error) {
                console.error('Error loading user data:', error);
            }
        };

        // Load initial data and render all pages immediately after dataStore is ready
        const loadInitialData = async () => {
            try {
                // Clean localStorage to remove any unwanted data
                cleanLocalStorage();
                
                appState.trades = await dataStore.getTrades();
                appState.ledger = await dataStore.getLedger();
                
                // Load ALL challenges from Supabase
                if (supabase && appState.user?.id) {
                    try {
                        const allChallenges = await dataStore.getChallenges();
                        
                        // Find the currently active challenge
                        const activeChallenge = allChallenges.find(c => c.status === 'active');
                        
                        if (activeChallenge) {
                            appState.challenge = activeChallenge;
                            console.log('Active challenge loaded from Supabase:', activeChallenge);
                        } else {
                            appState.challenge = null; // Ensure it's null if no active one is found
                        }

                        // The rest are history - map Supabase data to app format
                        appState.challengeHistory = allChallenges
                            .filter(c => c.status !== 'active')
                            .map(challenge => ({
                                ...challenge,
                                completed: challenge.status === 'completed',
                                success: challenge.success || false
                            }));
                        console.log(`Loaded ${appState.challengeHistory.length} challenges into history.`);

                    } catch (error) {
                        console.error('Error loading challenges from Supabase:', error);
                        appState.challenge = null;
                        appState.challengeHistory = [];
                    }
                }
                
                // Pre-render all data-dependent pages for instant navigation (without auto-navigating)
                window.main.loadDashboardData().then(data => {
                  window.ui.renderDashboardUI(data);
                }).catch(err => {
                  console.error('loadDashboardData error', err);
                });
                renderTradeHistory();
                renderStatement();
                renderReports();
                renderCalendar();
                renderFundManagement();
                renderChallenge();
                renderChallengeHistory();
                
                // Render charts after data is loaded
                if (typeof renderAllCharts === 'function') {
                    renderAllCharts(true); // Force immediate render
                }
                
                console.log('Initial data loaded and all pages rendered');
            } catch (error) {
                console.error('Error loading initial data:', error);
            }
        };
        
        // Load data immediately
        loadInitialData();
        
        // --- SCROLL TO TOP FUNCTIONALITY ---
        const scrollToTopBtn = document.getElementById('scroll-to-top-btn');
        
        // Show/hide button based on scroll position
        const toggleScrollToTopButton = () => {
            if (!scrollToTopBtn || !mainContent) return;
            
            // Show button when scrolled down more than 300px
            if (mainContent.scrollTop > 300) {
                scrollToTopBtn.classList.remove('hidden');
            } else {
                scrollToTopBtn.classList.add('hidden');
            }
        };
        
        // Add scroll event listener to main content
        if (mainContent) {
            mainContent.addEventListener('scroll', toggleScrollToTopButton);
        }
        
        // Add click event listener to scroll to top
        if (scrollToTopBtn) {
            scrollToTopBtn.addEventListener('click', function() {
                if (mainContent) {
                    mainContent.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });
                }
            });
        }
        
        // Clear Challenge History Button
        document.getElementById('clear-challenge-history')?.addEventListener('click', (e) => {
            e.preventDefault();
            showConfirmationModal(
                'Clear Challenge History?',
                () => {
                    clearChallengeHistory();
                },
                'Clear History',
                'Clear'
            );
        });

        // Trade Statement Filter Event Listeners
        document.getElementById('apply-filter-btn')?.addEventListener('click', () => {
            // Get filter values from form elements
            const transactionType = document.getElementById('filter-type')?.value || 'All Types';
            const strategy = document.getElementById('filter-strategy')?.value || 'All Strategies';
            const startDate = document.getElementById('filter-start-date')?.value || '';
            const endDate = document.getElementById('filter-end-date')?.value || '';
            const status = document.getElementById('filter-status')?.value || '';
            const winloss = document.getElementById('filter-winloss')?.value || '';
            const segment = document.getElementById('filter-segment')?.value || '';
            const direction = document.getElementById('filter-direction')?.value || '';
            
            // Apply filters to statement
            const filters = {
                transactionType: transactionType !== 'All Types' ? transactionType : null,
                strategy: strategy !== 'All Strategies' ? strategy : null,
                startDate: startDate || null,
                endDate: endDate || null,
                status: status || null,
                winloss: winloss || null,
                segment: segment || null,
                direction: direction || null
            };
            
            renderStatement(filters);
        });
        
        document.getElementById('reset-filter-btn')?.addEventListener('click', () => {
            // Reset all filter form elements to default values
            const filterType = document.getElementById('filter-type');
            const filterStrategy = document.getElementById('filter-strategy');
            const filterStartDate = document.getElementById('filter-start-date');
            const filterEndDate = document.getElementById('filter-end-date');
            const filterStatus = document.getElementById('filter-status');
            const filterWinloss = document.getElementById('filter-winloss');
            const filterSegment = document.getElementById('filter-segment');
            const filterDirection = document.getElementById('filter-direction');
            
            if (filterType) filterType.value = 'All Types';
            if (filterStrategy) filterStrategy.value = ''; // Empty string matches the option value
            if (filterStartDate) filterStartDate.value = '';
            if (filterEndDate) filterEndDate.value = '';
            if (filterStatus) filterStatus.value = '';
            if (filterWinloss) filterWinloss.value = '';
            if (filterSegment) filterSegment.value = '';
            if (filterDirection) filterDirection.value = '';
            
            // Render statement without filters (show all data)
            renderStatement();
        });

        // Export CSV functionality
        document.getElementById('export-csv-btn')?.addEventListener('click', () => {
            exportStatementToCSV();
        });

        // Trade History Filter Event Listeners
        document.getElementById('trade-history-apply-filter-btn')?.addEventListener('click', () => {
            const status = document.getElementById('trade-history-filter-status')?.value || '';
            const startDate = document.getElementById('trade-history-filter-start-date')?.value || '';
            const endDate = document.getElementById('trade-history-filter-end-date')?.value || '';
            const symbol = document.getElementById('trade-history-filter-symbol')?.value || '';
            
            const filters = {
                status: status || null,
                startDate: startDate || null,
                endDate: endDate || null,
                symbol: symbol || null
            };
            
            renderTradeHistory(false, filters);
        });

        document.getElementById('trade-history-reset-filter-btn')?.addEventListener('click', () => {
            document.getElementById('trade-history-filter-status').value = '';
            document.getElementById('trade-history-filter-start-date').value = '';
            document.getElementById('trade-history-filter-end-date').value = '';
            document.getElementById('trade-history-filter-symbol').value = '';
            
            renderTradeHistory(false, {});
        });

        const exportStatementToCSV = () => {
            try {
                console.log('Exporting statement to CSV...');
                
                // Get current data
                const trades = appState.trades || [];
                const ledger = appState.ledger || [];
                
                // Create CSV headers to match the table exactly
                const headers = [
                    'Date',
                    'Symbol/Desc',
                    'Direction',
                    'Segment',
                    'Amount (₹)',
                    'Gross P/L',
                    'Charges',
                    'Net P/L',
                    'Net P/L %',
                    'Win/Loss',
                    'Status',
                    'Entry Price',
                    'Entry Qty',
                    'Entry Date',
                    'Stop Loss',
                    'Target Price',
                    'Exit Price',
                    'Exit Qty',
                    'Exit Date',
                    'Strategy',
                    'Outcome Summary',
                    'Emotional State',
                    'Notes'
                ];
                
                // Combine trades and ledger data
                const allRows = [];
                
                // Add trades data
                trades.forEach(t => {
                    const isClosed = t.exit_date && t.exit_price && (!t.exit_quantity || t.exit_quantity >= t.quantity);
                    const isPartialExit = t.exit_date && t.exit_price && t.exit_quantity && t.exit_quantity < t.quantity;
                    const pnl = (isClosed || isPartialExit) ? calculateNetPnl(t) : 0;
                    const netProfitPercentage = (isClosed || isPartialExit) && t.entry_price ? ((pnl / (t.entry_price * (t.quantity || 0))) * 100) : 0;
                    const netPnl = pnl - (t.charges || 0);
                    const winLoss = netPnl > 0 ? 'Win' : (netPnl < 0 ? 'Loss' : '—');
                    
                    allRows.push({
                        date: window.utils.formatDateForDisplay(t.entry_date) || '—',
                        symbol: t.asset || '—',
                        direction: t.direction || '—',
                        segment: t.segment || '—',
                        amount: '—',
                        gross: pnl.toFixed(2),
                        charges: (t.charges || 0).toFixed(2),
                        net: netPnl.toFixed(2),
                        netPercentage: netProfitPercentage.toFixed(2),
                        winLoss: winLoss,
                        status: isClosed ? 'Closed' : (isPartialExit ? 'Partial Exit' : 'Open'),
                        entryPrice: t.entry_price ? parseFloat(t.entry_price).toFixed(2) : '—',
                        entryQty: t.quantity || '—',
                        entryDate: window.utils.formatDateForDisplay(t.entry_date) || '—',
                        stopLoss: t.stop_loss ? parseFloat(t.stop_loss).toFixed(2) : '—',
                        targetPrice: (t.target_price || t.target) ? parseFloat(t.target_price || t.target).toFixed(2) : '—',
                        exitPrice: t.exit_price ? parseFloat(t.exit_price).toFixed(2) : '—',
                        exitQty: t.exit_quantity || '—',
                        exitDate: window.utils.formatDateForDisplay(t.exit_date) || '—',
                        strategy: t.strategy || '—',
                        outcomeSummary: t.outcomeSummary || '—',
                        emotionalState: t.emotionalState || '—',
                        notes: t.reasons || '—'
                    });
                });
                
                // Add ledger data (deposits and withdrawals)
                ledger.forEach(l => {
                    allRows.push({
                        date: window.utils.formatDateForDisplay(l.date) || '—',
                        symbol: l.notes || l.type || '—',
                        direction: l.type === 'Deposit' ? 'Credit' : 'Debit',
                        segment: '—',
                        amount: parseFloat(l.amount || 0).toFixed(2),
                        gross: '—',
                        charges: '—',
                        net: parseFloat(l.amount || 0).toFixed(2),
                        netPercentage: '—',
                        winLoss: '—',
                        status: 'Completed',
                        entryPrice: '—',
                        entryQty: '—',
                        entryDate: window.utils.formatDateForDisplay(l.date) || '—',
                        stopLoss: '—',
                        targetPrice: '—',
                        exitPrice: '—',
                        exitQty: '—',
                        exitDate: '—',
                        strategy: '—',
                        outcomeSummary: '—',
                        emotionalState: '—',
                        notes: l.notes || '—'
                    });
                });
                
                // Sort by date (newest first)
                allRows.sort((a, b) => new Date(b.date) - new Date(a.date));
                
                // Create CSV content
                let csvContent = headers.join(',') + '\n';
                
                allRows.forEach(row => {
                    const csvRow = [
                        `"${row.date}"`,
                        `"${row.symbol}"`,
                        `"${row.direction}"`,
                        `"${row.segment}"`,
                        `"${row.amount}"`,
                        `"${row.gross}"`,
                        `"${row.charges}"`,
                        `"${row.net}"`,
                        `"${row.netPercentage}"`,
                        `"${row.winLoss}"`,
                        `"${row.status}"`,
                        `"${row.entryPrice}"`,
                        `"${row.entryQty}"`,
                        `"${row.entryDate}"`,
                        `"${row.stopLoss}"`,
                        `"${row.targetPrice}"`,
                        `"${row.exitPrice}"`,
                        `"${row.exitQty}"`,
                        `"${row.exitDate}"`,
                        `"${row.strategy}"`,
                        `"${row.outcomeSummary}"`,
                        `"${row.emotionalState}"`,
                        `"${row.notes}"`
                    ];
                    csvContent += csvRow.join(',') + '\n';
                });
                
                // Create and download file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                
                if (link.download !== undefined) {
                    const url = URL.createObjectURL(blob);
                    link.setAttribute('href', url);
                    link.setAttribute('download', `trade_statement_${new Date().toISOString().split('T')[0]}.csv`);
                    link.style.visibility = 'hidden';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                }
                
                console.log('CSV export completed successfully');
                
            } catch (error) {
                console.error('Error exporting CSV:', error);
                alert('Error exporting CSV. Please try again.');
            }
        };
        

        // --- CHALLENGE MODAL LOGIC ---
        const challengeModal = document.getElementById('challenge-modal');
        const challengeForm = document.getElementById('challenge-form');
        const setChallengeBtn = document.getElementById('set-challenge-btn');
        const setChallengeBtnInactive = document.getElementById('set-challenge-btn-inactive');

        const openChallengeModal = () => {
            challengeForm.reset();
            challengeModal.classList.remove('hidden');
        };

        const closeChallengeModal = () => {
            challengeModal.classList.add('hidden');
        };

        // Wire challenge buttons
        setChallengeBtn?.addEventListener('click', openChallengeModal);
        setChallengeBtnInactive?.addEventListener('click', openChallengeModal);
        document.querySelectorAll('#challenge-modal .close-modal-btn').forEach(btn => 
            btn.addEventListener('click', closeChallengeModal));

        // Handle challenge form submission
        challengeForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const startingCapital = parseFloat(document.getElementById('starting-capital').value) || 0;
            const targetCapital = parseFloat(document.getElementById('target-capital').value) || 0;
            const timeframe = parseInt(document.getElementById('timeframe').value) || 30;
            const maxRisk = parseFloat(document.getElementById('max-risk').value) || 2;

            // Check for existing active challenge from the app's state
            const existingChallenge = appState.challenge;
            if (existingChallenge && !existingChallenge.completed) {
                window.utils.showToast('Please complete your current challenge before starting a new one!', 'error');
                return;
            }

            // Validate target capital must be greater than starting capital
            if (targetCapital <= startingCapital) {
                window.utils.showToast('Target capital must be greater than starting capital!', 'error');
                return;
            }

            const startDate = new Date();
            const endDate = addWeekdays(startDate, timeframe);

            // Allow overlapping time periods - focus on trade isolation instead
            // Each challenge will be isolated by creation timestamp, not time period

            const challenge = {
                id: window.utils.generateUUID(),
                startingCapital,
                targetCapital,
                timeframe,
                maxRisk,
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString(),
                createdAt: new Date().toISOString(), // Add creation timestamp
                completed: false,
                success: false
            };

            try {
                // Update appState immediately
                appState.challenge = challenge;
                
                // Sync to Supabase for cross-device persistence
                await dataStore.upsertChallenge(challenge);
                
                // Don't add to history until completed - only save as active challenge

                closeChallengeModal();
                renderChallenge();
                renderChallengeHistory();
                renderChallengeStats();
                window.utils.showToast('Challenge set successfully!', 'success');
            } catch (err) {
                console.error('Failed to save challenge', err);
                window.utils.showToast('Failed to save challenge. Please try again.', 'error');
            }
        });

        // Initialize info tooltips functionality
        const initializeInfoTooltips = () => {
            const tooltipTriggers = document.querySelectorAll('.info-tooltip-trigger');
            
            tooltipTriggers.forEach(trigger => {
                const tooltip = trigger.nextElementSibling;
                
                // Smart positioning function
                const adjustTooltipPosition = () => {
                    if (!tooltip.classList.contains('show')) return;
                    
                    const tooltipRect = tooltip.getBoundingClientRect();
                    const triggerRect = trigger.getBoundingClientRect();
                    const viewportHeight = window.innerHeight;
                    const tooltipHeight = tooltipRect.height;
                    const spaceAbove = triggerRect.top;
                    const spaceBelow = viewportHeight - triggerRect.bottom;
                    
                    // Reset positioning
                    tooltip.style.top = '';
                    tooltip.style.bottom = '';
                    
                    // Check if there's enough space above
                    if (spaceAbove >= tooltipHeight + 20) {
                        // Position above (default)
                        tooltip.style.top = '-105px';
                        tooltip.style.bottom = 'auto';
                    } else if (spaceBelow >= tooltipHeight + 20) {
                        // Position below
                        tooltip.style.top = 'auto';
                        tooltip.style.bottom = '-105px';
                    } else {
                        // If neither space is enough, choose the side with more space
                        if (spaceAbove > spaceBelow) {
                            tooltip.style.top = '-105px';
                            tooltip.style.bottom = 'auto';
                        } else {
                            tooltip.style.top = 'auto';
                            tooltip.style.bottom = '-105px';
                        }
                    }
                };
                
                // Click to show/hide tooltip
                trigger.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Hide all other tooltips
                    document.querySelectorAll('.info-tooltip').forEach(t => {
                        if (t !== tooltip) {
                            t.classList.remove('show');
                        }
                    });
                    
                    // Toggle current tooltip
                    tooltip.classList.toggle('show');
                    
                    // Adjust position after showing
                    if (tooltip.classList.contains('show')) {
                        setTimeout(adjustTooltipPosition, 10);
                    }
                });
                
                // Hover to show tooltip with smart positioning
                trigger.addEventListener('mouseenter', () => {
                    tooltip.classList.add('show');
                    setTimeout(adjustTooltipPosition, 10);
                });
                
                trigger.addEventListener('mouseleave', () => {
                    tooltip.classList.remove('show');
                });
                
                // Hide tooltip when clicking outside
                document.addEventListener('click', (e) => {
                    if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
                        tooltip.classList.remove('show');
                    }
                });
                
                // Hide tooltip on escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        tooltip.classList.remove('show');
                    }
                });
                
                // Adjust position on scroll and resize
                window.addEventListener('scroll', adjustTooltipPosition);
                window.addEventListener('resize', adjustTooltipPosition);
            });
        };

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, setting up button groups...');
            setupButtonGroups();
            
            // Initialize info tooltips
            initializeInfoTooltips();
            
            // Initialize default button states
            setTimeout(() => {
                document.querySelector('#direction-group button[data-value="Long"]')?.classList.add('active', 'active-long');
                document.querySelector('#segment-group button[data-value="Equity"]')?.classList.add('active', 'active-green');
                document.querySelector('#trading-style-group button[data-value="Intraday"]')?.classList.add('active', 'active-green');
                console.log('Default button states initialized');
            }, 200);

            // Edit Trade Modal Event Listeners
            const editModal = document.getElementById('edit-trade-modal');
            const editCloseBtn = document.getElementById('edit-trade-close-btn');
            const editCancelBtn = document.getElementById('edit-trade-cancel-btn');
            const editSubmitBtn = document.getElementById('edit-trade-submit-btn');
            const editTradeTab = document.getElementById('edit-trade-tab');
            const editExitTab = document.getElementById('edit-exit-tab');
            const editForm = document.getElementById('edit-trade-form');

            // Close modal events
            editCloseBtn?.addEventListener('click', () => {
                resetEditModalButtonState();
                hideEditTradeModal();
            });
            editCancelBtn?.addEventListener('click', () => {
                resetEditModalButtonState();
                hideEditTradeModal();
            });

            // Tab switching events
            editTradeTab?.addEventListener('click', () => switchEditModalTab('trade'));
            editExitTab?.addEventListener('click', () => switchEditModalTab('exit'));

            // Add observer to monitor modal visibility changes
            const modal = document.getElementById('edit-trade-modal');
            if (modal) {
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            const isHidden = modal.classList.contains('hidden');
                            if (!isHidden) {
                                // Modal is being shown, reset button state
                                console.log('Modal shown - resetting button state');
                                resetEditModalButtonState();
                            }
                        }
                    });
                });
                observer.observe(modal, { attributes: true, attributeFilter: ['class'] });

                // Add click listener to modal overlay to reset button state
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        console.log('Modal overlay clicked - resetting button state');
                        resetEditModalButtonState();
                        hideEditTradeModal();
                    }
                });

                // Add keyboard listener for Escape key
                const handleKeyDown = (e) => {
                    if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
                        console.log('Escape key pressed - resetting button state');
                        resetEditModalButtonState();
                        hideEditTradeModal();
                    }
                };
                document.addEventListener('keydown', handleKeyDown);
            }

            // Form submission - SIMPLIFIED APPROACH
            editForm?.addEventListener('submit', (e) => {
                e.preventDefault();
                console.log('Form submit event triggered');
                
                const submitBtn = editSubmitBtn;
                const btnText = submitBtn.querySelector('.btn-text');
                
                // Validate elements exist
                if (!submitBtn || !btnText) {
                    console.error('Edit form elements not found');
                    return;
                }
                
                // Show loading state
                btnText.textContent = 'Saving...';
                submitBtn.disabled = true;
                console.log('Loading state set');

                // Use setTimeout to ensure the UI updates before processing
                setTimeout(async () => {
                    try {
                        console.log('Starting edit form submission...');
                        
                        const formData = new FormData(editForm);
                        const tradeId = formData.get('tradeId');
                        
                        if (!tradeId) {
                            throw new Error('No trade ID found');
                        }
                        
                        console.log('Form data collected, tradeId:', tradeId);
                        
                        // Find the trade to update
                        const tradeIndex = appState.trades.findIndex(t => String(t.id) === String(tradeId));
                        if (tradeIndex === -1) {
                            throw new Error(`Trade not found with ID: ${tradeId}`);
                        }
                        
                        console.log('Found trade at index:', tradeIndex);

                        // Update trade data
                        const updatedTrade = {
                            ...appState.trades[tradeIndex],
                            asset: formData.get('symbol'),
                            quantity: parseFloat(formData.get('quantity')),
                            entry_price: parseFloat(formData.get('entry_price')),
                            entry_date: formData.get('entry_date') ? new Date(formData.get('entry_date')).toISOString() : null,
                            stop_loss: formData.get('stop_loss') ? parseFloat(formData.get('stop_loss')) : null,
                            target_price: formData.get('target_price') ? parseFloat(formData.get('target_price')) : null,
                            exit_price: formData.get('exit_price') ? parseFloat(formData.get('exit_price')) : null,
                            exit_date: formData.get('exit_date') ? new Date(formData.get('exit_date')).toISOString() : null,
                            exit_quantity: formData.get('exit_quantity') ? parseFloat(formData.get('exit_quantity')) : null,
                            reasons: formData.get('reasons')
                        };

                        console.log('Updated trade data prepared');

                        // Update in data store
                        console.log('Calling dataStore.upsertTrade...');
                        try {
                            await dataStore.upsertTrade(updatedTrade);
                            console.log('dataStore.upsertTrade completed successfully');
                        } catch (dbError) {
                            console.error('Database error:', dbError);
                            // Continue with local update even if database fails
                            console.log('Continuing with local update despite database error');
                        }
                        
                        // Update local state
                        appState.trades[tradeIndex] = updatedTrade;
                        console.log('Local state updated');
                        
                        // Refresh displays
                        renderTradeHistory();
                        window.main.loadDashboardData().then(data => {
                          window.ui.renderDashboardUI(data);
                        }).catch(err => {
                          console.error('loadDashboardData error', err);
                        });
                        console.log('Displays refreshed');
                        
                        console.log('Trade updated successfully');
                        
                        // SUCCESS - Reset button and close modal
                        console.log('SUCCESS: Resetting button state');
                        btnText.textContent = 'Save';
                        submitBtn.disabled = false;
                        hideEditTradeModal();
                        console.log('SUCCESS: Modal closed');
                        
                    } catch (error) {
                        console.error('ERROR in form submission:', error);
                        alert('Error updating trade: ' + error.message);
                        
                        // ERROR - Reset button state
                        console.log('ERROR: Resetting button state');
                        btnText.textContent = 'Save';
                        submitBtn.disabled = false;
                        console.log('ERROR: Button state reset');
                    }
                }, 100); // Small delay to ensure UI updates
            });
        });

        // External Tooltip Support for Chart.js
        const externalTooltipHandler = (context) => {
            const { chart, tooltip } = context;
            const tooltipEl = document.getElementById('chartjs-custom-tooltip');

            // Hide if no tooltip
            if (tooltip.opacity === 0) {
                tooltipEl.style.opacity = '0';
                tooltipEl.setAttribute('aria-hidden', 'true');
                return;
            }

            // Set caret Position
            tooltipEl.classList.remove('above', 'below', 'no-transform');
            if (tooltip.yAlign) {
                tooltipEl.classList.add(tooltip.yAlign);
            }

            // Set Text
            if (tooltip.body) {
                const titleLines = tooltip.title || [];
                const bodyLines = tooltip.body.map(b => b.lines);

                let innerHtml = '';

                titleLines.forEach(title => {
                    innerHtml += `<div class="tooltip-title">${title}</div>`;
                });

                bodyLines.forEach((body, i) => {
                    const colors = tooltip.labelColors[i];
                    let style = `background:${colors.backgroundColor}`;
                    style += `; border-color:${colors.borderColor}`;
                    style += `; border-width: 2px`;
                    const span = `<span class="tooltip-color" style="${style}"></span>`;
                    innerHtml += `<div class="tooltip-body">${span}${body}</div>`;
                });

                tooltipEl.innerHTML = innerHtml;
            }

            const position = Chart.helpers.getRelativePosition(tooltip.caretX, tooltip.caretY, chart);
            tooltipEl.style.left = position.x + tooltip.caretX + 'px';
            tooltipEl.style.top = position.y + tooltip.caretY + 'px';
            tooltipEl.style.opacity = '1';
            tooltipEl.setAttribute('aria-hidden', 'false');
        };

        // Touch and Mouse Event Handlers for Tooltips
        const setupTooltipEvents = () => {
            const tooltipEl = document.getElementById('chartjs-custom-tooltip');
            
            // Hide tooltip on mouseout
            document.addEventListener('mouseout', (e) => {
                if (!e.relatedTarget || !e.relatedTarget.closest('canvas')) {
                    tooltipEl.style.opacity = '0';
                    tooltipEl.setAttribute('aria-hidden', 'true');
                }
            });

            // Touch support
            document.addEventListener('touchstart', (e) => {
                if (e.target.closest('canvas')) {
                    // Touch events will be handled by Chart.js
                }
            });

            // Hide tooltip on blur
            document.addEventListener('blur', () => {
                tooltipEl.style.opacity = '0';
                tooltipEl.setAttribute('aria-hidden', 'true');
            });
        };

        // Initialize tooltip events
        setupTooltipEvents();

        // Exit Trade Modal Functions
        let currentExitTrade = null;

        const showExitTradeModal = (trade) => {
            currentExitTrade = trade;
            const modal = document.getElementById('exit-trade-modal');
            
            // Determine trade status
            const isClosed = trade.exit_date && trade.exit_price && (!trade.exit_quantity || trade.exit_quantity >= trade.quantity);
            const isPartialExit = trade.exit_date && trade.exit_price && trade.exit_quantity && trade.exit_quantity < trade.quantity;
            const status = isClosed ? 'Closed' : (isPartialExit ? 'Partial Exit' : 'Open');
            
            // Populate trade details
            document.getElementById('exit-trade-symbol').textContent = trade.asset || 'Unknown';
            document.getElementById('exit-trade-status').textContent = status;
            document.getElementById('exit-trade-status').className = isClosed ? 'px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800' : 
                                                               (isPartialExit ? 'px-2 py-1 text-xs font-semibold rounded-full bg-blue-100 text-blue-800' : 
                                                               'px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800');
            
            document.getElementById('exit-trade-type').value = trade.direction || 'Long';
            document.getElementById('exit-trade-quantity').value = trade.quantity || 0;
            document.getElementById('exit-trade-entry-price').value = trade.entry_price || 0;
            document.getElementById('exit-trade-stop-loss').value = trade.stop_loss || 0;
            document.getElementById('exit-trade-target').value = trade.target || 0;
            document.getElementById('exit-trade-total-amount').value = window.utils.formatCurrency((trade.entry_price || 0) * (trade.quantity || 0));
            
            // Set default exit quantity to remaining quantity for partial exits
            const remainingQuantity = isPartialExit ? (trade.quantity - trade.exit_quantity) : trade.quantity;
            document.getElementById('exit-trade-exit-quantity').value = remainingQuantity;
            
            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('exit-trade-date').value = today;
            
            // Clear exit fields
            document.getElementById('exit-trade-price').value = '';
            document.getElementById('exit-trade-brokerage').value = '';
            document.getElementById('exit-trade-charges').value = '';
            
            // Clear additional fields
            document.getElementById('exit-strategy').value = trade.strategy || 'Price Action';
            document.getElementById('exit-outcome-summary').value = 'Select outcome summary';
            document.getElementById('exit-emotional-state').value = '';
            document.getElementById('exit-trade-notes').value = '';
            
            // Clear mistake checkboxes
            document.querySelectorAll('input[name="exit-mistakes"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Clear P&L calculations
            document.getElementById('exit-gross-pnl').textContent = '₹0.00';
            document.getElementById('exit-total-charges').textContent = '₹0.00';
            document.getElementById('exit-net-pnl').textContent = '₹0.00';
            document.getElementById('exit-pnl-percentage').textContent = '0.00%';
            
            // Reset to Trade tab
            switchToTradeTab();
            
            modal.classList.remove('hidden');
        };

        const hideExitTradeModal = () => {
            const modal = document.getElementById('exit-trade-modal');
            modal.classList.add('hidden');
            currentExitTrade = null;
        };

        // Tab switching functions
        const switchToTradeTab = () => {
            // Update tab buttons
            document.getElementById('exit-trade-tab').className = 'px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-blue-500 text-blue-600';
            document.getElementById('exit-journal-tab').className = 'px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-transparent text-gray-500 hover:text-gray-700';
            
            // Show/hide content
            document.getElementById('exit-trade-content').classList.remove('hidden');
            document.getElementById('exit-journal-content').classList.add('hidden');
        };

        const switchToJournalTab = () => {
            // Update tab buttons
            document.getElementById('exit-journal-tab').className = 'px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-blue-500 text-blue-600';
            document.getElementById('exit-trade-tab').className = 'px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-transparent text-gray-500 hover:text-gray-700';
            
            // Show/hide content
            document.getElementById('exit-journal-content').classList.remove('hidden');
            document.getElementById('exit-trade-content').classList.add('hidden');
        };

        const updateExitCalculations = () => {
            if (!currentExitTrade) return;
            
            const entryPrice = parseFloat(currentExitTrade.entry_price) || 0;
            const quantity = parseFloat(currentExitTrade.quantity) || 0;
            const exitPrice = parseFloat(document.getElementById('exit-trade-price').value) || 0;
            const exitQuantity = parseFloat(document.getElementById('exit-trade-exit-quantity').value) || 0;
            const brokerage = parseFloat(document.getElementById('exit-trade-brokerage').value) || 0;
            const charges = parseFloat(document.getElementById('exit-trade-charges').value) || 0;
            
            if (entryPrice && exitPrice && exitQuantity) {
                const directionMultiplier = currentExitTrade.direction === 'Short' ? -1 : 1;
                const grossPnl = (exitPrice - entryPrice) * exitQuantity * directionMultiplier;
                const totalCharges = brokerage + charges;
                const netPnl = grossPnl - totalCharges;
                const totalInvestment = entryPrice * quantity; // Always use full quantity for percentage
                const pnlPercentage = totalInvestment > 0 ? (netPnl / totalInvestment) * 100 : 0;
                
                document.getElementById('exit-gross-pnl').textContent = window.utils.formatCurrency(grossPnl);
                document.getElementById('exit-total-charges').textContent = window.utils.formatCurrency(totalCharges);
                document.getElementById('exit-net-pnl').textContent = window.utils.formatCurrency(netPnl);
                document.getElementById('exit-pnl-percentage').textContent = `${pnlPercentage.toFixed(2)}%`;
            }
        };

        // Event listeners for exit trade modal
        document.addEventListener('DOMContentLoaded', () => {
            const exitModal = document.getElementById('exit-trade-modal');
            const exitCloseBtn = document.getElementById('exit-trade-close');
            const exitCancelBtn = document.getElementById('exit-trade-cancel');
            const exitSubmitBtn = document.getElementById('exit-trade-submit');
            const exitTradeTab = document.getElementById('exit-trade-tab');
            const exitJournalTab = document.getElementById('exit-journal-tab');
            
            // Close modal events
            exitCloseBtn?.addEventListener('click', hideExitTradeModal);
            exitCancelBtn?.addEventListener('click', hideExitTradeModal);
            
            // Tab switching events
            exitTradeTab?.addEventListener('click', switchToTradeTab);
            exitJournalTab?.addEventListener('click', switchToJournalTab);
            
            // Close modal when clicking outside
            exitModal?.addEventListener('click', (e) => {
                if (e.target === exitModal) {
                    hideExitTradeModal();
                }
            });
            
            // Real-time calculations
            const calculationInputs = ['exit-trade-price', 'exit-trade-exit-quantity', 'exit-trade-brokerage', 'exit-trade-charges'];
            calculationInputs.forEach(id => {
                document.getElementById(id)?.addEventListener('input', updateExitCalculations);
            });
            
            // Submit exit trade
            exitSubmitBtn?.addEventListener('click', async () => {
                if (!currentExitTrade) return;
                
                const exitDate = document.getElementById('exit-trade-date').value;
                const exitTime = document.getElementById('exit-trade-time').value;
                const exitPrice = parseFloat(document.getElementById('exit-trade-price').value);
                const exitQuantity = parseFloat(document.getElementById('exit-trade-exit-quantity').value);
                const brokerage = parseFloat(document.getElementById('exit-trade-brokerage').value) || 0;
                const charges = parseFloat(document.getElementById('exit-trade-charges').value) || 0;
                
                if (!exitDate || !exitPrice || !exitQuantity) {
                    alert('Please fill in all required fields (Exit Date, Exit Price, Exit Qty)');
                    return;
                }
                
                if (exitQuantity > currentExitTrade.quantity) {
                    alert('Exit quantity cannot be greater than the original quantity');
                    return;
                }
                
                try {
                    // Prepare exit data
                    const exitData = {
                        ...currentExitTrade,
                        exit_date: (exitDate && exitTime) ? `${exitDate}T${exitTime}` : exitDate,
                        exit_price: exitPrice,
                        exit_quantity: exitQuantity,
                        brokerage: brokerage,
                        other_fees: charges,
                        strategy: document.getElementById('exit-strategy').value,
                        outcomeSummary: document.getElementById('exit-outcome-summary').value,
                        emotionalState: document.getElementById('exit-emotional-state').value,
                        reasons: document.getElementById('exit-trade-notes').value,
                        mistakes: Array.from(document.querySelectorAll('input[name="exit-mistakes"]:checked')).map(cb => cb.value)
                    };
                    
                    // Determine if it's a partial exit
                    const isPartialExit = exitQuantity < currentExitTrade.quantity;
                    
                    if (isPartialExit) {
                        // Store this individual partial exit
                        const partialExitRecord = {
                            id: window.utils.generateUUID(),
                            trade_id: currentExitTrade.id,
                            exit_date: exitData.exit_date,
                            exit_price: exitPrice,
                            exit_quantity: exitQuantity,
                            brokerage: brokerage,
                            charges: charges
                        };
                        
                        // Save partial exit to Supabase
                        await dataStore.savePartialExit(partialExitRecord);
                        
                        // Update the main trade with cumulative exit data
                        const currentExitQty = currentExitTrade.exit_quantity || 0;
                        const newTotalExitQty = currentExitQty + exitQuantity;
                        
                        // Update exit data with cumulative values
                        exitData.exit_quantity = newTotalExitQty;
                        
                        // If this makes it a full exit, show appropriate toast
                        if (newTotalExitQty >= currentExitTrade.quantity) {
                            window.utils.showToast('Trade fully exited successfully!', 'success');
                        } else {
                            window.utils.showToast('Partial exit recorded successfully!', 'success');
                        }
                        
                        await dataStore.upsertTrade(exitData);
                    } else {
                        // For full exit
                        await dataStore.upsertTrade(exitData);
                        window.utils.showToast('Trade exited successfully!', 'success');
                    }
                    
                    // Update in-memory state only - Supabase realtime will handle the rest
                    try {
                        const updatedTrades = Array.isArray(appState.trades) ? [...appState.trades] : [];
                        const idx = updatedTrades.findIndex(t => String(t.id) === String(exitData.id));
                        if (idx >= 0) updatedTrades[idx] = { ...updatedTrades[idx], ...exitData };
                        else updatedTrades.push(exitData);
                        appState.trades = updatedTrades;
                    } catch (e) {
                        console.warn('In-memory state update failed:', e);
                    }

                    // Re-render immediately
                    // Invalidate caches to force fresh rendering
                    try { tradeHistoryCache = null; tradeHistoryLastHash = null; } catch {}
                    try { openPositionsCache = null; openPositionsLastHash = null; } catch {}
                    renderTradeHistory();
                    window.main.loadDashboardData().then(data => {
                      window.ui.renderDashboardUI(data);
                    }).catch(err => {
                      console.error('loadDashboardData error', err);
                    });
                    renderFundManagement();
                    if (document.getElementById('ai-analyst').classList.contains('active')) {
                        renderAIAnalyst();
                    }

                    // Background refresh to sync with remote without blocking UI
                    (async () => {
                        try {
                            const fresh = await dataStore.getTrades();
                            appState.trades = fresh;
                            // Invalidate caches again before repaint with remote data
                            try { tradeHistoryCache = null; tradeHistoryLastHash = null; } catch {}
                            try { openPositionsCache = null; openPositionsLastHash = null; } catch {}
                            renderTradeHistory();
                            window.main.loadDashboardData().then(data => {
                              window.ui.renderDashboardUI(data);
                            }).catch(err => {
                              console.error('loadDashboardData error', err);
                            });
                            renderFundManagement();
                            if (document.getElementById('ai-analyst').classList.contains('active')) {
                                renderAIAnalyst();
                            }
                        } catch (e) {
                            console.warn('Background refresh failed:', e);
                        }
                    })();
                    
                    hideExitTradeModal();
                } catch (error) {
                    console.error('Error exiting trade:', error);
                    window.utils.showToast('Error exiting trade. Please try again.', 'error');
                }
            });
        });

        // Partial Exit Details Modal
        const showPartialExitDetailsModal = async (trade) => {
            console.log('showPartialExitDetailsModal called with trade:', trade);
            let modal = document.getElementById('partial-exit-details-modal');
            if (!modal) {
                // Create modal if it doesn't exist
                createPartialExitDetailsModal();
                modal = document.getElementById('partial-exit-details-modal');
            }
            
            // Populate symbol
            document.getElementById('partial-exit-symbol').textContent = trade.asset || 'Unknown';
            
            // Get all partial exits for this trade from Supabase
            const partialExits = await dataStore.getPartialExits(trade.id);
            console.log('Retrieved partial exits for trade', trade.id, ':', partialExits);
            const exits = [];
            
            // If this is a partial exit trade, create exit data
            if (trade.exit_quantity && trade.exit_quantity > 0) {
                const entryPrice = trade.entry_price || 0;
                const exitPrice = trade.exit_price || 0;
                const directionMultiplier = trade.direction === 'Short' ? -1 : 1;
                
                // If we have stored partial exits, use them
                if (partialExits.length > 0) {
                    console.log('Processing', partialExits.length, 'stored partial exits');
                    partialExits.forEach(exit => {
                        const grossPnl = (exit.price - entryPrice) * exit.quantity * directionMultiplier;
                        const totalCharges = (exit.brokerage || 0) + (exit.charges || 0);
                        const netPnl = grossPnl - totalCharges;
                        const totalInvestment = entryPrice * trade.quantity;
                        const pnlPercentage = totalInvestment > 0 ? (netPnl / totalInvestment) * 100 : 0;
                        
                        exits.push({
                            date: exit.date || '—',
                            price: exit.price,
                            quantity: exit.quantity,
                            pnl: netPnl,
                            pnlPercentage: pnlPercentage,
                            brokerage: exit.brokerage || 0,
                            charges: exit.charges || 0
                        });
                    });
                } else {
                    // Fallback: create single exit from current trade data
                    const exitQty = trade.exit_quantity;
                    const grossPnl = (exitPrice - entryPrice) * exitQty * directionMultiplier;
                    const totalCharges = (trade.brokerage || 0) + (trade.other_fees || 0);
                    const netPnl = grossPnl - totalCharges;
                    const totalInvestment = entryPrice * trade.quantity;
                    const pnlPercentage = totalInvestment > 0 ? (netPnl / totalInvestment) * 100 : 0;
                    
                    exits.push({
                        date: trade.exit_date || '—',
                        price: exitPrice,
                        quantity: exitQty,
                        pnl: netPnl,
                        pnlPercentage: pnlPercentage,
                        brokerage: trade.brokerage || 0,
                        charges: trade.other_fees || 0
                    });
                }
            }
            
            // Update exit count
            document.getElementById('partial-exit-count').textContent = `${exits.length} Exit${exits.length !== 1 ? 's' : ''}`;
            
            // Calculate summary
            const totalExited = exits.reduce((sum, exit) => sum + exit.quantity, 0);
            const remaining = (trade.quantity || 0) - totalExited;
            const cumulativePnl = exits.reduce((sum, exit) => sum + exit.pnl, 0);
            
            // Calculate average selling price (weighted by quantity)
            const totalValue = exits.reduce((sum, exit) => sum + (exit.price * exit.quantity), 0);
            const averageSellingPrice = totalExited > 0 ? totalValue / totalExited : 0;
            
            // Calculate average P&L per unit
            const averagePnlPerUnit = totalExited > 0 ? cumulativePnl / totalExited : 0;
            
            // Calculate total brokerage and charges
            const totalBrokerage = exits.reduce((sum, exit) => sum + (exit.brokerage || 0), 0);
            const totalCharges = exits.reduce((sum, exit) => sum + (exit.charges || 0), 0);
            
            // Update summary
            document.getElementById('partial-exit-total-exited').textContent = `${totalExited} units`;
            document.getElementById('partial-exit-remaining').textContent = `${remaining} units`;
            document.getElementById('partial-exit-avg-price').textContent = window.utils.formatCurrency(averageSellingPrice);
            document.getElementById('partial-exit-avg-pnl').textContent = window.utils.formatCurrency(averagePnlPerUnit);
            document.getElementById('partial-exit-total-brokerage').textContent = window.utils.formatCurrency(totalBrokerage);
            document.getElementById('partial-exit-total-charges').textContent = window.utils.formatCurrency(totalCharges);
            document.getElementById('partial-exit-cumulative-pnl').textContent = window.utils.formatCurrency(cumulativePnl);
            
            // Color code cumulative P&L
            const cumulativePnlElement = document.getElementById('partial-exit-cumulative-pnl');
            if (cumulativePnl > 0) {
                cumulativePnlElement.style.color = '#10b981'; // Green for profit
            } else if (cumulativePnl < 0) {
                cumulativePnlElement.style.color = '#ef4444'; // Red for loss
            } else {
                cumulativePnlElement.style.color = 'var(--text-primary)'; // Default color
            }
            
            // Color code average P&L per unit
            const averagePnlElement = document.getElementById('partial-exit-avg-pnl');
            if (averagePnlPerUnit > 0) {
                averagePnlElement.style.color = '#10b981'; // Green for profit
            } else if (averagePnlPerUnit < 0) {
                averagePnlElement.style.color = '#ef4444'; // Red for loss
            } else {
                averagePnlElement.style.color = 'var(--text-primary)'; // Default color
            }
            
            // Populate exits table
            const tableBody = document.getElementById('partial-exit-table-body');
            if (exits.length > 0) {
                tableBody.innerHTML = exits.map(exit => {
                    const pnlColor = exit.pnl > 0 ? '#10b981' : exit.pnl < 0 ? '#ef4444' : 'var(--text-primary)';
                    const pnlSign = exit.pnl > 0 ? '+' : '';
                    const pnlPercentageSign = exit.pnlPercentage > 0 ? '+' : '';
                    
                    return `
                        <tr>
                            <td class="px-4 py-3 text-sm" style="color: var(--text-primary);">${window.utils.formatDateForDisplay(exit.date) || '—'}</td>
                            <td class="px-4 py-3 text-sm" style="color: var(--text-primary);">₹${exit.price.toFixed(2)}</td>
                            <td class="px-4 py-3 text-sm" style="color: var(--text-primary);">${exit.quantity}</td>
                            <td class="px-4 py-3 text-sm font-semibold" style="color: ${pnlColor};">${pnlSign}₹${exit.pnl.toFixed(2)}</td>
                            <td class="px-4 py-3 text-sm font-semibold" style="color: ${pnlColor};">${pnlPercentageSign}${exit.pnlPercentage.toFixed(3)}%</td>
                        </tr>
                    `;
                }).join('');
            } else {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="5" class="px-4 py-8 text-center text-sm" style="color: var(--text-secondary);">
                            No exits recorded
                        </td>
                    </tr>
                `;
            }
            
            modal.classList.remove('hidden');
            console.log('Partial exit modal shown with exits:', exits.length);
            console.log('Modal element:', modal);
            console.log('Summary data:', {
                totalExited,
                averageSellingPrice,
                averagePnlPerUnit,
                totalBrokerage,
                totalCharges,
                cumulativePnl
            });
        };

        // --- AI ANALYST FUNCTIONALITY ---
        // Debouncing for AI analyst rendering to prevent jitter
        let aiAnalystRenderTimeout = null;
        
        const renderAIAnalyst = async () => {
            // Clear previous timeout to prevent multiple rapid renders
            if (aiAnalystRenderTimeout) {
                clearTimeout(aiAnalystRenderTimeout);
            }
            
            // Debounce rendering by 100ms to prevent jitter (longer delay due to async operations)
            aiAnalystRenderTimeout = setTimeout(async () => {
                try {
                    console.debug('AI Analyst: Starting analysis...');
            
            // Show loading state
            const loadingElements = document.querySelectorAll('#ai-analyst .text-2xl');
            loadingElements.forEach(el => {
                if (el.id && el.id.startsWith('ai-')) {
                    el.textContent = 'Loading...';
                }
            });
            
            // Get trade data - ensure we have the latest data
            let trades = [];
            try {
                // First try to get fresh data from dataStore
                trades = await dataStore.getTrades();
                console.debug('AI Analyst: Using fresh data from dataStore, count:', trades.length);
                console.debug('AI Analyst: Sample trade data:', trades.slice(0, 2));
                
                // Update appState with fresh data
                appState.trades = trades;
            } catch (error) {
                console.warn('AI Analyst: Error getting fresh data, trying appState.trades', error);
                try {
                    trades = appState.trades || [];
                    console.debug('AI Analyst: Using appState.trades, count:', trades.length);
                    console.debug('AI Analyst: appState.trades sample:', trades.slice(0, 2));
                } catch (appStateError) {
                    console.warn('AI Analyst: Error accessing appState.trades, falling back to DOM parsing', appStateError);
                    trades = parseTradesFromDOM();
                    console.debug('AI Analyst: Using DOM parsing, count:', trades.length);
                }
            }
            
            // Additional debugging
            console.debug('AI Analyst: Final trades array:', trades);
            console.debug('AI Analyst: Trades length:', trades.length);
            console.debug('AI Analyst: DataStore available:', !!dataStore);
            console.debug('AI Analyst: Supabase client available:', !!supabase);
            
            // Calculate core metrics with defensive checks
            const metrics = calculateTradeMetrics(trades);
            console.debug('AI Analyst: Calculated metrics:', metrics);
            
            // Check if we have any trades at all
            if (trades.length === 0) {
                console.warn('AI Analyst: No trades found in the system');
                // Show a message to the user
                const noDataMessage = document.createElement('div');
                noDataMessage.className = 'text-center py-8';
                noDataMessage.innerHTML = `
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
                        <i data-feather="info" class="h-12 w-12 text-yellow-500 mx-auto mb-4"></i>
                        <h3 class="text-lg font-semibold text-yellow-800 mb-2">No Trade Data Found</h3>
                        <p class="text-yellow-700 mb-4">To see AI analysis, you need to add some trades first.</p>
                        <button onclick="navigateTo('add-trade')" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">
                            Add Your First Trade
                        </button>
                    </div>
                `;
                
                // Clear existing content and show message
                const aiAnalystPage = document.getElementById('ai-analyst');
                const existingContent = aiAnalystPage.querySelector('.space-y-8');
                if (existingContent) {
                    existingContent.innerHTML = '';
                    existingContent.appendChild(noDataMessage);
                    feather.replace();
                }
                return;
            }
            
            // Update summary cards
            updateSummaryCards(metrics);
            
            // Generate and display alert cards
            const alerts = generateAlertCards(metrics, trades);
            displayAlertCards(alerts);
            
            // Determine trader personality profile
            const traderProfile = determineTraderProfile(metrics, trades);
            displayTraderProfile(traderProfile);
            
            // Generate behavior insights
            const behaviorInsights = await analyzeBehaviorPatterns(trades, metrics);
            displayBehaviorInsights(behaviorInsights);
            
            // Display emotional volatility and performance under stress in separate cards
            displayEmotionalVolatilityInsights(behaviorInsights);
            displayPerformanceUnderStressInsights(behaviorInsights);
            
            // Update performance sections
            updatePerformanceSections(trades, metrics);
            
            // Update risk discipline panel
            updateRiskDisciplinePanel(metrics, trades);
            
            // Generate AI recommendations
            const recommendations = generateAIRecommendations(metrics, trades, traderProfile);
            displayAIRecommendations(recommendations);
            
            // Generate and display adaptive risk suggestion
            const riskSuggestion = generateRiskSuggestion(metrics);
            displayRiskSuggestion(riskSuggestion);
            
            // Update consistency and growth stats
            updateConsistencyAndGrowth(metrics, trades);
            
            // Update summary highlight
            updateSummaryHighlight(metrics, traderProfile);
            
            console.debug('AI Analyst: Analysis complete');
                } catch (e) {
                    console.error('renderAIAnalyst error', e);
                }
            }, 100); // 100ms debounce delay
        };
        
        
        // Parse trades from DOM if appState.trades is not available
        const parseTradesFromDOM = () => {
            console.debug('AI Analyst: Parsing trades from DOM...');
            const trades = [];
            try {
                const tbody = document.getElementById('trade-history-tbody');
                if (!tbody) {
                    console.warn('AI Analyst: Trade history table not found');
                    return [];
                }
                
                const rows = tbody.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    try {
                        const cells = row.querySelectorAll('td');
                        if (cells.length >= 10) {
                            const trade = {
                                id: `dom_${index}`,
                                asset: cells[0]?.textContent?.trim() || '',
                                pnl: parseFloat(cells[1]?.textContent?.replace(/[₹,]/g, '')) || 0,
                                status: cells[2]?.textContent?.trim() || '',
                                entry_price: parseFloat(cells[3]?.textContent?.replace(/[₹,]/g, '')) || 0,
                                direction: cells[4]?.textContent?.trim() || '',
                                entry_date: cells[5]?.textContent?.trim() || '',
                                stop_loss: parseFloat(cells[6]?.textContent?.replace(/[₹,]/g, '')) || null,
                                quantity: parseFloat(cells[7]?.textContent?.replace(/[,]/g, '')) || 0,
                                exit_price: parseFloat(cells[8]?.textContent?.replace(/[₹,]/g, '')) || null,
                                exit_date: cells[9]?.textContent?.trim() || null
                            };
                            trades.push(trade);
                        }
                    } catch (error) {
                        console.warn('AI Analyst: Error parsing trade row', index, error);
                    }
                });
                console.debug('AI Analyst: Parsed', trades.length, 'trades from DOM');
            } catch (error) {
                console.error('AI Analyst: Error parsing trades from DOM', error);
            }
            return trades;
        };
        
        // Calculate comprehensive trade metrics
        const calculateTradeMetrics = (trades) => {
            console.debug('AI Analyst: Calculating metrics for', trades.length, 'trades');
            
            if (!trades || trades.length === 0) {
                return {
                    totalTrades: 0,
                    winningTrades: 0,
                    losingTrades: 0,
                    winRate: 0,
                    totalPnL: 0,
                    avgPnL: 0,
                    avgWin: 0,
                    avgLoss: 0,
                    riskRewardRatio: 0,
                    maxDrawdown: 0,
                    stopLossUsage: 0,
                    avgStopLoss: 0,
                    avgHoldingDays: 0,
                    oversizePositions: 0,
                    consecutiveWinStreak: 0,
                    consecutiveLossStreak: 0,
                    profitableDays: 0,
                    totalTradingDays: 0
                };
            }
            
            // Filter closed trades for P&L calculations
            // Use the same logic as other parts of the app for consistency
            const closedTrades = trades.filter(t => {
                // Check if trade has exit data
                if (!t.exit_date || !t.exit_price) return false;
                
                // Check if it's fully closed or partial exit
                const isClosed = !t.exit_quantity || t.exit_quantity >= t.quantity;
                const isPartialExit = t.exit_quantity && t.exit_quantity < t.quantity;
                
                return isClosed || isPartialExit;
            });
            
            console.debug('AI Analyst: Closed trades count:', closedTrades.length);
            console.debug('AI Analyst: Sample closed trades:', closedTrades.slice(0, 2));
            console.debug('AI Analyst: All trades sample:', trades.slice(0, 2));
            
            // If no closed trades found, use all trades for basic analysis
            const tradesToAnalyze = closedTrades.length > 0 ? closedTrades : trades;
            console.debug('AI Analyst: Using trades for analysis:', tradesToAnalyze.length);
            
            // Basic metrics
            const totalTrades = tradesToAnalyze.length;
            let totalPnL = 0;
            let winningTrades = 0;
            let losingTrades = 0;
            let totalWinPnL = 0;
            let totalLossPnL = 0;
            let stopLossCount = 0;
            let totalStopLoss = 0;
            let totalHoldingDays = 0;
            let validHoldingDays = 0;
            let oversizePositions = 0;
            
            // Calculate daily P&L for consistency metrics
            const dailyPnL = {};
            
            tradesToAnalyze.forEach(trade => {
                try {
                    // Calculate P&L - use existing calculateNetPnl if available, otherwise calculate manually
                    let pnl = 0;
                    if (typeof calculateNetPnl === 'function') {
                        pnl = calculateNetPnl(trade);
                    } else {
                        // Manual P&L calculation
                        const entryPrice = parseFloat(trade.entry_price) || 0;
                        const exitPrice = parseFloat(trade.exit_price) || 0;
                        const quantity = parseFloat(trade.quantity) || 0;
                        const direction = trade.direction === 'Short' ? -1 : 1;
                        const grossPnL = (exitPrice - entryPrice) * quantity * direction;
                        const brokerage = parseFloat(trade.brokerage) || 0;
                        const otherFees = parseFloat(trade.other_fees) || 0;
                        pnl = grossPnL - brokerage - otherFees;
                    }
                    
                    if (isNaN(pnl)) pnl = 0;
                    
                    totalPnL += pnl;
                    
                    if (pnl > 0) {
                        winningTrades++;
                        totalWinPnL += pnl;
                    } else if (pnl < 0) {
                        losingTrades++;
                        totalLossPnL += Math.abs(pnl);
                    }
                    
                    // Stop loss analysis
                    if (trade.stop_loss && !isNaN(parseFloat(trade.stop_loss))) {
                        stopLossCount++;
                        totalStopLoss += parseFloat(trade.stop_loss);
                    }
                    
                    // Holding days calculation
                    if (trade.entry_date && trade.exit_date) {
                        try {
                            const entryDate = new Date(trade.entry_date);
                            const exitDate = new Date(trade.exit_date);
                            if (!isNaN(entryDate.getTime()) && !isNaN(exitDate.getTime())) {
                                const holdingDays = (exitDate - entryDate) / (1000 * 60 * 60 * 24);
                                totalHoldingDays += holdingDays;
                                validHoldingDays++;
                            }
                        } catch (error) {
                            console.warn('AI Analyst: Error calculating holding days for trade', trade.id, error);
                        }
                    }
                    
                    // Oversize position detection (heuristic: position value > 20% of assumed account balance)
                    const positionValue = (parseFloat(trade.entry_price) || 0) * (parseFloat(trade.quantity) || 0);
                    const assumedAccountBalance = 100000; // Default assumption, could be made configurable
                    if (positionValue > assumedAccountBalance * 0.2) {
                        oversizePositions++;
                    }
                    
                    // Daily P&L aggregation for consistency metrics
                    if (trade.exit_date) {
                        try {
                            const exitDate = new Date(trade.exit_date);
                            if (!isNaN(exitDate.getTime())) {
                                const dateKey = exitDate.toISOString().split('T')[0];
                                dailyPnL[dateKey] = (dailyPnL[dateKey] || 0) + pnl;
                            }
                        } catch (error) {
                            console.warn('AI Analyst: Error processing exit date for daily P&L', trade.exit_date, error);
                        }
                    }
                    
                } catch (error) {
                    console.warn('AI Analyst: Error processing trade for metrics', trade.id, error);
                }
            });
            
            // Calculate derived metrics
            const winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0;
            const avgPnL = totalTrades > 0 ? totalPnL / totalTrades : 0;
            const avgWin = winningTrades > 0 ? totalWinPnL / winningTrades : 0;
            const avgLoss = losingTrades > 0 ? totalLossPnL / losingTrades : 0;
            const riskRewardRatio = avgLoss > 0 ? avgWin / avgLoss : 0;
            const stopLossUsage = totalTrades > 0 ? (stopLossCount / totalTrades) * 100 : 0;
            const avgStopLoss = stopLossCount > 0 ? totalStopLoss / stopLossCount : 0;
            const avgHoldingDays = validHoldingDays > 0 ? totalHoldingDays / validHoldingDays : 0;
            
            // Calculate streaks
            const streaks = calculateStreaks(tradesToAnalyze);
            
            // Calculate consistency metrics
            const tradingDays = Object.keys(dailyPnL);
            const profitableDays = tradingDays.filter(date => dailyPnL[date] > 0).length;
            const totalTradingDays = tradingDays.length;
            
            // Calculate max drawdown (simplified)
            const maxDrawdown = calculateMaxDrawdown(tradesToAnalyze);
            
            // Calculate Consistency Index
            const startingBalance = appState.ledger && appState.ledger.length > 0 ? 
                appState.ledger.filter(l => l.type === 'Deposit').reduce((sum, l) => sum + (parseFloat(l.amount) || 0), 0) : 0;
            const consistencyData = calculateConsistencyIndex(closedTrades, startingBalance);
            
            // Calculate Trade Efficiency
            const efficiencyData = calculateTradeEfficiency(closedTrades);
            
            // Calculate Capital Utilization
            const currentAccountValue = appState.accountValue || 0;
            const capitalUtilizationData = calculateCapitalUtilization(closedTrades, currentAccountValue);
            
            // Calculate Recent Win Rate (Predictive Win Probability)
            const recentWinRateData = calculateRecentWinRate(closedTrades, 20);
            
            // Calculate Trading Discipline Score
            const disciplineScoreData = calculateDisciplineScore(closedTrades, {
                stopLossUsage: stopLossUsage,
                totalTrades: totalTrades
            });
            
            const metrics = {
                totalTrades,
                winningTrades,
                losingTrades,
                winRate,
                totalPnL,
                avgPnL,
                avgWin,
                avgLoss,
                riskRewardRatio,
                maxDrawdown,
                stopLossUsage,
                avgStopLoss,
                avgHoldingDays,
                oversizePositions,
                consecutiveWinStreak: streaks.maxWinStreak,
                consecutiveLossStreak: streaks.maxLossStreak,
                profitableDays,
                totalTradingDays,
                consistencyIndex: consistencyData.value,
                consistencyInterpretation: consistencyData.interpretation,
                tradeEfficiency: efficiencyData.value,
                efficiencyInterpretation: efficiencyData.interpretation,
                capitalUtilization: capitalUtilizationData.value,
                capitalUtilizationInterpretation: capitalUtilizationData.interpretation,
                recentWinRate: recentWinRateData.winRate,
                recentWinRateInterpretation: recentWinRateData.interpretation,
                disciplineScore: disciplineScoreData.score,
                disciplineScoreInterpretation: disciplineScoreData.interpretation
            };
            
            console.debug('AI Analyst: Final metrics:', metrics);
            return metrics;
        };
        
        // Calculate consecutive win/loss streaks
        const calculateStreaks = (trades) => {
            if (!trades || trades.length === 0) return { maxWinStreak: 0, maxLossStreak: 0 };
            
            let maxWinStreak = 0;
            let maxLossStreak = 0;
            let currentWinStreak = 0;
            let currentLossStreak = 0;
            
            // Sort trades by exit date
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.exit_date || a.entry_date);
                const dateB = new Date(b.exit_date || b.entry_date);
                return dateA - dateB;
            });
            
            sortedTrades.forEach(trade => {
                try {
                    let pnl = 0;
                    if (typeof calculateNetPnl === 'function') {
                        pnl = calculateNetPnl(trade);
                    } else {
                        // Manual calculation fallback
                        const entryPrice = parseFloat(trade.entry_price) || 0;
                        const exitPrice = parseFloat(trade.exit_price) || 0;
                        const quantity = parseFloat(trade.quantity) || 0;
                        const direction = trade.direction === 'Short' ? -1 : 1;
                        pnl = (exitPrice - entryPrice) * quantity * direction;
                    }
                    
                    if (pnl > 0) {
                        currentWinStreak++;
                        currentLossStreak = 0;
                        maxWinStreak = Math.max(maxWinStreak, currentWinStreak);
                    } else if (pnl < 0) {
                        currentLossStreak++;
                        currentWinStreak = 0;
                        maxLossStreak = Math.max(maxLossStreak, currentLossStreak);
                    }
                } catch (error) {
                    console.warn('AI Analyst: Error calculating streak for trade', trade.id, error);
                }
            });
            
            return { maxWinStreak, maxLossStreak };
        };
        
        // Calculate max drawdown (simplified peak-to-trough)
        const calculateMaxDrawdown = (trades) => {
            if (!trades || trades.length === 0) return 0;
            
            let runningPnL = 0;
            let peak = 0;
            let maxDrawdown = 0;
            
            // Sort trades by exit date
            const sortedTrades = [...trades].sort((a, b) => {
                const dateA = new Date(a.exit_date || a.entry_date);
                const dateB = new Date(b.exit_date || b.entry_date);
                return dateA - dateB;
            });
            
            sortedTrades.forEach(trade => {
                try {
                    let pnl = 0;
                    if (typeof calculateNetPnl === 'function') {
                        pnl = calculateNetPnl(trade);
                    } else {
                        // Manual calculation fallback
                        const entryPrice = parseFloat(trade.entry_price) || 0;
                        const exitPrice = parseFloat(trade.exit_price) || 0;
                        const quantity = parseFloat(trade.quantity) || 0;
                        const direction = trade.direction === 'Short' ? -1 : 1;
                        pnl = (exitPrice - entryPrice) * quantity * direction;
                    }
                    
                    runningPnL += pnl;
                    peak = Math.max(peak, runningPnL);
                    const drawdown = peak - runningPnL;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                } catch (error) {
                    console.warn('AI Analyst: Error calculating drawdown for trade', trade.id, error);
                }
            });
            
            return maxDrawdown;
        };
        
        // Update summary cards with calculated metrics
        const updateSummaryCards = (metrics) => {
            try {
                document.getElementById('ai-total-trades').textContent = metrics.totalTrades || 0;
                document.getElementById('ai-win-rate').textContent = `${(metrics.winRate || 0).toFixed(1)}%`;
                document.getElementById('ai-avg-pnl').textContent = window.utils.formatCurrency(metrics.avgPnL || 0);
                document.getElementById('ai-net-pnl').textContent = window.utils.formatCurrency(metrics.totalPnL || 0);
                
                // Update Consistency Index card
                const consistencyIndexEl = document.getElementById('ai-consistency-index');
                const consistencyInterpretationEl = document.getElementById('ai-consistency-interpretation');
                if (consistencyIndexEl && consistencyInterpretationEl) {
                    consistencyIndexEl.textContent = (metrics.consistencyIndex || 0).toFixed(2);
                    consistencyInterpretationEl.textContent = metrics.consistencyInterpretation || 'No Data';
                }
                
                // Update Trade Efficiency card
                const tradeEfficiencyEl = document.getElementById('ai-trade-efficiency');
                const efficiencyInterpretationEl = document.getElementById('ai-efficiency-interpretation');
                if (tradeEfficiencyEl && efficiencyInterpretationEl) {
                    const efficiency = metrics.tradeEfficiency || 0;
                    tradeEfficiencyEl.textContent = `₹${efficiency.toFixed(2)} / min`;
                    
                    // Add color coding based on efficiency level
                    if (efficiency > 10) {
                        tradeEfficiencyEl.style.color = '#10b981'; // Green for excellent
                        efficiencyInterpretationEl.textContent = 'Excellent efficiency';
                    } else if (efficiency > 5) {
                        tradeEfficiencyEl.style.color = '#059669'; // Darker green for good
                        efficiencyInterpretationEl.textContent = 'Good efficiency';
                    } else if (efficiency > 1) {
                        tradeEfficiencyEl.style.color = '#f59e0b'; // Orange for moderate
                        efficiencyInterpretationEl.textContent = 'Moderate efficiency';
                    } else if (efficiency > 0) {
                        tradeEfficiencyEl.style.color = '#f97316'; // Darker orange for low
                        efficiencyInterpretationEl.textContent = 'Low efficiency';
                    } else {
                        tradeEfficiencyEl.style.color = '#ef4444'; // Red for negative
                        efficiencyInterpretationEl.textContent = 'Negative efficiency';
                    }
                    
                    // Fallback for no data
                    if (!metrics.efficiencyInterpretation || metrics.efficiencyInterpretation === 'No Data') {
                        tradeEfficiencyEl.style.color = 'var(--text-primary)';
                        efficiencyInterpretationEl.textContent = 'No Data';
                    }
                }
                
                // Update Predictive Win Probability card
                const predictiveWinProbEl = document.getElementById('ai-predictive-win-prob');
                const predictiveWinInterpretationEl = document.getElementById('ai-predictive-win-interpretation');
                if (predictiveWinProbEl && predictiveWinInterpretationEl) {
                    const recentWinRate = metrics.recentWinRate || 0;
                    predictiveWinProbEl.textContent = `${recentWinRate.toFixed(1)}%`;
                    
                    // Enhanced color coding based on recent win rate with better visual hierarchy
                    if (recentWinRate >= 80) {
                        predictiveWinProbEl.style.color = '#10b981'; // Bright green for excellent
                        predictiveWinProbEl.style.fontWeight = '700'; // Extra bold for excellent
                    } else if (recentWinRate >= 65) {
                        predictiveWinProbEl.style.color = '#059669'; // Green for very good
                        predictiveWinProbEl.style.fontWeight = '600'; // Bold for very good
                    } else if (recentWinRate >= 50) {
                        predictiveWinProbEl.style.color = '#0d9488'; // Teal for good
                        predictiveWinProbEl.style.fontWeight = '500'; // Medium for good
                    } else if (recentWinRate >= 35) {
                        predictiveWinProbEl.style.color = '#f59e0b'; // Orange for moderate
                        predictiveWinProbEl.style.fontWeight = '500'; // Medium for moderate
                    } else if (recentWinRate > 0) {
                        predictiveWinProbEl.style.color = '#f97316'; // Dark orange for low
                        predictiveWinProbEl.style.fontWeight = '500'; // Medium for low
                    } else {
                        predictiveWinProbEl.style.color = '#ef4444'; // Red for very low
                        predictiveWinProbEl.style.fontWeight = '600'; // Bold for very low
                    }
                    
                    // Enhanced interpretation with performance indicators
                    let interpretation = metrics.recentWinRateInterpretation || 'No Data';
                    if (recentWinRate > 0) {
                        if (recentWinRate >= 80) {
                            interpretation += ' - Excellent momentum!';
                        } else if (recentWinRate >= 65) {
                            interpretation += ' - Strong performance';
                        } else if (recentWinRate >= 50) {
                            interpretation += ' - Good performance';
                        } else if (recentWinRate >= 35) {
                            interpretation += ' - Room for improvement';
                        } else {
                            interpretation += ' - Needs attention';
                        }
                    }
                    
                    predictiveWinInterpretationEl.textContent = interpretation;
                }
                
                // Update Trading Discipline Score card
                const disciplineScoreEl = document.getElementById('ai-discipline-score');
                const disciplineInterpretationEl = document.getElementById('ai-discipline-interpretation');
                if (disciplineScoreEl && disciplineInterpretationEl) {
                    const disciplineScore = metrics.disciplineScore || 0;
                    disciplineScoreEl.textContent = `${disciplineScore.toFixed(0)}/100`;
                    
                    // Color coding based on discipline score
                    if (disciplineScore >= 80) {
                        disciplineScoreEl.style.color = '#10b981'; // Green for excellent
                        disciplineScoreEl.style.fontWeight = '700'; // Extra bold for excellent
                    } else if (disciplineScore >= 65) {
                        disciplineScoreEl.style.color = '#059669'; // Green for very good
                        disciplineScoreEl.style.fontWeight = '600'; // Bold for very good
                    } else if (disciplineScore >= 50) {
                        disciplineScoreEl.style.color = '#0d9488'; // Teal for good
                        disciplineScoreEl.style.fontWeight = '500'; // Medium for good
                    } else if (disciplineScore >= 30) {
                        disciplineScoreEl.style.color = '#f59e0b'; // Orange for moderate
                        disciplineScoreEl.style.fontWeight = '500'; // Medium for moderate
                    } else {
                        disciplineScoreEl.style.color = '#ef4444'; // Red for poor
                        disciplineScoreEl.style.fontWeight = '600'; // Bold for poor
                    }
                    
                    // Enhanced interpretation with performance indicators
                    let interpretation = metrics.disciplineScoreInterpretation || 'No Data';
                    if (disciplineScore > 0) {
                        if (disciplineScore >= 80) {
                            interpretation += ' - Excellent discipline!';
                        } else if (disciplineScore >= 65) {
                            interpretation += ' - Strong discipline';
                        } else if (disciplineScore >= 50) {
                            interpretation += ' - Good discipline';
                        } else if (disciplineScore >= 30) {
                            interpretation += ' - Room for improvement';
                        } else {
                            interpretation += ' - Needs attention';
                        }
                    }
                    
                    disciplineInterpretationEl.textContent = interpretation;
                }
            } catch (error) {
                console.error('AI Analyst: Error updating summary cards', error);
            }
        };
        
        // Generate alert cards based on metrics and trade data
        const generateAlertCards = (metrics, trades) => {
            const alerts = [];
            
            try {
                // Risk Management Alert - low stop loss usage
                if (metrics.stopLossUsage < 20 && metrics.totalTrades > 5) {
                    alerts.push({
                        type: 'risk',
                        icon: 'alert-triangle',
                        title: 'Risk Management Alert',
                        message: `${metrics.totalTrades - Math.floor(metrics.totalTrades * metrics.stopLossUsage / 100)} trades without stop loss`,
                        recommendation: 'Consider setting stop losses to limit downside risk and protect your capital.'
                    });
                }
                
                // Overtrading Alert - high frequency trading detected
                const tradingDays = metrics.totalTradingDays || 1;
                const tradesPerDay = metrics.totalTrades / tradingDays;
                if (tradesPerDay > 5 && metrics.totalTrades > 20) {
                    alerts.push({
                        type: 'overtrading',
                        icon: 'zap',
                        title: 'Overtrading Alert',
                        message: `Averaging ${tradesPerDay.toFixed(1)} trades per day - burst trading detected`,
                        recommendation: 'Consider reducing trade frequency and focusing on higher quality setups.'
                    });
                }
                
                // Streak Alert - significant consecutive losses
                if (metrics.consecutiveLossStreak >= 5) {
                    alerts.push({
                        type: 'streak',
                        icon: 'trending-down',
                        title: 'Loss Streak Alert',
                        message: `Maximum consecutive losses: ${metrics.consecutiveLossStreak}`,
                        recommendation: 'Review your strategy and consider taking a break to reset your mindset.'
                    });
                } else if (metrics.consecutiveWinStreak >= 8) {
                    alerts.push({
                        type: 'streak',
                        icon: 'trending-up',
                        title: 'Win Streak Alert',
                        message: `Maximum consecutive wins: ${metrics.consecutiveWinStreak}`,
                        recommendation: 'Stay disciplined and avoid overconfidence - maintain your risk management.'
                    });
                }
                
                // Oversize Position Alert
                if (metrics.oversizePositions > 0) {
                    alerts.push({
                        type: 'position-size',
                        icon: 'shield',
                        title: 'Position Size Alert',
                        message: `${metrics.oversizePositions} trades with large position sizes detected`,
                        recommendation: 'Review position sizing to ensure it aligns with your risk tolerance.'
                    });
                }
                
            } catch (error) {
                console.error('AI Analyst: Error generating alert cards', error);
            }
            
            return alerts;
        };
        
        // Display alert cards in the UI
        const displayAlertCards = (alerts) => {
            try {
                const alertContainer = document.getElementById('ai-alert-cards');
                if (!alertContainer) return;
                
                if (alerts.length === 0) {
                    alertContainer.innerHTML = `
                        <div class="p-4 rounded-lg shadow-sm text-center" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <i data-feather="check-circle" class="h-8 w-8 mx-auto mb-2" style="color: #10b981;"></i>
                            <p style="color: var(--text-primary);">No alerts - Your trading looks healthy!</p>
                        </div>
                    `;
                } else {
                    alertContainer.innerHTML = alerts.map(alert => `
                        <div class="p-4 rounded-lg shadow-sm border-l-4 ${getAlertColor(alert.type)}" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                            <div class="flex items-start">
                                <i data-feather="${alert.icon}" class="h-6 w-6 mr-3 mt-1" style="color: ${getAlertIconColor(alert.type)};"></i>
                                <div class="flex-1">
                                    <h4 class="font-semibold mb-1" style="color: var(--text-primary);">${alert.title}</h4>
                                    <p class="text-sm mb-2" style="color: var(--text-secondary);">${alert.message}</p>
                                    <p class="text-sm font-medium" style="color: var(--text-primary);">${alert.recommendation}</p>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
                
                // Replace feather icons
                setTimeout(() => feather.replace(), 100);
            } catch (error) {
                console.error('AI Analyst: Error displaying alert cards', error);
            }
        };
        
        // Get alert card styling based on type
        const getAlertColor = (type) => {
            switch (type) {
                case 'risk': return 'border-red-500';
                case 'overtrading': return 'border-yellow-500';
                case 'streak': return 'border-blue-500';
                case 'position-size': return 'border-orange-500';
                default: return 'border-gray-500';
            }
        };
        
        const getAlertIconColor = (type) => {
            switch (type) {
                case 'risk': return '#ef4444';
                case 'overtrading': return '#eab308';
                case 'streak': return '#3b82f6';
                case 'position-size': return '#f97316';
                default: return '#6b7280';
            }
        };
        
        // Determine trader personality profile based on metrics and trades
        const determineTraderProfile = (metrics, trades) => {
            console.debug('AI Analyst: Determining trader profile...');
            
            try {
                // Profile rules based on trading patterns
                const stopLossUsage = metrics.stopLossUsage || 0;
                const avgHoldingDays = metrics.avgHoldingDays || 0;
                const winRate = metrics.winRate || 0;
                const oversizePositions = metrics.oversizePositions || 0;
                const totalTrades = metrics.totalTrades || 0;
                
                // The Risk-Taker: high % trades without SL or large avg position size vs account
                if (stopLossUsage < 40 || oversizePositions > totalTrades * 0.3) {
                    return {
                        type: 'The Risk-Taker',
                        description: 'You tend to take on significant risks, often trading without stop losses or with large position sizes. This can lead to both big wins and substantial losses.',
                        tips: [
                            'Implement strict stop-loss rules to protect your capital from large drawdowns.',
                            'Reduce position sizes after experiencing losses to preserve trading capital.'
                        ],
                        color: '#ef4444'
                    };
                }
                
                // The Scalper: most trades < 1 day, many small P&L
                else if (avgHoldingDays < 1 && totalTrades > 20) {
                    return {
                        type: 'The Scalper',
                        description: 'You prefer quick, short-term trades with small profit targets. You focus on high-frequency trading with rapid entry and exit.',
                        tips: [
                            'Focus on transaction costs - high frequency trading can erode profits through fees.',
                            'Maintain strict discipline with entry/exit rules to avoid emotional decisions.'
                        ],
                        color: '#f59e0b'
                    };
                }
                
                // The Swinger: average holding > 2 days, P&L from swing trades
                else if (avgHoldingDays > 2 && metrics.totalPnL > 0) {
                    return {
                        type: 'The Swinger',
                        description: 'You prefer holding positions for several days or weeks, capitalizing on medium-term price movements and trends.',
                        tips: [
                            'Use wider stop losses to accommodate normal price fluctuations in swing trades.',
                            'Focus on fundamental analysis alongside technical patterns for better entries.'
                        ],
                        color: '#10b981'
                    };
                }
                
                // The Disciplined Trader: high win-rate and consistent risk rules
                else if (winRate > 65 && stopLossUsage > 70) {
                    return {
                        type: 'The Disciplined Trader',
                        description: 'You maintain consistent risk management practices and achieve steady results through disciplined execution of your trading strategy.',
                        tips: [
                            'Continue your systematic approach - consistency is key to long-term success.',
                            'Consider gradually increasing position sizes as your track record strengthens.'
                        ],
                        color: '#3b82f6'
                    };
                }
                
                // Default: The Learning Trader
                else {
                    return {
                        type: 'The Learning Trader',
                        description: 'You are developing your trading style and building experience. Your patterns show a mix of different approaches as you find what works best.',
                        tips: [
                            'Focus on developing consistent rules for entry, exit, and risk management.',
                            'Keep detailed records to identify which strategies work best for your style.'
                        ],
                        color: '#8b5cf6'
                    };
                }
            } catch (error) {
                console.error('AI Analyst: Error determining trader profile', error);
                return {
                    type: 'Profile Analysis Unavailable',
                    description: 'Unable to determine trading profile. More trade data may be needed.',
                    tips: ['Continue trading and return for updated analysis.'],
                    color: '#6b7280'
                };
            }
        };
        
        // Display trader profile in the UI
        const displayTraderProfile = (profile) => {
            try {
                const profileContainer = document.getElementById('ai-trader-profile');
                if (!profileContainer) return;
                
                profileContainer.innerHTML = `
                    <div class="flex items-center mb-3">
                        <div class="w-4 h-4 rounded-full mr-3" style="background-color: ${profile.color};"></div>
                        <h4 class="text-lg font-semibold" style="color: var(--text-primary);">${profile.type}</h4>
                    </div>
                    <p class="text-sm mb-4" style="color: var(--text-secondary);">${profile.description}</p>
                    <div class="space-y-2">
                        <h5 class="font-medium" style="color: var(--text-primary);">Action Tips:</h5>
                        ${profile.tips.map(tip => `
                            <div class="flex items-start">
                                <i data-feather="arrow-right" class="h-4 w-4 mr-2 mt-0.5" style="color: ${profile.color};"></i>
                                <p class="text-sm" style="color: var(--text-secondary);">${tip}</p>
                            </div>
                        `).join('')}
                    </div>
                `;
                
                // Replace feather icons
                setTimeout(() => feather.replace(), 100);
            } catch (error) {
                console.error('AI Analyst: Error displaying trader profile', error);
            }
        };
        
        // Analyze behavior patterns for psychological insights
        // Debouncing for behavior pattern analysis to prevent jitter
        let behaviorAnalysisTimeout = null;
        
        const analyzeBehaviorPatterns = (trades, metrics) => {
            return new Promise((resolve) => {
                // Clear previous timeout to prevent multiple rapid analysis
                if (behaviorAnalysisTimeout) {
                    clearTimeout(behaviorAnalysisTimeout);
                }
                
                // Debounce analysis by 50ms to prevent jitter
                behaviorAnalysisTimeout = setTimeout(() => {
                    try {
                        console.log('analyzeBehaviorPatterns called - trades count:', trades?.length || 0);
                        const insights = [];
                        
                        // Revenge trading detection - large losses followed by increased position sizes
                        const sortedTrades = [...trades].sort((a, b) => {
                            const dateA = new Date(a.exit_date || a.entry_date);
                            const dateB = new Date(b.exit_date || b.entry_date);
                            return dateA - dateB;
                        });
                        
                        let revengeTradingCount = 0;
                        for (let i = 1; i < sortedTrades.length; i++) {
                    const prevTrade = sortedTrades[i - 1];
                    const currentTrade = sortedTrades[i];
                    
                    try {
                        let prevPnL = 0;
                        if (typeof calculateNetPnl === 'function') {
                            prevPnL = calculateNetPnl(prevTrade);
                        }
                        
                        const prevPositionSize = (parseFloat(prevTrade.entry_price) || 0) * (parseFloat(prevTrade.quantity) || 0);
                        const currentPositionSize = (parseFloat(currentTrade.entry_price) || 0) * (parseFloat(currentTrade.quantity) || 0);
                        
                        // If previous trade was a loss and current position size is significantly larger
                        if (prevPnL < -1000 && currentPositionSize > prevPositionSize * 1.5) {
                            revengeTradingCount++;
                        }
                    } catch (error) {
                        console.warn('AI Analyst: Error analyzing revenge trading pattern', error);
                    }
                        }
                        
                        if (revengeTradingCount > 0) {
                            insights.push({
                                type: 'revenge-trading',
                                title: 'Revenge Trading Pattern',
                                description: `Detected ${revengeTradingCount} instances of increased position size after losses.`,
                                recommendation: 'Take breaks after losses and maintain consistent position sizing.'
                            });
                        }
                        
                        // Confidence trap detection - winning streaks followed by large losses
                        if (metrics.consecutiveWinStreak >= 5 && metrics.maxDrawdown > 5000) {
                            insights.push({
                                type: 'confidence-trap',
                                title: 'Overconfidence Pattern',
                                description: 'Long winning streaks may be leading to overconfidence and larger losses.',
                                recommendation: 'Maintain discipline even during winning streaks. Stick to your risk management rules.'
                            });
                        }
                        
                        // Mood-based insights based on win rate and consistency
                        if (metrics.winRate < 40 && metrics.totalTrades > 10) {
                            insights.push({
                                type: 'low-confidence',
                                title: 'Low Confidence Pattern',
                                description: 'Low win rate may indicate lack of confidence or poor entry timing.',
                                recommendation: 'Review your entry criteria and consider paper trading to build confidence.'
                            });
                        } else if (metrics.winRate > 80 && metrics.avgWin < metrics.avgLoss) {
                            insights.push({
                                type: 'small-wins',
                                title: 'Risk-Averse Pattern',
                                description: 'High win rate but small average wins suggest you may be cutting profits too early.',
                                recommendation: 'Let your winners run longer while maintaining your stop losses.'
                            });
                        }
                        
                        // Emotional Volatility Analysis
                        try {
                            const closedTrades = trades.filter(t => t.exit_date && t.exit_price);
                            console.log('AI Analyst: Analyzing emotional volatility with', closedTrades.length, 'closed trades');
                            const emotionalVolatility = calculateEmotionalVolatility(closedTrades);
                            console.log('AI Analyst: Emotional volatility result:', emotionalVolatility);
                            
                            // Always add emotional volatility insight if we have any data
                            if (emotionalVolatility.interpretation && emotionalVolatility.interpretation !== 'Error') {
                                insights.push({
                                    type: 'emotional-volatility',
                                    title: 'Emotional Volatility',
                                    description: emotionalVolatility.interpretation,
                                    recommendation: emotionalVolatility.recommendation,
                                    volatilityData: emotionalVolatility.volatilityData
                                });
                            }
                        } catch (error) {
                            console.warn('AI Analyst: Error calculating emotional volatility', error);
                        }
                        
                        // Stress Index Analysis (Performance Under Volatility)
                        try {
                            const closedTrades = trades.filter(t => t.exit_date && t.exit_price);
                            console.log('AI Analyst: Analyzing stress index with', closedTrades.length, 'closed trades');
                            
                            // Get starting balance from ledger
                            const startingBalance = appState.ledger && appState.ledger.length > 0 ? 
                                appState.ledger.filter(l => l.type === 'Deposit').reduce((sum, l) => sum + (parseFloat(l.amount) || 0), 0) : 0;
                            
                            const stressIndexData = calculateStressIndex(closedTrades, startingBalance);
                            console.log('AI Analyst: Stress index result:', stressIndexData);
                            
                            // Add stress index insight if we have valid data
                            if (stressIndexData.interpretation && stressIndexData.interpretation !== 'Error' && stressIndexData.interpretation !== 'No Data') {
                                const highVol = stressIndexData.highVolatility;
                                const lowVol = stressIndexData.lowVolatility;
                                
                                insights.push({
                                    type: 'stress-index',
                                    title: 'Performance Under Stress',
                                    description: `High Volatility Days: Avg P&L: ₹${highVol.avgPnL.toFixed(0)}, Win Rate: ${highVol.winRate.toFixed(1)}% (${highVol.tradeCount} trades) | Low Volatility Days: Avg P&L: ₹${lowVol.avgPnL.toFixed(0)}, Win Rate: ${lowVol.winRate.toFixed(1)}% (${lowVol.tradeCount} trades)`,
                                    recommendation: stressIndexData.interpretation,
                                    stressData: stressIndexData
                                });
                            }
                        } catch (error) {
                            console.warn('AI Analyst: Error calculating stress index', error);
                        }
                        
                        resolve(insights);
                    } catch (error) {
                        console.error('AI Analyst: Error analyzing behavior patterns', error);
                        resolve([]); // Return empty array on error
                    }
                }, 50); // 50ms debounce delay
            });
        };
        
        // Display behavior insights in the UI
        // Debouncing for behavior insights display to prevent jitter
        let behaviorInsightsTimeout = null;
        
        const displayBehaviorInsights = (insights) => {
            // Clear previous timeout to prevent multiple rapid renders
            if (behaviorInsightsTimeout) {
                clearTimeout(behaviorInsightsTimeout);
            }
            
            // Debounce display by 50ms to prevent jitter
            behaviorInsightsTimeout = setTimeout(() => {
                try {
                    console.log('displayBehaviorInsights called with insights count:', insights?.length || 0);
                    const behaviorContainer = document.getElementById('ai-behavior-insights');
                    if (!behaviorContainer) {
                        console.log('Behavior container not found');
                        return;
                    }
                
                // Filter out emotional-volatility and stress-index insights from behavior card
                const behaviorInsights = insights.filter(insight => 
                    insight.type !== 'emotional-volatility' && insight.type !== 'stress-index'
                );
                
                if (behaviorInsights.length === 0) {
                    behaviorContainer.innerHTML = `
                        <div class="text-center py-4">
                            <i data-feather="smile" class="h-8 w-8 mx-auto mb-2" style="color: #10b981;"></i>
                            <p style="color: var(--text-primary);">No concerning behavioral patterns detected.</p>
                            <p class="text-sm mt-1" style="color: var(--text-secondary);">Your trading psychology appears healthy!</p>
                        </div>
                    `;
                } else {
                    behaviorContainer.innerHTML = behaviorInsights.map(insight => {
                        // Default insight display for behavior insights
                        return `
                            <div class="p-3 rounded-md border-l-4 border-blue-400" style="background-color: var(--bg-secondary);">
                                <h5 class="font-medium mb-1" style="color: var(--text-primary);">${insight.title}</h5>
                                <p class="text-sm mb-2" style="color: var(--text-secondary);">${insight.description}</p>
                                <p class="text-sm font-medium" style="color: var(--text-primary);">${insight.recommendation}</p>
                            </div>
                        `;
                    }).join('');
                }
                
                // Replace feather icons
                setTimeout(() => feather.replace(), 100);
                } catch (error) {
                    console.error('AI Analyst: Error displaying behavior insights', error);
                }
            }, 50); // 50ms debounce delay
        };
        
        // Display emotional volatility insights
        const displayEmotionalVolatilityInsights = (insights) => {
            try {
                console.log('displayEmotionalVolatilityInsights called with insights count:', insights?.length || 0);
                const emotionalContainer = document.getElementById('ai-emotional-volatility');
                if (!emotionalContainer) {
                    console.log('Emotional volatility container not found');
                    return;
                }
                
                // Filter for emotional volatility insights only
                const emotionalInsights = insights.filter(insight => insight.type === 'emotional-volatility');
                
                if (emotionalInsights.length === 0) {
                    emotionalContainer.innerHTML = `
                        <div class="text-center py-4">
                            <i data-feather="heart" class="h-8 w-8 mx-auto mb-2" style="color: #10b981;"></i>
                            <p style="color: var(--text-primary);">No emotional volatility patterns detected.</p>
                            <p class="text-sm mt-1" style="color: var(--text-secondary);">Your emotional trading patterns appear stable!</p>
                        </div>
                    `;
                } else {
                    emotionalContainer.innerHTML = emotionalInsights.map(insight => {
                        let volatilityDetails = '';
                        if (insight.volatilityData && Object.keys(insight.volatilityData).length > 0) {
                            const volatilityEntries = Object.entries(insight.volatilityData);
                            
                            // Sort by performance (average P&L) to show best emotions first
                            const sortedEntries = volatilityEntries.sort((a, b) => b[1].avgPnL - a[1].avgPnL);
                            
                            volatilityDetails = sortedEntries.map(([emotion, data]) => {
                                const performanceColor = data.avgPnL > 0 ? '#10b981' : '#ef4444'; // Green for positive, red for negative
                                const performanceIcon = data.avgPnL > 0 ? '↗' : '↘';
                                
                                return `<span class="inline-block px-2 py-1 rounded text-xs mr-1 mb-1" style="background-color: var(--bg-primary); color: var(--text-secondary); border-left: 3px solid ${performanceColor};">
                                    ${emotion}: ${performanceIcon} ₹${data.avgPnL.toFixed(0)} avg (${data.winRate.toFixed(0)}% wins, ${data.count} trades)
                                </span>`;
                            }).join('');
                        }
                        
                        return `
                            <div class="p-3 rounded-md border-l-4 border-purple-400" style="background-color: var(--bg-secondary);">
                                <h5 class="font-medium mb-1" style="color: var(--text-primary);">${insight.title}</h5>
                                <p class="text-sm mb-2" style="color: var(--text-secondary);">${insight.description}</p>
                                <p class="text-sm font-medium mb-2" style="color: var(--text-primary);">${insight.recommendation}</p>
                                ${volatilityDetails ? `<div class="mt-2">${volatilityDetails}</div>` : ''}
                            </div>
                        `;
                    }).join('');
                }
                
                // Replace feather icons
                setTimeout(() => feather.replace(), 100);
            } catch (error) {
                console.error('AI Analyst: Error displaying emotional volatility insights', error);
            }
        };
        
        // Display performance under stress insights
        const displayPerformanceUnderStressInsights = (insights) => {
            try {
                console.log('displayPerformanceUnderStressInsights called with insights count:', insights?.length || 0);
                const stressContainer = document.getElementById('ai-performance-stress');
                if (!stressContainer) {
                    console.log('Performance under stress container not found');
                    return;
                }
                
                // Filter for stress index insights only
                const stressInsights = insights.filter(insight => insight.type === 'stress-index');
                
                if (stressInsights.length === 0) {
                    stressContainer.innerHTML = `
                        <div class="text-center py-4">
                            <i data-feather="trending-up" class="h-8 w-8 mx-auto mb-2" style="color: #10b981;"></i>
                            <p style="color: var(--text-primary);">No stress performance patterns detected.</p>
                            <p class="text-sm mt-1" style="color: var(--text-secondary);">Your performance under stress appears consistent!</p>
                        </div>
                    `;
                } else {
                    stressContainer.innerHTML = stressInsights.map(insight => {
                        let stressDetails = '';
                        if (insight.stressData) {
                            const highVol = insight.stressData.highVolatility;
                            const lowVol = insight.stressData.lowVolatility;
                            
                            // Enhanced color coding and styling
                            const highVolColor = highVol.avgPnL > 0 ? '#10b981' : '#ef4444';
                            const lowVolColor = lowVol.avgPnL > 0 ? '#10b981' : '#ef4444';
                            const highVolBgColor = highVol.avgPnL > 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                            const lowVolBgColor = lowVol.avgPnL > 0 ? 'rgba(16, 185, 129, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                            const highVolIcon = highVol.avgPnL > 0 ? '📈' : '📉';
                            const lowVolIcon = lowVol.avgPnL > 0 ? '📈' : '📉';
                            
                            // Calculate performance difference for visual emphasis
                            const performanceDiff = highVol.avgPnL - lowVol.avgPnL;
                            const performanceDiffPercent = lowVol.avgPnL !== 0 ? ((performanceDiff / Math.abs(lowVol.avgPnL)) * 100) : 0;
                            
                            stressDetails = `
                                <div class="mt-4">
                                    <!-- Performance Summary -->
                                    <div class="mb-2 p-1.5 rounded-lg" style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.1)); border: 1px solid rgba(59, 130, 246, 0.2);">
                                        <div class="flex items-center justify-between mb-1">
                                            <h6 class="font-semibold text-sm" style="color: var(--text-primary);">Performance Comparison</h6>
                                            <span class="text-xs px-2 py-1 rounded-full" style="background-color: ${performanceDiff > 0 ? 'rgba(16, 185, 129, 0.2)' : 'rgba(239, 68, 68, 0.2)'}; color: ${performanceDiff > 0 ? '#10b981' : '#ef4444'};">
                                                ${performanceDiff > 0 ? 'Better under stress' : 'Worse under stress'}
                                            </span>
                                        </div>
                                        <div class="text-xs" style="color: var(--text-secondary);">
                                            Difference: ₹${performanceDiff.toFixed(0)} (${performanceDiffPercent.toFixed(1)}%)
                                        </div>
                                    </div>
                                    
                                    <!-- Detailed Comparison Cards -->
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        <!-- High Volatility Card -->
                                        <div class="p-2 rounded-xl border-2 transition-all duration-200 hover:shadow-lg" style="border-color: ${highVolColor}; background: ${highVolBgColor};">
                                            <div class="flex items-center justify-between mb-1">
                                                <div class="flex items-center">
                                                    <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${highVolColor};"></div>
                                                    <h6 class="font-semibold text-sm" style="color: var(--text-primary);">High Volatility Days</h6>
                                                </div>
                                                <span class="text-lg">${highVolIcon}</span>
                                            </div>
                                            
                                            <div class="space-y-1">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Average P&L</span>
                                                    <span class="text-sm font-bold" style="color: ${highVolColor};">
                                                        ₹${highVol.avgPnL.toFixed(0)}
                                                    </span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Win Rate</span>
                                                    <span class="text-sm font-bold" style="color: var(--text-primary);">
                                                        ${highVol.winRate.toFixed(1)}%
                                                    </span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Trades</span>
                                                    <span class="text-xs px-2 py-1 rounded-full" style="background-color: var(--bg-primary); color: var(--text-secondary);">
                                                        ${highVol.tradeCount}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Low Volatility Card -->
                                        <div class="p-2 rounded-xl border-2 transition-all duration-200 hover:shadow-lg" style="border-color: ${lowVolColor}; background: ${lowVolBgColor};">
                                            <div class="flex items-center justify-between mb-1">
                                                <div class="flex items-center">
                                                    <div class="w-3 h-3 rounded-full mr-2" style="background-color: ${lowVolColor};"></div>
                                                    <h6 class="font-semibold text-sm" style="color: var(--text-primary);">Low Volatility Days</h6>
                                                </div>
                                                <span class="text-lg">${lowVolIcon}</span>
                                            </div>
                                            
                                            <div class="space-y-1">
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Average P&L</span>
                                                    <span class="text-sm font-bold" style="color: ${lowVolColor};">
                                                        ₹${lowVol.avgPnL.toFixed(0)}
                                                    </span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Win Rate</span>
                                                    <span class="text-sm font-bold" style="color: var(--text-primary);">
                                                        ${lowVol.winRate.toFixed(1)}%
                                                    </span>
                                                </div>
                                                <div class="flex justify-between items-center">
                                                    <span class="text-xs font-medium" style="color: var(--text-secondary);">Trades</span>
                                                    <span class="text-xs px-2 py-1 rounded-full" style="background-color: var(--bg-primary); color: var(--text-secondary);">
                                                        ${lowVol.tradeCount}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                        
                        return `
                            <div class="p-4 rounded-xl border-l-4 transition-all duration-200 hover:shadow-md" style="border-left-color: #f97316; background: linear-gradient(135deg, var(--bg-secondary), rgba(249, 115, 22, 0.05));">
                                <div class="flex items-center mb-3">
                                    <div class="w-8 h-8 rounded-lg flex items-center justify-center mr-3" style="background: linear-gradient(135deg, #f97316, #ea580c);">
                                        <i data-feather="trending-up" class="h-4 w-4 text-white"></i>
                                    </div>
                                    <div>
                                        <h5 class="font-semibold text-base" style="color: var(--text-primary);">${insight.title}</h5>
                                        <p class="text-xs" style="color: var(--text-secondary);">Performance under market stress</p>
                                    </div>
                                </div>
                                
                                
                                <div class="p-3 rounded-lg border-l-4" style="border-left-color: #3b82f6; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(147, 51, 234, 0.05));">
                                    <p class="text-sm font-medium leading-relaxed" style="color: var(--text-primary);">${insight.recommendation}</p>
                                </div>
                                
                                ${stressDetails}
                            </div>
                        `;
                    }).join('');
                }
                
                // Replace feather icons
                setTimeout(() => feather.replace(), 100);
            } catch (error) {
                console.error('AI Analyst: Error displaying performance under stress insights', error);
            }
        };
        
        // Update performance sections (Top Winners/Losers)
        const updatePerformanceSections = (trades, metrics) => {
            try {
                // Get closed trades with P&L
                const closedTrades = trades.filter(t => {
                    // Check if trade has exit data
                    if (!t.exit_date || !t.exit_price) return false;
                    
                    // Check if it's fully closed or partial exit
                    const isClosed = !t.exit_quantity || t.exit_quantity >= t.quantity;
                    const isPartialExit = t.exit_quantity && t.exit_quantity < t.quantity;
                    
                    return isClosed || isPartialExit;
                });
                
                // If no closed trades, use all trades for basic analysis
                const tradesToAnalyze = closedTrades.length > 0 ? closedTrades : trades;
                
                const tradesWithPnL = tradesToAnalyze.map(trade => {
                    let pnl = 0;
                    try {
                        if (typeof calculateNetPnl === 'function') {
                            pnl = calculateNetPnl(trade);
                        } else {
                            const entryPrice = parseFloat(trade.entry_price) || 0;
                            const exitPrice = parseFloat(trade.exit_price) || 0;
                            const quantity = parseFloat(trade.quantity) || 0;
                            const direction = trade.direction === 'Short' ? -1 : 1;
                            pnl = (exitPrice - entryPrice) * quantity * direction;
                        }
                    } catch (error) {
                        console.warn('AI Analyst: Error calculating P&L for performance section', trade.id, error);
                    }
                    return { ...trade, pnl };
                });
                
                
            } catch (error) {
                console.error('AI Analyst: Error updating performance sections', error);
            }
        };
        
        // Update risk discipline panel
        const updateRiskDisciplinePanel = (metrics, trades) => {
            try {
                // Stop Loss Usage
                const stopLossUsageEl = document.getElementById('ai-stop-loss-usage');
                if (stopLossUsageEl) {
                    stopLossUsageEl.textContent = metrics.totalTrades > 0 ? `${metrics.stopLossUsage.toFixed(1)}%` : 'N/A';
                }
                
                // Average Stop Loss
                const avgStopLossEl = document.getElementById('ai-avg-stop-loss');
                if (avgStopLossEl) {
                    avgStopLossEl.textContent = metrics.avgStopLoss > 0 ? window.utils.formatCurrency(metrics.avgStopLoss) : 'N/A';
                }
                
                // Oversize Positions
                const oversizePositionsEl = document.getElementById('ai-oversize-positions');
                if (oversizePositionsEl) {
                    oversizePositionsEl.textContent = metrics.oversizePositions || 0;
                }
                
                // Capital Utilization
                const capitalUtilizationEl = document.getElementById('ai-capital-utilization');
                if (capitalUtilizationEl) {
                    const utilization = metrics.capitalUtilization || 0;
                    capitalUtilizationEl.textContent = `${utilization.toFixed(1)}%`;
                    
                    // Add color coding based on utilization level
                    if (utilization > 20) {
                        capitalUtilizationEl.style.color = '#ef4444'; // Red for high risk
                    } else if (utilization > 10) {
                        capitalUtilizationEl.style.color = '#f59e0b'; // Orange for moderate
                    } else if (utilization > 5) {
                        capitalUtilizationEl.style.color = '#10b981'; // Green for conservative
                    } else if (utilization > 0) {
                        capitalUtilizationEl.style.color = '#059669'; // Darker green for very conservative
                    } else {
                        capitalUtilizationEl.style.color = 'var(--text-primary)'; // Default for no data
                    }
                }
                
            } catch (error) {
                console.error('AI Analyst: Error updating risk discipline panel', error);
            }
        };
        
        // Generate AI-style recommendations
        const generateAIRecommendations = (metrics, trades, traderProfile) => {
            const recommendations = [];
            
            try {
                // Risk-reward ratio recommendation
                if (metrics.riskRewardRatio < 1.5 && metrics.totalTrades > 5) {
                    recommendations.push(`Your average loss is ${(metrics.avgLoss / metrics.avgWin).toFixed(1)}× your average win — consider tightening stops or letting winners run longer.`);
                }
                
                // Win rate vs risk-reward balance
                if (metrics.winRate < 50 && metrics.riskRewardRatio < 2) {
                    recommendations.push('With a lower win rate, focus on achieving a risk-reward ratio above 2:1 to maintain profitability.');
                }
                
                // Asset concentration analysis
                const assetCounts = {};
                trades.forEach(trade => {
                    const asset = trade.asset || 'Unknown';
                    assetCounts[asset] = (assetCounts[asset] || 0) + 1;
                });
                
                const topAsset = Object.keys(assetCounts).reduce((a, b) => assetCounts[a] > assetCounts[b] ? a : b, '');
                const topAssetPercentage = (assetCounts[topAsset] / trades.length) * 100;
                
                if (topAssetPercentage > 60 && trades.length > 10) {
                    recommendations.push(`${topAssetPercentage.toFixed(0)}% of your trades are in ${topAsset} — consider diversifying across different assets to reduce concentration risk.`);
                }
                
                // Holding period recommendation based on profile
                if (traderProfile.type === 'The Scalper' && metrics.avgWin < 500) {
                    recommendations.push('As a scalper, ensure your average wins cover transaction costs — consider targeting slightly higher profit margins.');
                } else if (traderProfile.type === 'The Swinger' && metrics.avgHoldingDays < 1) {
                    recommendations.push('Your profile suggests swing trading, but your holding periods are short — consider longer-term setups for better results.');
                }
                
                // Ensure we have at least 4 recommendations by adding general ones
                while (recommendations.length < 4) {
                    const generalRecommendations = [
                        'Maintain a consistent trading journal to track what works and what doesn\'t in your strategy.',
                        'Review your trades weekly to identify patterns and areas for improvement.',
                        'Consider position sizing based on volatility — reduce size for more volatile assets.',
                        'Set realistic daily and monthly P&L targets to maintain consistent performance expectations.'
                    ];
                    
                    const unusedRecommendations = generalRecommendations.filter(rec => !recommendations.includes(rec));
                    if (unusedRecommendations.length > 0) {
                        recommendations.push(unusedRecommendations[0]);
                    } else {
                        break;
                    }
                }
                
            } catch (error) {
                console.error('AI Analyst: Error generating recommendations', error);
                recommendations.push('Continue developing your trading skills and maintain disciplined risk management.');
            }
            
            return recommendations.slice(0, 4); // Limit to 4 recommendations
        };
        
        // Display AI recommendations
        const displayAIRecommendations = (recommendations) => {
            try {
                const recommendationsContainer = document.getElementById('ai-recommendations');
                if (!recommendationsContainer) return;
                
                recommendationsContainer.innerHTML = recommendations.map((rec, index) => `
                    <div class="flex items-start">
                        <div class="flex-shrink-0 w-6 h-6 rounded-full flex items-center justify-center mr-3" style="background-color: var(--bg-secondary);">
                            <span class="text-sm font-medium" style="color: var(--text-primary);">${index + 1}</span>
                        </div>
                        <p class="text-sm" style="color: var(--text-secondary);">${rec}</p>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('AI Analyst: Error displaying recommendations', error);
            }
        };
        
        // Generate Adaptive Risk Limit Suggestion
        const generateRiskSuggestion = (metrics) => {
            try {
                console.log('generateRiskSuggestion called with metrics:', metrics);
                
                if (!metrics) {
                    return {
                        type: 'maintain',
                        message: '💡 Maintain: Risk data not available. Continue to adhere to your risk limits.',
                        style: 'neutral',
                        icon: 'lightbulb'
                    };
                }

                const { consecutiveLossStreak, winRate } = metrics;
                
                // Check for significant losing streak
                if (consecutiveLossStreak >= 3) {
                    return {
                        type: 'alert',
                        message: '⚠️ Risk Alert: You are on a significant losing streak. Consider reducing your risk per trade by 30-50% until you achieve a winning trade to protect capital and mental state.',
                        style: 'red',
                        icon: 'alert-triangle'
                    };
                }
                
                // Check for strong performance with no recent losses
                if (consecutiveLossStreak === 0 && winRate > 60) {
                    return {
                        type: 'confidence',
                        message: '✅ Risk Confidence: Your performance is strong. Maintain current risk management. Consider slight scaling if your system allows.',
                        style: 'green',
                        icon: 'check-circle'
                    };
                }
                
                // Default balanced approach
                return {
                    type: 'maintain',
                    message: '💡 Maintain: Your risk approach seems balanced. Continue to adhere to your risk limits.',
                    style: 'neutral',
                    icon: 'lightbulb'
                };
                
            } catch (error) {
                console.error('Error generating risk suggestion:', error);
                return {
                    type: 'maintain',
                    message: '💡 Maintain: Risk analysis unavailable. Continue to adhere to your risk limits.',
                    style: 'neutral',
                    icon: 'lightbulb'
                };
            }
        };
        
        // Display Adaptive Risk Suggestion
        const displayRiskSuggestion = (suggestion) => {
            try {
                const riskSuggestionEl = document.getElementById('ai-adaptive-risk-recommendation');
                if (!riskSuggestionEl) return;
                
                // Determine styling based on suggestion type
                let bgColor, borderColor, textColor, iconColor;
                
                switch (suggestion.style) {
                    case 'red':
                        bgColor = 'rgba(239, 68, 68, 0.1)';
                        borderColor = '#ef4444';
                        textColor = '#dc2626';
                        iconColor = '#ef4444';
                        break;
                    case 'green':
                        bgColor = 'rgba(16, 185, 129, 0.1)';
                        borderColor = '#10b981';
                        textColor = '#059669';
                        iconColor = '#10b981';
                        break;
                    default: // neutral
                        bgColor = 'rgba(59, 130, 246, 0.1)';
                        borderColor = '#3b82f6';
                        textColor = '#1d4ed8';
                        iconColor = '#3b82f6';
                        break;
                }
                
                riskSuggestionEl.innerHTML = `
                    <div class="p-4 rounded-lg border-l-4" style="background-color: ${bgColor}; border-left-color: ${borderColor};">
                        <div class="flex items-start">
                            <div class="flex-shrink-0 mr-3">
                                <i data-feather="${suggestion.icon}" class="h-5 w-5" style="color: ${iconColor};"></i>
                            </div>
                            <div class="flex-1">
                                <h4 class="font-semibold mb-1" style="color: ${textColor};">Adaptive Risk Suggestion</h4>
                                <p class="text-sm" style="color: var(--text-secondary);">${suggestion.message}</p>
                            </div>
                        </div>
                    </div>
                `;
                
                // Re-initialize Feather icons for the new content
                if (typeof feather !== 'undefined') {
                    feather.replace();
                }
                
            } catch (error) {
                console.error('AI Analyst: Error displaying risk suggestion', error);
            }
        };
        
        // Update consistency and growth stats
        const updateConsistencyAndGrowth = (metrics, trades) => {
            try {
                // Consistency Score (profitable days percentage)
                const consistencyScore = metrics.totalTradingDays > 0 ? 
                    (metrics.profitableDays / metrics.totalTradingDays) * 100 : 0;
                
                const consistencyEl = document.getElementById('ai-consistency-score');
                if (consistencyEl) {
                    consistencyEl.textContent = `${consistencyScore.toFixed(0)}%`;
                }
                
                // Growth Projection (simplified monthly projection based on recent performance)
                let monthlyGrowthProjection = 0;
                if (metrics.totalTrades > 5 && metrics.totalTradingDays > 0) {
                    const dailyAvgPnL = metrics.totalPnL / metrics.totalTradingDays;
                    const tradingDaysPerMonth = 22; // Approximate trading days per month
                    monthlyGrowthProjection = dailyAvgPnL * tradingDaysPerMonth;
                }
                
                const growthProjectionEl = document.getElementById('ai-growth-projection');
                if (growthProjectionEl) {
                    growthProjectionEl.textContent = window.utils.formatCurrency(monthlyGrowthProjection);
                }
                
            } catch (error) {
                console.error('AI Analyst: Error updating consistency and growth stats', error);
            }
        };
        
        // Update summary highlight
        const updateSummaryHighlight = (metrics, traderProfile) => {
            try {
                const summaryEl = document.getElementById('ai-summary-highlight');
                if (!summaryEl) return;
                
                let highlight = '';
                
                if (metrics.totalTrades === 0) {
                    highlight = 'Start trading to unlock personalized insights and recommendations.';
                } else if (metrics.winRate > 70 && metrics.totalPnL > 0) {
                    highlight = `Excellent performance! ${metrics.winRate.toFixed(0)}% win rate with ${window.utils.formatCurrency(metrics.totalPnL)} total profit.`;
                } else if (metrics.totalPnL > 0) {
                    highlight = `Profitable trading with ${window.utils.formatCurrency(metrics.totalPnL)} net gain. Focus on consistency.`;
                } else if (metrics.winRate > 60) {
                    highlight = `Good win rate at ${metrics.winRate.toFixed(0)}%. Work on letting winners run to improve profitability.`;
                } else {
                    highlight = `${traderProfile.type} profile identified. Focus on risk management and strategy refinement.`;
                }
                
                summaryEl.textContent = highlight;
                
            } catch (error) {
                console.error('AI Analyst: Error updating summary highlight', error);
            }
        };



        const createPartialExitDetailsModal = () => {
            const modalHTML = `
                <div id="partial-exit-details-modal" class="modal-overlay hidden">
                    <div class="modal-content max-w-4xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); padding: 1.5rem;">
                        <!-- Header -->
                        <div class="flex justify-between items-center mb-6 pb-4 border-b" style="border-color: var(--border-color);">
                            <div class="flex items-center space-x-3">
                                <h2 class="text-2xl font-bold" style="color: var(--text-primary);">Partial Exit Breakdown</h2>
                                <span id="partial-exit-symbol" class="px-3 py-1 text-sm font-semibold rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);"></span>
                            </div>
                            <div class="flex items-center space-x-3">
                                <span id="partial-exit-count" class="px-2 py-1 text-xs font-semibold rounded-full" style="background-color: var(--bg-secondary); color: var(--text-primary);">0 Exits</span>
                                <button id="partial-exit-close" class="p-2 rounded-full hover:bg-gray-100" style="color: var(--text-secondary);">
                                    <i data-feather="x" class="h-5 w-5"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Summary Section -->
                        <div class="mb-6 p-4 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Total Exited</p>
                                    <p id="partial-exit-total-exited" class="text-lg font-bold" style="color: var(--text-primary);">0 units</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Remaining</p>
                                    <p id="partial-exit-remaining" class="text-lg font-bold" style="color: var(--text-primary);">0 units</p>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Average Selling Price</p>
                                    <p id="partial-exit-avg-price" class="text-lg font-bold" style="color: var(--text-primary);">₹0.00</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Average P&L per Unit</p>
                                    <p id="partial-exit-avg-pnl" class="text-lg font-bold" style="color: var(--text-primary);">₹0.00</p>
                                </div>
                            </div>
                            <div class="grid grid-cols-3 gap-4">
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Total Brokerage</p>
                                    <p id="partial-exit-total-brokerage" class="text-lg font-bold" style="color: var(--text-primary);">₹0.00</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Total Charges</p>
                                    <p id="partial-exit-total-charges" class="text-lg font-bold" style="color: var(--text-primary);">₹0.00</p>
                                </div>
                                <div class="text-center">
                                    <p class="text-sm font-medium mb-1" style="color: var(--text-secondary);">Cumulative P&L</p>
                                    <p id="partial-exit-cumulative-pnl" class="text-lg font-bold" style="color: var(--text-primary);">₹0.00</p>
                                </div>
                            </div>
                        </div>

                        <!-- Exits Table -->
                        <div class="rounded-lg overflow-hidden" style="border: 1px solid var(--border-color);">
                            <div class="overflow-x-auto">
                                <table class="w-full">
                                    <thead style="background-color: var(--bg-secondary);">
                                        <tr>
                                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider" style="color: var(--text-secondary);">Exit Date</th>
                                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider" style="color: var(--text-secondary);">Price</th>
                                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider" style="color: var(--text-secondary);">Quantity</th>
                                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider" style="color: var(--text-secondary);">P&L</th>
                                            <th class="px-4 py-3 text-left text-xs font-medium uppercase tracking-wider" style="color: var(--text-secondary);">P&L %</th>
                                        </tr>
                                    </thead>
                                    <tbody id="partial-exit-table-body" class="divide-y" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                        <!-- Exit rows will be populated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex justify-end mt-6 pt-4 border-t" style="border-color: var(--border-color);">
                            <button id="partial-exit-close-btn" class="px-4 py-2 text-sm font-medium rounded-md hover:bg-gray-600" style="background-color: var(--text-primary); color: var(--bg-primary);">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            
            // Add event listeners
            document.getElementById('partial-exit-close')?.addEventListener('click', () => {
                document.getElementById('partial-exit-details-modal').classList.add('hidden');
            });
            document.getElementById('partial-exit-close-btn')?.addEventListener('click', () => {
                document.getElementById('partial-exit-details-modal').classList.add('hidden');
            });
            document.getElementById('partial-exit-details-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'partial-exit-details-modal') {
                    document.getElementById('partial-exit-details-modal').classList.add('hidden');
                }
            });
        };

        // Date Filter Functionality (Optimized for Speed)
        document.addEventListener('DOMContentLoaded', function() {
            


            // Function to refresh dashboard data (simplified - shows all data)
            function refreshDashboardData() {
                // Simply show all trades without filtering
                updateDashboardStats(appState.trades);
                updateCharts(appState.trades);
                updateTopTradesWithFilter(appState.trades);
                updateOpenPositionsWithFilter(appState.trades);
            }


            // Function to update dashboard stats
            function updateDashboardStats(filteredTrades) {
                // Only consider closed trades (with exit_date and exit_price)
                const closedTrades = filteredTrades.filter(t => t.exit_price && t.exit_date);
                
                // Calculate stats from filtered trades
                let netPnl = 0, grossProfit = 0, grossLoss = 0, totalNetProfit = 0, totalNetLoss = 0, wins = 0, losses = 0;
                
                closedTrades.forEach(trade => {
                    const netPnlValue = calculateNetPnl(trade);
                    netPnl += netPnlValue;
                    
                    // Calculate gross P&L (before charges)
                    const exitPrice = parseFloat(trade.exit_price);
                    const entryPrice = parseFloat(trade.entry_price);
                    const quantity = parseFloat(trade.quantity);
                    const isShort = trade.trade_type === 'Short' || trade.direction === 'Short';
                    const grossPnlValue = (exitPrice - entryPrice) * quantity * (isShort ? -1 : 1);
                    
                    // Use NET P&L to determine if it's a win or loss
                    if (netPnlValue > 0) {
                        wins++;
                        grossProfit += netPnlValue;  // Use net P&L consistently
                        totalNetProfit += netPnlValue;
                    } else if (netPnlValue < 0) {
                        losses++;
                        grossLoss += Math.abs(netPnlValue);  // Use net P&L consistently
                        totalNetLoss += Math.abs(netPnlValue);
                    }
                });
                
                const totalTrades = closedTrades.length;
                const winRate = totalTrades > 0 ? (wins / totalTrades * 100).toFixed(1) : 0;
                const profitFactor = grossLoss > 0 ? (grossProfit / grossLoss).toFixed(2) : (grossProfit > 0 ? '∞' : '0.00');
                const avgWin = wins > 0 ? (grossProfit / wins).toFixed(2) : '0.00';
                const avgLoss = losses > 0 ? (grossLoss / losses).toFixed(2) : '0.00';
                // Avg win/loss ratio: ratio of average win size to average loss size
                const avgWinLoss = avgLoss > 0 ? (avgWin / avgLoss).toFixed(2) : (avgWin > 0 ? '∞' : '0.00');

                // Update DOM elements
                const netPnlEl = document.getElementById('db-net-pnl');
                if (netPnlEl) {
                    netPnlEl.textContent = window.utils.formatCurrency(netPnl);
                    netPnlEl.className = `text-2xl font-bold mt-2 ${netPnl >= 0 ? 'text-green-500' : 'text-red-500'}`;
                }
                
                // Calculate and update Net P&L percentage
                const ledger = appState.ledger || [];
                const totalDeposits = ledger.filter(l => l.type === 'Deposit').reduce((s, l) => s + (l.amount || 0), 0);
                const netPnlPercentage = totalDeposits > 0 ? (netPnl / totalDeposits) * 100 : 0;
                const netPnlPercentageEl = document.getElementById('db-net-pnl-percentage');
                if (netPnlPercentageEl) {
                    netPnlPercentageEl.textContent = `${netPnlPercentage >= 0 ? '+' : ''}${netPnlPercentage.toFixed(2)}%`;
                    netPnlPercentageEl.className = 'text-xs font-bold';
                    netPnlPercentageEl.style.color = netPnlPercentage >= 0 ? '#10b981' : '#ef4444'; // Green or Red
                }
                
                const totalTradesEl = document.getElementById('db-total-trades');
                if (totalTradesEl) totalTradesEl.textContent = `${totalTrades} trades`;
                
                const winRateEl = document.getElementById('db-win-rate');
                if (winRateEl) winRateEl.textContent = `${winRate}%`;
                
                const wonTradesEl = document.getElementById('db-won-trades');
                if (wonTradesEl) wonTradesEl.textContent = `${wins} won`;
                
                const lostTradesEl = document.getElementById('db-lost-trades');
                if (lostTradesEl) lostTradesEl.textContent = `${losses} lost`;
                
                const profitFactorEl = document.getElementById('db-profit-factor');
                if (profitFactorEl) profitFactorEl.textContent = profitFactor;
                
                const profitFactorRatioEl = document.getElementById('profit-factor-ratio');
                if (profitFactorRatioEl) profitFactorRatioEl.textContent = profitFactor;
                
                const avgWinLossEl = document.getElementById('db-avg-win-loss');
                if (avgWinLossEl) avgWinLossEl.textContent = avgWinLoss;
                
                const avgWinEl = document.getElementById('db-avg-win');
                if (avgWinEl) avgWinEl.textContent = `+${window.utils.formatCurrency(avgWin)}`;
                
                const avgLossEl = document.getElementById('db-avg-loss');
                if (avgLossEl) avgLossEl.textContent = `-${window.utils.formatCurrency(avgLoss)}`;
                
                // Update account summary with filtered data
                updateAccountSummary(filteredTrades, netPnl);
                
                // Update detailed stats with filtered data
                updateDetailedStats(closedTrades, grossProfit, grossLoss, totalNetProfit, totalNetLoss);
            }
            
            // Function to update detailed stats with filtered data
            function updateDetailedStats(closedTrades, grossProfit, grossLoss, totalNetProfit, totalNetLoss) {
                const container = document.getElementById('reports-metrics-grid');
                if (!container) return;
                
                const metric = (label, value, accent='') => `
                    <div class="flex items-center justify-between py-1 px-2 rounded-md" style="background-color: var(--bg-secondary);">
                        <span class="text-sm" style="color: var(--text-secondary);">${label}</span>
                        <span class="font-semibold ${accent}">${value}</span>
                    </div>`;

                // Override the parent grid layout
                container.className = 'space-y-4';
                container.innerHTML = `
                        <!-- Row 1: Gross Profit and Gross Loss -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Gross Profit', `${window.utils.formatCurrency(grossProfit)}`, 'text-green-500')}
                            ${metric('Gross Loss', `${window.utils.formatCurrency(-grossLoss)}`, 'text-red-500')}
                        </div>
                        
                        <!-- Row 2: Total Net Profit and Total Net Loss -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Total Net Profit', `${window.utils.formatCurrency(totalNetProfit)}`, 'text-green-500')}
                            ${metric('Total Net Loss', `${window.utils.formatCurrency(totalNetLoss)}`, 'text-red-500')}
                        </div>
                        
                        <!-- Row 3: Avg. Stop Loss and Avg. Target Price -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Avg. Stop Loss', `${window.utils.formatCurrency(0)}`)}
                            ${metric('Avg. Target Price', `${window.utils.formatCurrency(0)}`)}
                        </div>
                        
                        <!-- Row 4: Avg. Risk/Reward and Avg. Holding Period -->
                        <div class="grid grid-cols-2 gap-4">
                            ${metric('Avg. Risk/Reward', '0.00')}
                            ${metric('Avg. Holding Period', '0 days')}
                        </div>
                    `;
            }
            
            // Function to update account summary with filtered data
            function updateAccountSummary(filteredTrades, netPnl) {
                const ledger = appState.ledger || [];
                const deposits = ledger.filter(l => l.type === 'Deposit').reduce((sum, l) => sum + (l.amount || 0), 0);
                const withdrawals = ledger.filter(l => l.type === 'Withdrawal').reduce((sum, l) => sum + (l.amount || 0), 0);
                // Deployed capital should be from OPEN trades (not closed trades)
                const deployedCapital = filteredTrades.filter(t => !t.exit_date || !t.exit_price).reduce((sum, t) => sum + ((t.entry_price || 0) * (t.quantity || 0)), 0);
                
                const accountValue = deposits - withdrawals + netPnl;
                const availableCash = Math.max(0, accountValue - deployedCapital);
                
                // Calculate starting balance (first deposit or 0)
                const startingBalance = ledger.length > 0 ? 
                    ledger.filter(l => l.type === 'Deposit')[0]?.amount || 0 : 0;
                
                // Calculate open risk percentage and amount from active trades (same as Fund Management)
                const openRiskData = (() => {
                    const activeTrades = filteredTrades.filter(trade => !trade.exit_date || !trade.exit_price);
                    if (activeTrades.length === 0) return { percentage: 0, amount: 0 };
                    
                    const totalRiskAmount = activeTrades.reduce((total, trade) => {
                        // Risk is the potential loss if trade goes against us
                        // For Long: risk = entry_price * quantity (if price goes to 0)
                        // For Short: risk = (current_price - entry_price) * quantity (if price goes to infinity)
                        const tradeValue = trade.entry_price * trade.quantity;
                        return total + tradeValue;
                    }, 0);
                    
                    const totalAccountValue = accountValue > 0 ? accountValue : 1; // Avoid division by zero
                    const percentage = (totalRiskAmount / totalAccountValue) * 100;
                    
                    return { percentage, amount: totalRiskAmount };
                })();
                
                const summaryEl = document.getElementById('db-account-summary');
                if (summaryEl) {
                    const txt = "text-2xl font-bold";
                    summaryEl.innerHTML = `
                        <div><p class="text-sm" style="color: var(--text-secondary);">NET ACCOUNT VALUE</p><p class="${txt} ${accountValue >= 0 ? 'text-green-500' : 'text-red-500'}">${window.utils.formatCurrency(accountValue)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">NET REALIZED P&L</p><p class="${txt} ${netPnl >= 0 ? 'text-green-500' : 'text-red-500'}">${window.utils.formatCurrency(netPnl)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">AVAILABLE CASH</p><p class="${txt}">${window.utils.formatCurrency(availableCash)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">DEPLOYED CAPITAL</p><p class="${txt}">${window.utils.formatCurrency(deployedCapital)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL DEPOSITS</p><p class="${txt}">${window.utils.formatCurrency(deposits)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">TOTAL WITHDRAWN</p><p class="${txt}">${window.utils.formatCurrency(withdrawals)}</p></div>
                        <div><p class="text-sm" style="color: var(--text-secondary);">STARTING BALANCE</p><p class="${txt}">${window.utils.formatCurrency(startingBalance)}</p></div>
                        <div><p class="text-sm font-medium" style="color: var(--text-secondary);">TOTAL OPEN RISK <span class="text-xs">(${openRiskData.percentage.toFixed(1)}%)</span></p><p class="${txt}">${window.utils.formatCurrency(openRiskData.amount)}</p></div>`;
                }
            }

            // Function to update charts with filtered data (optimized with debouncing)
            let updateChartsTimeout = null;
            function updateCharts(filteredTrades) {
                // Clear existing timeout to prevent excessive updates
                if (updateChartsTimeout) {
                    clearTimeout(updateChartsTimeout);
                }
                
                // Debounce chart updates by 100ms
                updateChartsTimeout = setTimeout(() => {
                    // Only update charts if they exist and are initialized
                    if (typeof renderAllCharts === 'function' && chartInstances) {
                        // Clear chart cache for filtered data
                        performanceCache.clearChartCache();
                        
                        // Store the filtered trades temporarily for chart rendering
                        const originalTrades = appState.trades;
                        appState.trades = filteredTrades;
                        
                        // Re-render all charts with filtered data (force immediate render)
                        renderAllCharts(true);
                        
                        // Restore original trades
                        appState.trades = originalTrades;
                    }
                }, 100);
            }

            // Function to update top trades with filtered data
            function updateTopTradesWithFilter(filteredTrades) {
                try {
                    const closedTrades = filteredTrades.filter(t => t.exit_price && t.exit_date);
                    
                    // Sort by P&L (best first)
                    const sortedTrades = closedTrades
                        .map(trade => ({ ...trade, pnl: calculateNetPnl(trade) }))
                        .sort((a, b) => b.pnl - a.pnl)
                        .slice(0, 5); // Keep default 5 for filtered view
                    
                    const container = document.getElementById('top-trades-widget');
                    if (container) {
                        if (sortedTrades.length === 0) {
                            container.innerHTML = '<p class="text-center text-sm" style="color: var(--text-secondary);">No trades in selected period</p>';
                        } else {
                            container.innerHTML = sortedTrades.map((trade, index) => {
                                const pnl = trade.pnl;
                                const isProfit = pnl > 0;
                                const pnlClass = isProfit ? 'text-green-500' : 'text-red-500';
                                const pnlSign = pnl >= 0 ? '+' : '';
                                
                                return `
                                    <div class="p-2 rounded-lg border" style="background-color: var(--bg-primary); border-color: var(--border-color);">
                                        <div class="flex justify-between items-center">
                                            <div class="flex items-center">
                                                <div class="w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold ${isProfit ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}">
                                                    ${index + 1}
                                                </div>
                                                <div class="ml-2">
                                                    <h4 class="font-semibold text-sm" style="color: var(--text-primary);">${trade.asset || 'N/A'}</h4>
                                                    <p class="text-xs" style="color: var(--text-secondary);">${trade.direction || 'N/A'} • ${window.utils.formatDate(trade.exit_date)}</p>
                                                </div>
                                            </div>
                                            <div class="text-right">
                                                <p class="font-bold text-sm ${pnlClass}">${pnlSign}${window.utils.formatCurrency(pnl)}</p>
                                                <p class="text-xs" style="color: var(--text-muted);">${trade.quantity || 0} qty</p>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                        }
                    }
                    
                    // Also update the new dashboard winners and losers
                    renderDashboardTopWinners();
                    renderDashboardTopLosers();
                } catch (e) {
                    console.error('updateTopTradesWithFilter error', e);
                }
            }

            // Function to update open positions with filtered data
            function updateOpenPositionsWithFilter(filteredTrades) {
                try {
                    const openTrades = filteredTrades.filter(trade => !trade.exit_date || !trade.exit_price);
                    const openTradesCount = openTrades.length;
                    
                    // Update count and pluralization
                    const countEl = document.getElementById('open-positions-count');
                    const pluralEl = document.getElementById('open-positions-plural');
                    const capitalPluralEl = document.getElementById('capital-deployed-plural');
                    
                    if (countEl) countEl.textContent = openTradesCount;
                    if (pluralEl) pluralEl.textContent = openTradesCount === 1 ? '' : 's';
                    if (capitalPluralEl) capitalPluralEl.textContent = openTradesCount === 1 ? '' : 's';
                    
                    // Calculate total deployed capital from filtered open trades
                    let totalDeployedCapital = 0;
                    openTrades.forEach(trade => {
                        const entryPrice = parseFloat(trade.entry_price) || 0;
                        const quantity = parseFloat(trade.quantity) || 0;
                        totalDeployedCapital += entryPrice * quantity;
                    });
                    
                    // Update capital deployed
                    const capitalEl = document.getElementById('capital-deployed-amount');
                    if (capitalEl) capitalEl.textContent = window.utils.formatCurrency(totalDeployedCapital);
                    
                    // Update open positions list
                    const positionsContainer = document.getElementById('open-positions-list');
                    if (positionsContainer) {
                        if (openTrades.length === 0) {
                            positionsContainer.innerHTML = '<p class="text-center text-sm" style="color: var(--text-secondary);">No open positions in selected period</p>';
                        } else {
                            positionsContainer.innerHTML = openTrades.slice(0, 3).map(trade => {
                                const entryPrice = parseFloat(trade.entry_price) || 0;
                                const quantity = parseFloat(trade.quantity) || 0;
                                const totalValue = entryPrice * quantity;
                                
                                return `
                                    <div class="flex justify-between items-center py-0.5 border-b" style="border-color: var(--border-color);">
                                        <div>
                                            <p class="font-medium text-sm" style="color: var(--text-primary);">${trade.asset || 'N/A'}</p>
                                            <p class="text-xs" style="color: var(--text-secondary);">${trade.direction || 'N/A'} • ${window.utils.formatDate(trade.entry_date)}</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="font-medium text-sm" style="color: var(--text-primary);">${window.utils.formatCurrency(totalValue)}</p>
                                            <p class="text-xs" style="color: var(--text-secondary);">${trade.quantity || 0} @ ${window.utils.formatCurrency(trade.entry_price || 0)}</p>
                                        </div>
                                    </div>
                                `;
                            }).join('');
                        }
                    }
                } catch (e) {
                    console.error('updateOpenPositionsWithFilter error', e);
                }
            }

            
            // Initialize dashboard with all data
            setTimeout(() => {
                refreshDashboardData();
            }, 100);
        });

        // Tab functionality
        document.addEventListener('DOMContentLoaded', function() {
            const tradeTab = document.getElementById('trade-tab');
            const journalTab = document.getElementById('journal-tab');
            const tradeTabContent = document.getElementById('trade-tab-content');
            const journalTabContent = document.getElementById('journal-tab-content');
            
            if (tradeTab && journalTab && tradeTabContent && journalTabContent) {
                // Set initial state - Trade tab active
                tradeTab.style.backgroundColor = 'var(--bg-primary)';
                tradeTab.style.color = 'var(--text-primary)';
                journalTab.style.backgroundColor = 'var(--bg-tertiary)';
                journalTab.style.color = 'var(--text-secondary)';
                tradeTabContent.classList.remove('hidden');
                journalTabContent.classList.add('hidden');
                
                // Trade tab click handler
                tradeTab.addEventListener('click', function() {
                    tradeTab.style.backgroundColor = 'var(--bg-primary)';
                    tradeTab.style.color = 'var(--text-primary)';
                    journalTab.style.backgroundColor = 'var(--bg-tertiary)';
                    journalTab.style.color = 'var(--text-secondary)';
                    tradeTabContent.classList.remove('hidden');
                    journalTabContent.classList.add('hidden');
                });
                
                // Journal tab click handler
                journalTab.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Journal tab clicked!');
                    journalTab.style.backgroundColor = 'var(--bg-primary)';
                    journalTab.style.color = 'var(--text-primary)';
                    tradeTab.style.backgroundColor = 'var(--bg-tertiary)';
                    tradeTab.style.color = 'var(--text-secondary)';
                    journalTabContent.classList.remove('hidden');
                    tradeTabContent.classList.add('hidden');
                });
            }
        });

        // --- EXPOSE GLOBAL FUNCTIONS ---
        window.calculateNetPnl = calculateNetPnl;
        window.performanceCache = performanceCache;
        window.statementCache = statementCache;
        window.statementLastHash = statementLastHash;

    </script>

    <!-- Exit Trade Modal -->
    <div id="exit-trade-modal" class="modal-overlay hidden">
        <div class="modal-content max-w-sm sm:max-w-md md:max-w-2xl lg:max-w-2xl" style="background-color: var(--bg-primary); border: 1px solid var(--border-color); box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); padding: 0.75rem; max-height: 90vh; overflow-y: auto;">
            <!-- Header -->
            <div class="flex justify-between items-center mb-2 pb-2 md:mb-4 md:pb-4 border-b" style="border-color: var(--border-color);">
                <div class="flex items-center space-x-3">
                    <h2 id="exit-trade-title" class="text-xl md:text-2xl font-bold" style="color: var(--text-primary);">Exit Trade</h2>
                    <span id="exit-trade-symbol" class="px-3 py-1 text-sm font-semibold rounded-full bg-gray-200 text-gray-700"></span>
                    <span id="exit-trade-status" class="px-2 py-1 text-xs font-semibold rounded-full bg-green-100 text-green-800">Open</span>
                </div>
                <button id="exit-trade-close" class="p-2 rounded-full hover:bg-gray-100" style="color: var(--text-secondary);">
                    <i data-feather="x" class="h-5 w-5"></i>
                </button>
            </div>

            <!-- Tabs -->
            <div class="flex space-x-1 mb-3 md:mb-6">
                <button id="exit-trade-tab" class="px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-blue-500 text-blue-600" style="background-color: var(--bg-primary);">
                    Trade
                </button>
                <button id="exit-journal-tab" class="px-4 py-2 text-sm font-medium rounded-t-lg border-b-2 border-transparent text-gray-500 hover:text-gray-700" style="background-color: var(--bg-primary);">
                    Journal
                </button>
            </div>

            <!-- Trade Tab Content -->
            <div id="exit-trade-content" class="space-y-3 md:space-y-4 lg:space-y-4">
                <!-- Two Column Layout -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3 md:gap-6">
                    <!-- Left Column - Trade Details -->
                    <div class="space-y-2 md:space-y-3 lg:space-y-3">
                        <h3 class="text-sm md:text-base lg:text-lg font-semibold" style="color: var(--text-primary);">Trade Details</h3>
                        <div class="space-y-2 md:space-y-3">
                            <div>
                                <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Direction</label>
                                <input type="text" id="exit-trade-type" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                            </div>
                            
                            <!-- Entry Price and Quantity in one line -->
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Entry Price</label>
                                    <input type="text" id="exit-trade-entry-price" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Quantity</label>
                                    <input type="text" id="exit-trade-quantity" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                                </div>
                            </div>
                            
                            <!-- Stop Loss and Target Price in one line -->
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Stop Loss</label>
                                    <input type="text" id="exit-trade-stop-loss" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Target Price</label>
                                    <input type="text" id="exit-trade-target" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                                </div>
                            </div>
                            
                            <div>
                                <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Total Amount</label>
                                <input type="text" id="exit-trade-total-amount" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" readonly>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column - Exit Details with P&L Summary -->
                    <div class="space-y-2 md:space-y-3 lg:space-y-3">
                        <h3 class="text-sm md:text-base lg:text-lg font-semibold" style="color: var(--text-primary);">Exit Details</h3>
                        <div class="space-y-2 md:space-y-3">
                            <!-- Exit Date and Exit Time in one line -->
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Exit Date</label>
                                    <input type="date" id="exit-trade-date" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Exit Time (Optional)</label>
                                    <input type="time" id="exit-trade-time" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                                </div>
                            </div>
                            
                            <!-- Exit Price and Exit Qty in one line -->
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Exit Price</label>
                                    <input type="number" id="exit-trade-price" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" step="0.01" placeholder="0.00">
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Exit Qty</label>
                                    <input type="number" id="exit-trade-exit-quantity" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" step="1" placeholder="0">
                                </div>
                            </div>
                            
                            <!-- Brokerage and Charges in one line -->
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Brokerage</label>
                                    <input type="number" id="exit-trade-brokerage" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" step="0.01" placeholder="0.00">
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Charges</label>
                                    <input type="number" id="exit-trade-charges" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" step="0.01" placeholder="0.00">
                                </div>
                            </div>
                        </div>
                        
                        <!-- P&L Summary Section -->
                        <div class="mt-6">
                            <div class="space-y-2">
                                <!-- Gross P&L and amount in one line -->
                                <div class="flex items-center justify-between py-1">
                                    <span class="text-sm font-medium" style="color: var(--text-secondary);">Gross P&L</span>
                                    <span id="exit-gross-pnl" class="text-sm font-semibold text-green-600">₹0.00</span>
                                </div>
                                
                                <!-- Total Charges and amount in one line -->
                                <div class="flex items-center justify-between py-1">
                                    <span class="text-sm font-medium" style="color: var(--text-secondary);">Total Charges</span>
                                    <span id="exit-total-charges" class="text-sm font-semibold text-red-600">₹0.00</span>
                                </div>
                                
                                <!-- Net P&L Amount and amount in one line -->
                                <div class="flex items-center justify-between py-1">
                                    <span class="text-sm font-medium" style="color: var(--text-secondary);">Net P&L Amount</span>
                                    <span id="exit-net-pnl" class="text-sm font-semibold text-green-600">₹0.00</span>
                                </div>
                                
                                <!-- P&L (%) and percentage in one line -->
                                <div class="flex items-center justify-between py-1">
                                    <span class="text-sm font-medium" style="color: var(--text-secondary);">P&L (%)</span>
                                    <span id="exit-pnl-percentage" class="text-sm font-semibold text-green-600">0.00%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Journal Tab Content -->
            <div id="exit-journal-content" class="space-y-6 hidden">
                <!-- Two Column Layout -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Left Column - Strategy Tag and Psychology -->
                    <div class="space-y-6">
                        <!-- Strategy Tag Section -->
                        <div class="p-4 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <h3 class="text-lg font-semibold mb-4" style="color: var(--text-primary);">Strategy and Outcome</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-medium mb-1" style="color: var(--text-secondary);">Strategy Tag</label>
                                    <select id="exit-strategy" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                                        <option value="Price Action">Price Action</option>
                                        <option value="Support/Resistance">Support/Resistance</option>
                                        <option value="Trend Following">Trend Following</option>
                                        <option value="Breakout">Breakout</option>
                                        <option value="Reversal">Reversal</option>
                                        <option value="Scalping">Scalping</option>
                                        <option value="Swing Trading">Swing Trading</option>
                                        <option value="News Trading">News Trading</option>
                                        <option value="Technical Analysis">Technical Analysis</option>
                                        <option value="Fundamental Analysis">Fundamental Analysis</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Psychology Section -->
                        <div class="p-4 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <h3 class="text-sm md:text-base font-semibold mb-3 md:mb-4" style="color: var(--text-primary);">Psychology</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Emotional State During Trade</label>
                                    <select id="exit-emotional-state" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                                        <option value="">Select Emotional state</option>
                                        <option value="Confident">Confident</option>
                                        <option value="Nervous">Nervous</option>
                                        <option value="Excited">Excited</option>
                                        <option value="Fearful">Fearful</option>
                                        <option value="Greedy">Greedy</option>
                                        <option value="Calm">Calm</option>
                                        <option value="Frustrated">Frustrated</option>
                                        <option value="Overconfident">Overconfident</option>
                                        <option value="Indecisive">Indecisive</option>
                                        <option value="Patient">Patient</option>
                                        <option value="Impatient">Impatient</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-xs md:text-sm font-medium mb-1" style="color: var(--text-secondary);">Mistake Made</label>
                                    <div class="grid grid-cols-2 gap-2">
                                        <div class="space-y-2">
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Overtrading" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Overtrading</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Exited Too Late" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Exited Too Late</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Ignored Stop loss" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Ignored Stop loss</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Exited Too Early" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Exited Too Early</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="No clean Plan" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">No clean Plan</span>
                                            </label>
                                        </div>
                                        <div class="space-y-2">
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Risked Too Much" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Risked Too Much</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Ignored signals" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Ignored signals</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Revenge signals" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Revenge signals</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="Revenge Trading" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">Revenge Trading</span>
                                            </label>
                                            <label class="flex items-center text-xs">
                                                <input type="checkbox" name="exit-mistakes" value="No Mistake" class="mr-2 h-4 w-4 rounded" style="border-color: var(--border-color); background-color: var(--bg-primary);">
                                                <span style="color: var(--text-primary);">No Mistake</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Column - Outcome Summary and Trade Journal & Notes -->
                    <div class="space-y-6">
                        <!-- Outcome Summary Section -->
                        <div class="p-4 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <h3 class="text-lg font-semibold mb-4" style="color: var(--text-primary);">Strategy and Outcome</h3>
                            <div class="space-y-4">
                                <div>
                                    <label class="block text-sm font-medium mb-1" style="color: var(--text-secondary);">Outcome Summary</label>
                                    <select id="exit-outcome-summary" class="w-full px-3 py-2 text-sm border rounded-md" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                                        <option value="Select outcome summary">Select outcome summary</option>
                                        <option value="Target Hit">Target Hit</option>
                                        <option value="Stop Loss Hit">Stop Loss Hit</option>
                                        <option value="Exited Early (Profit)">Exited Early (Profit)</option>
                                        <option value="Exited Early (Loss)">Exited Early (Loss)</option>
                                        <option value="Break Even">Break Even</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <!-- Trade Journal & Notes Section -->
                        <div class="p-4 rounded-lg" style="background-color: var(--bg-secondary); border: 1px solid var(--border-color);">
                            <h3 class="text-lg font-semibold mb-4" style="color: var(--text-primary);">Trade Journal & Notes</h3>
                            <div>
                                <label class="block text-sm font-medium mb-1" style="color: var(--text-secondary);">Reason for entry/exit, learning, etc.</label>
                                <textarea id="exit-trade-notes" rows="8" class="w-full px-3 py-2 text-sm border rounded-md resize-none" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);" placeholder="What was your thesis for this trade? What did you learn?"></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-end space-x-3 mt-3 pt-2 md:mt-6 md:pt-4 border-t" style="border-color: var(--border-color);">
                <button id="exit-trade-cancel" class="px-4 py-2 text-xs md:text-sm font-medium border rounded-md hover:bg-gray-50" style="background-color: var(--bg-primary); border-color: var(--border-color); color: var(--text-primary);">
                    Cancel
                </button>
                <button id="exit-trade-submit" class="px-4 py-2 text-xs md:text-sm font-medium rounded-md hover:bg-gray-800" style="background-color: var(--text-primary); color: var(--bg-primary);">
                    Exit Trade
                </button>
            </div>
        </div>
    </div>

    <!-- Custom Tooltip Container for Accessibility -->
    <div id="chartjs-custom-tooltip" aria-live="polite" role="tooltip" aria-hidden="true"></div>
</body>
</html>

